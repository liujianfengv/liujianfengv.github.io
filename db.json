{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/white/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/white/source/fonts/chinese-zodiac.eot","path":"fonts/chinese-zodiac.eot","modified":0,"renderable":1},{"_id":"themes/white/source/fonts/chinese-zodiac.woff","path":"fonts/chinese-zodiac.woff","modified":0,"renderable":1},{"_id":"themes/white/source/fonts/chinese-zodiac.woff2","path":"fonts/chinese-zodiac.woff2","modified":0,"renderable":1},{"_id":"themes/white/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/white/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/white/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/white/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/white/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/white/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/white/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/white/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/white/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/white/source/js/firework.js","path":"js/firework.js","modified":0,"renderable":1},{"_id":"themes/white/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/white/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/white/source/js/todark.js","path":"js/todark.js","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/dark.styl","path":"css/partial/dark.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/header.styl","path":"css/partial/header.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/fonts.styl","path":"css/partial/fonts.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight.styl","path":"css/partial/highlight.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/local-search.styl","path":"css/partial/local-search.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/media.styl","path":"css/partial/media.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/post.styl","path":"css/partial/post.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/reward.styl","path":"css/partial/reward.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/recent-posts.styl","path":"css/partial/recent-posts.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/a11y-dark.css","path":"css/partial/highlight/a11y-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/a11y-light.css","path":"css/partial/highlight/a11y-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/agate.css","path":"css/partial/highlight/agate.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/androidstudio.css","path":"css/partial/highlight/androidstudio.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/an-old-hope.css","path":"css/partial/highlight/an-old-hope.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/arduino-light.css","path":"css/partial/highlight/arduino-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/arta.css","path":"css/partial/highlight/arta.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/ascetic.css","path":"css/partial/highlight/ascetic.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-cave-dark.css","path":"css/partial/highlight/atelier-cave-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-dune-dark.css","path":"css/partial/highlight/atelier-dune-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-cave-light.css","path":"css/partial/highlight/atelier-cave-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-dune-light.css","path":"css/partial/highlight/atelier-dune-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-estuary-dark.css","path":"css/partial/highlight/atelier-estuary-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-estuary-light.css","path":"css/partial/highlight/atelier-estuary-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-forest-light.css","path":"css/partial/highlight/atelier-forest-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-forest-dark.css","path":"css/partial/highlight/atelier-forest-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-heath-light.css","path":"css/partial/highlight/atelier-heath-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-heath-dark.css","path":"css/partial/highlight/atelier-heath-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-lakeside-dark.css","path":"css/partial/highlight/atelier-lakeside-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-lakeside-light.css","path":"css/partial/highlight/atelier-lakeside-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-plateau-light.css","path":"css/partial/highlight/atelier-plateau-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-plateau-dark.css","path":"css/partial/highlight/atelier-plateau-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-savanna-light.css","path":"css/partial/highlight/atelier-savanna-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-savanna-dark.css","path":"css/partial/highlight/atelier-savanna-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-seaside-dark.css","path":"css/partial/highlight/atelier-seaside-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-seaside-light.css","path":"css/partial/highlight/atelier-seaside-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-sulphurpool-dark.css","path":"css/partial/highlight/atelier-sulphurpool-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atelier-sulphurpool-light.css","path":"css/partial/highlight/atelier-sulphurpool-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atom-one-dark-reasonable.css","path":"css/partial/highlight/atom-one-dark-reasonable.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atom-one-light.css","path":"css/partial/highlight/atom-one-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/atom-one-dark.css","path":"css/partial/highlight/atom-one-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/brown-paper.css","path":"css/partial/highlight/brown-paper.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/codepen-embed.css","path":"css/partial/highlight/codepen-embed.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/color-brewer.css","path":"css/partial/highlight/color-brewer.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/darcula.css","path":"css/partial/highlight/darcula.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/dark.css","path":"css/partial/highlight/dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/default.css","path":"css/partial/highlight/default.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/docco.css","path":"css/partial/highlight/docco.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/far.css","path":"css/partial/highlight/far.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/dracula.css","path":"css/partial/highlight/dracula.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/github-gist.css","path":"css/partial/highlight/github-gist.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/foundation.css","path":"css/partial/highlight/foundation.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/github.css","path":"css/partial/highlight/github.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/gml.css","path":"css/partial/highlight/gml.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/googlecode.css","path":"css/partial/highlight/googlecode.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/gradient-dark.css","path":"css/partial/highlight/gradient-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/grayscale.css","path":"css/partial/highlight/grayscale.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/gruvbox-light.css","path":"css/partial/highlight/gruvbox-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/gruvbox-dark.css","path":"css/partial/highlight/gruvbox-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/hopscotch.css","path":"css/partial/highlight/hopscotch.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/hybrid.css","path":"css/partial/highlight/hybrid.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/idea.css","path":"css/partial/highlight/idea.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/ir-black.css","path":"css/partial/highlight/ir-black.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/isbl-editor-dark.css","path":"css/partial/highlight/isbl-editor-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/isbl-editor-light.css","path":"css/partial/highlight/isbl-editor-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/kimbie.dark.css","path":"css/partial/highlight/kimbie.dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/kimbie.light.css","path":"css/partial/highlight/kimbie.light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/lightfair.css","path":"css/partial/highlight/lightfair.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/lioshi.css","path":"css/partial/highlight/lioshi.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/magula.css","path":"css/partial/highlight/magula.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/mono-blue.css","path":"css/partial/highlight/mono-blue.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/monokai.css","path":"css/partial/highlight/monokai.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/monokai-sublime.css","path":"css/partial/highlight/monokai-sublime.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/night-owl.css","path":"css/partial/highlight/night-owl.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/nnfx-dark.css","path":"css/partial/highlight/nnfx-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/nnfx.css","path":"css/partial/highlight/nnfx.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/obsidian.css","path":"css/partial/highlight/obsidian.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/nord.css","path":"css/partial/highlight/nord.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/ocean.css","path":"css/partial/highlight/ocean.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/paraiso-dark.css","path":"css/partial/highlight/paraiso-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/paraiso-light.css","path":"css/partial/highlight/paraiso-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/pojoaque.css","path":"css/partial/highlight/pojoaque.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/purebasic.css","path":"css/partial/highlight/purebasic.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/qtcreator_dark.css","path":"css/partial/highlight/qtcreator_dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/qtcreator_light.css","path":"css/partial/highlight/qtcreator_light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/railscasts.css","path":"css/partial/highlight/railscasts.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/rainbow.css","path":"css/partial/highlight/rainbow.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/routeros.css","path":"css/partial/highlight/routeros.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/school-book.css","path":"css/partial/highlight/school-book.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/solarized-dark.css","path":"css/partial/highlight/solarized-dark.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/shades-of-purple.css","path":"css/partial/highlight/shades-of-purple.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/srcery.css","path":"css/partial/highlight/srcery.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/solarized-light.css","path":"css/partial/highlight/solarized-light.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night-blue.css","path":"css/partial/highlight/tomorrow-night-blue.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/sunburst.css","path":"css/partial/highlight/sunburst.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night-bright.css","path":"css/partial/highlight/tomorrow-night-bright.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night-eighties.css","path":"css/partial/highlight/tomorrow-night-eighties.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night.css","path":"css/partial/highlight/tomorrow-night.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/vs.css","path":"css/partial/highlight/vs.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/vs2015.css","path":"css/partial/highlight/vs2015.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/tomorrow.css","path":"css/partial/highlight/tomorrow.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/xcode.css","path":"css/partial/highlight/xcode.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/xt256.css","path":"css/partial/highlight/xt256.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/highlight/zenburn.css","path":"css/partial/highlight/zenburn.css","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/tag_plugin/note.styl","path":"css/partial/tag_plugin/note.styl","modified":0,"renderable":1},{"_id":"themes/white/source/css/partial/tag_plugin/tags.styl","path":"css/partial/tag_plugin/tags.styl","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"54d62e828f45ebd3ebd60b87f6d332379198381a","modified":1635683018792},{"_id":"source/_posts/Learn-shared-ptr-by-Error.md","hash":"96f7f23e2b59102b9b37bfaf9942e98a59b4181e","modified":1646320116939},{"_id":"source/_posts/MQTT基础文档翻译-一-MQTT协议介绍.md","hash":"877b0dba848111c733efbd26e2d9f989388188a8","modified":1636788432189},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释.md","hash":"b96f4df56a23133ac2fb5b036c22331db31aa107","modified":1638374558381},{"_id":"source/_posts/MQTT基础文档翻译-二-发布和订阅.md","hash":"02fc792613d305c63bed042c61ecb66f03a426a6","modified":1636790261300},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践.md","hash":"961408ea0b55ad4dcc392a8c7f29d4aa9189de93","modified":1646150907543},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅.md","hash":"b8a8e7896081d74399987567c57e08e2c9058a30","modified":1646150705465},{"_id":"source/_posts/ProtoBuf为什么比Json快.md","hash":"79be0b67b97610a3fd3b7a18aee02439064d7c48","modified":1641487332386},{"_id":"source/_posts/Qt信号槽机制浅析.md","hash":"4352251e60052d165fbe7c3ee2bfe31aef0b8cf7","modified":1636790459480},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connack1.png","hash":"b542c7e60067cda6a88dccdb5ad9f7668602f6eb","modified":1637249360659},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connect-flow.gif","hash":"79e4ae8e65dc2b243ff142d14a0b9d5881f980c2","modified":1636989272226},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/mqtt-tcp-ip-stack.png","hash":"cc5d9dc3a7ec7ee1cea4487519991d7ca4929fa8","modified":1636989034178},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connect.png","hash":"6859d17c03eb36266436572fbd11fe2e7dcc281f","modified":1636990089447},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/retcode.png","hash":"553220db2f0b8065f8ed6dff10aad2c173bb4612","modified":1637249486366},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_basics.png","hash":"682a4ba240c2c1d09959872788eff9efe9f3071c","modified":1645977276265},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_plus.png","hash":"afc2763e9e71945a3fb03af9387b6474611745e5","modified":1646144746570},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_hash.png","hash":"a5cd8a62e6c2be07444abc0a5f44b68fa922a920","modified":1646145503166},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_plus_example.png","hash":"5038f5a437033f7aa7d72bf3eb229a20d676553b","modified":1646144953031},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/publish_flow.png","hash":"53debbe98c9b5163e34e017fa58aa8ec635a760c","modified":1645112387129},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/return_code.png","hash":"75c011702040352538d844d14de443688fb45674","modified":1645195592143},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/publish_packet.png","hash":"9ca2eb21303351f6f9c8943b8a0caa9cae72af30","modified":1645110479176},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/suback_packet.png","hash":"9ea37b67f389572502dd3bcf4c7fd86caccb3632","modified":1645195119147},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/subscribe_flow.png","hash":"03942ac175d33f9284d97bd76df9893c03bfae25","modified":1645195658526},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/subscribe_packet.png","hash":"760a3477e43a5e14625c08afb8e4236664abdfb8","modified":1645194623766},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsuback_packet.png","hash":"43dbfb04b3f687a83ced79f8fc31e04d62846330","modified":1645196365469},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsubscribe_flow.png","hash":"d332bbad21ad75055c35ff534bb604c45067a68d","modified":1645196587829},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsubscribe_packet.png","hash":"884300d567428cd1ed22f2d6f2f6489acdf4de6a","modified":1645195951620},{"_id":"source/_posts/ProtoBuf为什么比Json快/wire_types.png","hash":"d0683780eeca7b87a44b26b56d67e20fde09996e","modified":1639063103746},{"_id":"source/_posts/MQTT基础文档翻译-二-发布和订阅/mqtt-publish-subscribe.svg","hash":"cea410816d440b3b9e8bf97334795e235467bad6","modified":1636645688205},{"_id":"source/_posts/ProtoBuf为什么比Json快/debug_protoc.png","hash":"83312fe7ffc6dca3c57d7e9d813cfc1066cccdf9","modified":1640796484030},{"_id":"themes/white/LICENSE","hash":"7306544691069be1d116c2b38daecdcb012fd0dd","modified":1635678906255},{"_id":"themes/white/README.md","hash":"1b72ea05ed7672549130bacee474782c69967a91","modified":1635678906255},{"_id":"themes/white/_config.yml","hash":"8e5090b0295d76c4890ac08fda886164c5f7b229","modified":1641911980660},{"_id":"themes/white/languages/zh-CN.yml","hash":"aed84280f7b8dc71f57db01ff4b43daebc5f9c77","modified":1635678906256},{"_id":"themes/white/languages/en.yml","hash":"e0d12361d230a271defd9618b1c645df63f5d3ef","modified":1635678906256},{"_id":"themes/white/layout/404.ejs","hash":"4153b9d446d6c4e10691d479184853975792f450","modified":1635678906256},{"_id":"themes/white/layout/archive.ejs","hash":"23d476da388281955ed84dd842b33e886b1c7da7","modified":1635678906256},{"_id":"themes/white/layout/category.ejs","hash":"16480bc7ff1b0ffbce4cf384eebdfa9485a78abc","modified":1635678906256},{"_id":"themes/white/layout/index.ejs","hash":"fdaf171dc0309a64fa0e537420339015ce924207","modified":1635678906257},{"_id":"themes/white/layout/layout.ejs","hash":"d3956666af7fcdb11bff5689a23f6bb0a5f3d32f","modified":1635678906257},{"_id":"themes/white/layout/post.ejs","hash":"910e1eab4ae13e3d9d937ba8ac9b56c8ba5d9c28","modified":1635678906263},{"_id":"themes/white/layout/page.ejs","hash":"12b2f3acfc43332f32c6ae82aab00a8324a3a363","modified":1635678906257},{"_id":"themes/white/layout/tag.ejs","hash":"cc4df43f5b2af885f56500b6a6d1c9ba38f88398","modified":1635678906263},{"_id":"themes/white/scripts/404.js","hash":"e2e5a51c45dc0aa0e6a03e92cb16d84fc5460508","modified":1635678906263},{"_id":"themes/white/scripts/mermaid.js","hash":"90fc166acbaa8b3ec61c8d042ff43af1c0db039f","modified":1635678906263},{"_id":"themes/white/scripts/post_lazyload.js","hash":"989aaee619bc83b0f22cf17297282fbd5726135a","modified":1635678906263},{"_id":"themes/white/scripts/replace_config.js","hash":"0ff46c45db709a6e8c64601dc1096b920f617f20","modified":1635678906264},{"_id":"themes/white/layout/partial/archive.ejs","hash":"4c97df9059eec52cf2837bc5bc72d7967a3d65c9","modified":1635678906260},{"_id":"themes/white/scripts/wordcount.js","hash":"6bf77eedbaf12f78d6dae2f0c48e85707a73b4cd","modified":1635678906265},{"_id":"themes/white/scripts/year.js","hash":"a931302e8702644d0c80e8f85d379145f2a8cf09","modified":1635678906265},{"_id":"themes/white/layout/partial/article.ejs","hash":"80e49811682c805b7823033c4471df2d14c15935","modified":1635678906261},{"_id":"themes/white/layout/partial/footer.ejs","hash":"f8c087785a7b77e473657f8b18e8f8b590e57d84","modified":1635678906261},{"_id":"themes/white/layout/partial/categories.ejs","hash":"312c0125e09e6c0f9be7fadbf434e816c41bc4ee","modified":1635678906261},{"_id":"themes/white/layout/partial/head.ejs","hash":"00d6ac0c57d14f7d890121f61324d1ef0dc145d5","modified":1635678906261},{"_id":"themes/white/layout/partial/gotop.ejs","hash":"fa16fa8d0bebeb39c85bf56249323ce8ffd7973d","modified":1635678906261},{"_id":"themes/white/layout/partial/header.ejs","hash":"956d5fa8ac05189973f61a37a306993f1a10373a","modified":1635678906261},{"_id":"themes/white/layout/partial/mobile-header.ejs","hash":"fc681d602911b69406935845f61897605e9c0e70","modified":1635678906262},{"_id":"themes/white/layout/partial/link.ejs","hash":"4f2be13551a04d43d8998446bc8ff64553d5ec75","modified":1635678906261},{"_id":"themes/white/layout/partial/page.ejs","hash":"c281bd8ed5c3883363588df916892459a3f275e5","modified":1635678906262},{"_id":"themes/white/layout/partial/paginator.ejs","hash":"935b7bc0da2ab34893b15c048bc4df9e35892594","modified":1635678906262},{"_id":"themes/white/layout/partial/post-meta.ejs","hash":"74f71905ef4762f5220be324e62b085643b1dc3e","modified":1635678906262},{"_id":"themes/white/layout/partial/recent-posts.ejs","hash":"98cb6264e01a6a50992e4099c7929038bedb1fc0","modified":1635678906262},{"_id":"themes/white/layout/partial/tags.ejs","hash":"16d8d762ae14ba488179d5684786059afefc8c0d","modified":1635678906263},{"_id":"themes/white/layout/partial/script.ejs","hash":"2c7909df68d5c7099a97d562ac6f9447e52c3e78","modified":1635678906262},{"_id":"themes/white/source/css/style.styl","hash":"92b97de50d6ac6ddac513e1329dd07209b8bd0c3","modified":1636295885781},{"_id":"themes/white/source/css/var.styl","hash":"ffc6591955c06ff6bd1e7ec41b3700a015a63904","modified":1635678906282},{"_id":"themes/white/source/fonts/chinese-zodiac.woff","hash":"bf8137ae4b8a1e11bc5480ba5af2d44244d13f99","modified":1635678906283},{"_id":"themes/white/source/fonts/chinese-zodiac.eot","hash":"e3ea84e00f4fae1bbf157650ed09000299ea8c7b","modified":1635678906283},{"_id":"themes/white/source/fonts/chinese-zodiac.woff2","hash":"96af181d987ecc97bf9f1fe12df883102bdc18a4","modified":1635678906283},{"_id":"themes/white/source/img/alipay.svg","hash":"292ea040e865c1d0be259703ff850570b3bdfc97","modified":1635678906285},{"_id":"themes/white/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1635678906285},{"_id":"themes/white/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1635678906285},{"_id":"themes/white/source/img/paypal.svg","hash":"1dfd643ce13dec27c63847acd6acf3eb17bb598e","modified":1635678906285},{"_id":"themes/white/source/img/loading.gif","hash":"dabf141cac0a42a8dbfb8844e9a8fb1d1f3fceab","modified":1635678906285},{"_id":"themes/white/source/img/wechat.svg","hash":"6d08667c5881e66d20df72bf2214bae55396554b","modified":1635678906286},{"_id":"themes/white/source/js/firework.js","hash":"038d20368a9ee07eb9af9a1a15fd86aa506e8a1a","modified":1635678906287},{"_id":"themes/white/source/js/local-search.js","hash":"affa02ea82b2d5c2331e309aa8f6a7e77d2494e5","modified":1635678906287},{"_id":"themes/white/source/js/script.js","hash":"cbeb616c07dfbd74f5ce0aec7a2158e041e5eba1","modified":1635678906287},{"_id":"themes/white/source/js/todark.js","hash":"d910646651c9f749ff7b8045d1e57487b3fe48bb","modified":1635678906287},{"_id":"themes/white/scripts/tags/btns.js","hash":"1634b36c52d25bd028c352c0fbc7a0042263466d","modified":1635678906264},{"_id":"themes/white/scripts/tags/folding.js","hash":"161550da7b428d0d1b0ae4216bef5219751d1b54","modified":1635678906264},{"_id":"themes/white/scripts/tags/tabs.js","hash":"6ddb21fe88dab585f4be3ac372494fd74cb530cb","modified":1635678906264},{"_id":"themes/white/scripts/tags/checkbox.js","hash":"c89b133be596c1fd93d79004f91e915bf6142d73","modified":1635678906264},{"_id":"themes/white/scripts/tags/note.js","hash":"b435f1edd9f3ba77af4c05e0191efd130fb5255f","modified":1635678906264},{"_id":"themes/white/layout/partial/_comment/index.ejs","hash":"9bb8110bf015e1e1ed0e0185139a26ef1ba7384c","modified":1635678906257},{"_id":"themes/white/layout/partial/_comment/waline.ejs","hash":"c5a2080804a59ebe589514218e5d7937080531f8","modified":1635678906258},{"_id":"themes/white/layout/partial/_comment/valine.ejs","hash":"99a997833dee225a82c2685feac4baa02513605e","modified":1635678906257},{"_id":"themes/white/layout/partial/_maths/mermaid.ejs","hash":"91fe441e9dce2a67550b87d7c7d1d69cfa95c4e9","modified":1635678906258},{"_id":"themes/white/layout/partial/_search/local-search.ejs","hash":"5b3506051d3298b1b4e569e4020d18ccefcf6744","modified":1635678906260},{"_id":"themes/white/layout/partial/_maths/mathjax.ejs","hash":"fc5d45d621e43406894a3d67665a271460827091","modified":1635678906258},{"_id":"themes/white/layout/partial/_search/local-searchjs.ejs","hash":"a6aa5505a80a29245b69a37372f45ea9c900f950","modified":1635678906260},{"_id":"themes/white/layout/partial/_modify/fancybox.ejs","hash":"267c9c0e272b2506f666bd53d3eccb4e0be194a0","modified":1635678906259},{"_id":"themes/white/layout/partial/_modify/audio.ejs","hash":"a36d2adae20fecc4839d217ea576e7b69f7e98c1","modified":1635678906258},{"_id":"themes/white/layout/partial/_modify/sharejs.ejs","hash":"d33cb5e12a4ec8a3e815cea09e7466fa5c0e79cf","modified":1635678906259},{"_id":"themes/white/layout/partial/_modify/copy.ejs","hash":"efc46186b2845fba38cbefc6fb5a9091e94644b9","modified":1635678906258},{"_id":"themes/white/layout/partial/_modify/lazyload.ejs","hash":"89b90290a1d491defa247a54ff80a9d9ed404cbc","modified":1635678906259},{"_id":"themes/white/layout/partial/_third-party/baidu-analytics.ejs","hash":"5b0b97b24878160ccf4ca392ac5103719110d74b","modified":1635678906260},{"_id":"themes/white/layout/partial/_third-party/baidu-push.ejs","hash":"96908d8c44f84deb42735d5a6db1154fadd51e7e","modified":1635678906260},{"_id":"themes/white/layout/partial/_third-party/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1635678906260},{"_id":"themes/white/source/css/partial/dark.styl","hash":"06d1bf80b27c47fde7b0fcce7c4b4f2fa313e364","modified":1635678906265},{"_id":"themes/white/source/css/partial/fonts.styl","hash":"a9f8b10fafb5cd6d70572c1bf0d6cd9507c779b0","modified":1635678906265},{"_id":"themes/white/source/css/partial/header.styl","hash":"ba1bfb7863938a0f7ca5d6a62c299f54eb109315","modified":1635678906265},{"_id":"themes/white/source/css/partial/highlight.styl","hash":"eafd0965ad02dee18325f0a22998b1ab16ea3b99","modified":1640487250980},{"_id":"themes/white/source/css/partial/local-search.styl","hash":"573d2714c55f381e3c92acb143a839fd3718aa8e","modified":1635678906281},{"_id":"themes/white/source/css/partial/media.styl","hash":"1e881b0484768fd7d3ebb4e99bd78cdfd0f15949","modified":1635678906281},{"_id":"themes/white/source/css/partial/post.styl","hash":"50f664ee85ab8d8873ecf09693697d67ba831383","modified":1636790402698},{"_id":"themes/white/source/css/partial/recent-posts.styl","hash":"74b532f862b3122835732f6affd5337f41967218","modified":1635678906281},{"_id":"themes/white/source/css/partial/reward.styl","hash":"cba0a0833b396f91cbc13be109f3e815e964de70","modified":1635678906282},{"_id":"themes/white/layout/partial/_modify/rewards/reward.ejs","hash":"3bd17a0bc81243d580bd14b267b763dd053f04fe","modified":1635678906259},{"_id":"themes/white/layout/partial/_modify/rewards/rewardjs.ejs","hash":"382b0c71c0c91d58777bf00b4219de661f6232b8","modified":1635678906259},{"_id":"themes/white/source/css/partial/highlight/a11y-dark.css","hash":"6d0c9b42bb12c36095fb765daeae680f6264dc3a","modified":1635678906266},{"_id":"themes/white/source/css/partial/highlight/a11y-light.css","hash":"96010219f371f28085e1f222aa1a7eb001805bcc","modified":1635678906266},{"_id":"themes/white/source/css/partial/highlight/agate.css","hash":"a2e0c77549f832217cc1d70bf23c033dd007acdc","modified":1635678906266},{"_id":"themes/white/source/css/partial/highlight/androidstudio.css","hash":"0deff643b52a52605b78d54a081707d39df03bed","modified":1635678906266},{"_id":"themes/white/source/css/partial/highlight/an-old-hope.css","hash":"94c46eea4ab15cb0f093361bb3c4279cac5f1fe1","modified":1635678906266},{"_id":"themes/white/source/css/partial/highlight/arduino-light.css","hash":"34643df1a21951859eef3182a6e771352d9b07fa","modified":1635678906267},{"_id":"themes/white/source/css/partial/highlight/arta.css","hash":"84b10a804a198e9f3010971bc7cfaabbf4299d75","modified":1635678906267},{"_id":"themes/white/source/css/partial/highlight/ascetic.css","hash":"23edee489d7d42ac15e94f2c0df8af9e1bbdecf7","modified":1635678906267},{"_id":"themes/white/source/css/partial/highlight/atelier-cave-dark.css","hash":"4a7e94f97c73bdb807cb3b3fde8cb3ebf9fabb9c","modified":1635678906267},{"_id":"themes/white/source/css/partial/highlight/atelier-dune-dark.css","hash":"f6769c7b68f938059ec7257a8f07aa214d9569a3","modified":1635678906268},{"_id":"themes/white/source/css/partial/highlight/atelier-cave-light.css","hash":"ff964bba2eb5a4281d4f273f1af33c7b7cba720f","modified":1635678906267},{"_id":"themes/white/source/css/partial/highlight/atelier-dune-light.css","hash":"e54adb3a7061bb9c40398d15b4166f94b13edc6a","modified":1635678906268},{"_id":"themes/white/source/css/partial/highlight/atelier-estuary-dark.css","hash":"23cb99fb223dd7d3c36ab12a1e2e8c9801d87f6b","modified":1635678906268},{"_id":"themes/white/source/css/partial/highlight/atelier-forest-light.css","hash":"1b76cb6fe52cb4e505ededdcb8b0b8981a9002ed","modified":1635678906268},{"_id":"themes/white/source/css/partial/highlight/atelier-estuary-light.css","hash":"711dfeb0edbe6f57c570367470b6ab907cf46cf1","modified":1635678906268},{"_id":"themes/white/source/css/partial/highlight/atelier-heath-light.css","hash":"0e85bb6e24f9f2cc1b00a488be3d83e55fcd47b3","modified":1635678906269},{"_id":"themes/white/source/css/partial/highlight/atelier-forest-dark.css","hash":"2e0a7cdcca2a1d2c4b3e2e8a4249f50cfe59410a","modified":1635678906268},{"_id":"themes/white/source/css/partial/highlight/atelier-heath-dark.css","hash":"ede696513d4997a143e479d7c09cd89749c99933","modified":1635678906268},{"_id":"themes/white/source/css/partial/highlight/atelier-lakeside-light.css","hash":"25934f2bfe7f71282495569f2173b172f04dc35e","modified":1635678906269},{"_id":"themes/white/source/css/partial/highlight/atelier-lakeside-dark.css","hash":"58e579c0121eedeead5baf31ecb3213b592b019f","modified":1635678906269},{"_id":"themes/white/source/css/partial/highlight/atelier-plateau-light.css","hash":"0455d731fb3af3fee0cc489860528fb4919c69ca","modified":1635678906269},{"_id":"themes/white/source/css/partial/highlight/atelier-plateau-dark.css","hash":"22cb142ef6f6f4f8687214e15729d6b704bf2b0c","modified":1635678906269},{"_id":"themes/white/source/css/partial/highlight/atelier-savanna-light.css","hash":"b519a41e09b5449f03520b043443652b9ee5dc91","modified":1635678906270},{"_id":"themes/white/source/css/partial/highlight/atelier-seaside-dark.css","hash":"a8f0182bff79292ba8ab6c65c562a6692333891d","modified":1635678906270},{"_id":"themes/white/source/css/partial/highlight/atelier-savanna-dark.css","hash":"c686abc9c55ec430cae77d7da9e5ad90c1f593e8","modified":1635678906269},{"_id":"themes/white/source/css/partial/highlight/atelier-seaside-light.css","hash":"0e88d434a404bb1f2c84ab935342c2f4f3901a28","modified":1635678906270},{"_id":"themes/white/source/css/partial/highlight/atelier-sulphurpool-dark.css","hash":"d56391073d8ea82dc91bdb461c83631a47cca82f","modified":1635678906270},{"_id":"themes/white/source/css/partial/highlight/atelier-sulphurpool-light.css","hash":"f06168bf8e89838c31910697a1f637b30099986f","modified":1635678906270},{"_id":"themes/white/source/css/partial/highlight/atom-one-dark-reasonable.css","hash":"e86ca6ffcdb5371eba9e99e88d7ddb2412950aa1","modified":1635678906270},{"_id":"themes/white/source/css/partial/highlight/atom-one-light.css","hash":"c206ead3be5954f4c125311217d8e250edf6e63c","modified":1635678906271},{"_id":"themes/white/source/css/partial/highlight/brown-paper.css","hash":"05b31c40094f2912a370a12ce252b1f56a4b8f38","modified":1635678906271},{"_id":"themes/white/source/css/partial/highlight/atom-one-dark.css","hash":"031c3c1e59406e0658e7f1197fe6d6a5029c3055","modified":1635678906270},{"_id":"themes/white/source/css/partial/highlight/codepen-embed.css","hash":"d3e1fec332a44f96817129e7ff4c9f23defcbd40","modified":1635678906271},{"_id":"themes/white/source/css/partial/highlight/color-brewer.css","hash":"1c952672bafab7dff6da2354741e813cc045d8d7","modified":1635678906271},{"_id":"themes/white/source/css/partial/highlight/darcula.css","hash":"5a8a0f2b61c9c935d92d34ef38b989805a6e978e","modified":1635678906271},{"_id":"themes/white/source/css/partial/highlight/dark.css","hash":"cd37c30905f983490a7f0d4647a11171f483f812","modified":1635678906271},{"_id":"themes/white/source/css/partial/highlight/default.css","hash":"daab0ef2a4a5e7c856209bcc35de1dbff9665d22","modified":1635678906272},{"_id":"themes/white/source/css/partial/highlight/far.css","hash":"9a2331bd7def5bb1ef35c2575ba5ea1cccab8acf","modified":1635678906272},{"_id":"themes/white/source/css/partial/highlight/docco.css","hash":"a8fc483604b2cab5ffe166bb598e922024f79014","modified":1635678906272},{"_id":"themes/white/source/css/partial/highlight/dracula.css","hash":"83cb7632a977d99c40596ffe366c171f7a5c15e2","modified":1635678906272},{"_id":"themes/white/source/css/partial/highlight/foundation.css","hash":"4f04dcb43a3144ae0c22c82d971eef24c48363a0","modified":1635678906272},{"_id":"themes/white/source/css/partial/highlight/github-gist.css","hash":"23fc125b60162b14781d356ce84c096c0212f1a3","modified":1635678906272},{"_id":"themes/white/source/css/partial/highlight/github.css","hash":"29c4f2ac5fadf5146021eefb44984ac08e9e9688","modified":1635678906273},{"_id":"themes/white/source/css/partial/highlight/gml.css","hash":"fee6d7a0e8d8cbbfb147e9af2812808f9853dd71","modified":1635678906273},{"_id":"themes/white/source/css/partial/highlight/googlecode.css","hash":"7162f4d01403326754b0ec13cf1b67dbd69fb576","modified":1635678906273},{"_id":"themes/white/source/css/partial/highlight/grayscale.css","hash":"e71b26a8c2f0c675598552551c1a6ffa9790a5d0","modified":1635678906273},{"_id":"themes/white/source/css/partial/highlight/gradient-dark.css","hash":"5b59633a52e52151686a2bf6aa04ec4324f3d03e","modified":1635678906273},{"_id":"themes/white/source/css/partial/highlight/gruvbox-light.css","hash":"363141bbcb1dd986c69bc356f1b5e195c46a1a44","modified":1635678906273},{"_id":"themes/white/source/css/partial/highlight/gruvbox-dark.css","hash":"79b9188de6f9806b986a6847b736898ddee09441","modified":1635678906273},{"_id":"themes/white/source/css/partial/highlight/hopscotch.css","hash":"13a20a61be2c23166d2adc34a0fcd11ffb967073","modified":1635678906274},{"_id":"themes/white/source/css/partial/highlight/hybrid.css","hash":"8315bc3988bebb758771174b185cee950d27067f","modified":1635678906274},{"_id":"themes/white/source/css/partial/highlight/idea.css","hash":"f75a28d7216218341a8319b2a267f5781ae98397","modified":1635678906274},{"_id":"themes/white/source/css/partial/highlight/isbl-editor-dark.css","hash":"3c742bdc0fad6cae97bdf30dae7f36d42f9758d9","modified":1635678906274},{"_id":"themes/white/source/css/partial/highlight/ir-black.css","hash":"0d7d59283979b9fc3b6204973b3a344264bfda47","modified":1635678906274},{"_id":"themes/white/source/css/partial/highlight/isbl-editor-light.css","hash":"0ca0cc52b5536788e1d898fa3c9256b652d09ce4","modified":1635678906275},{"_id":"themes/white/source/css/partial/highlight/kimbie.dark.css","hash":"61bd80ed7c41b5122d543620784aadf4e44d2b8e","modified":1635678906275},{"_id":"themes/white/source/css/partial/highlight/kimbie.light.css","hash":"a254e40ae09f0b639d00cbd7e99f90469b53de41","modified":1635678906275},{"_id":"themes/white/source/css/partial/highlight/lightfair.css","hash":"b00d0919e5370462bb4a490493750b8b4c17ff03","modified":1635678906275},{"_id":"themes/white/source/css/partial/highlight/lioshi.css","hash":"48459e415a1c5c9e5c5ccdaa1de16b71abf92891","modified":1635678906275},{"_id":"themes/white/source/css/partial/highlight/mono-blue.css","hash":"d684208c3fc2e3724421ad342d6fc15875f23fc5","modified":1635678906275},{"_id":"themes/white/source/css/partial/highlight/magula.css","hash":"3297dd14312ea8c36f1e4602c9516f414077055a","modified":1635678906275},{"_id":"themes/white/source/css/partial/highlight/monokai-sublime.css","hash":"a0742650bb27f05d1d9572decaa0bb931f9bead3","modified":1635678906276},{"_id":"themes/white/source/css/partial/highlight/monokai.css","hash":"4598a4e47a74a650eab69fee0eebfe8efee7d5a6","modified":1635678906276},{"_id":"themes/white/source/css/partial/highlight/nnfx-dark.css","hash":"0328bdb2744dc5cf28e700e0e6ba23777ad701ba","modified":1635678906276},{"_id":"themes/white/source/css/partial/highlight/night-owl.css","hash":"2f5c43199055deb5966ca5412c7a9a39f2c68b88","modified":1635678906276},{"_id":"themes/white/source/css/partial/highlight/nnfx.css","hash":"da49d999c92643a41894fe0265cc8f155ad0842f","modified":1635678906276},{"_id":"themes/white/source/css/partial/highlight/nord.css","hash":"82148093d2954ab685a8e82602631b551a8777b5","modified":1635678906276},{"_id":"themes/white/source/css/partial/highlight/obsidian.css","hash":"48890593dd858ed8d47b40e34487edf0899ece35","modified":1635678906277},{"_id":"themes/white/source/css/partial/highlight/ocean.css","hash":"21472b75fd4eb1810764fdc2704522fe249877ca","modified":1635678906277},{"_id":"themes/white/source/css/partial/highlight/paraiso-dark.css","hash":"3d553a29acc72cd0f5db4ad9c70d755d481b0687","modified":1635678906277},{"_id":"themes/white/source/css/partial/highlight/paraiso-light.css","hash":"568814940dfdd36118a7f8665656ac36b643190e","modified":1635678906277},{"_id":"themes/white/source/css/partial/highlight/pojoaque.css","hash":"3a06d371ea4b1e097860e4a9747d817cd3c5e888","modified":1635678906277},{"_id":"themes/white/source/css/partial/highlight/purebasic.css","hash":"2f578beb25d16c45ca0774519df3fe50f3c35760","modified":1635678906277},{"_id":"themes/white/source/css/partial/highlight/qtcreator_light.css","hash":"edef0e3036cf276b3f70bb4df55003f6a27e56e1","modified":1635678906278},{"_id":"themes/white/source/css/partial/highlight/qtcreator_dark.css","hash":"f963aae29d81512550ff699a63b2f3a2439bf404","modified":1635678906278},{"_id":"themes/white/source/css/partial/highlight/rainbow.css","hash":"093bec82c2577df4d0d761dee30d5472c4f697f1","modified":1635678906278},{"_id":"themes/white/source/css/partial/highlight/railscasts.css","hash":"2b8d2c1faadc51d312cb0bd7058c5431400c2924","modified":1635678906278},{"_id":"themes/white/source/css/partial/highlight/school-book.css","hash":"ebfec3f0e1f473593595c8146dcf79e0c445a8b3","modified":1635678906278},{"_id":"themes/white/source/css/partial/highlight/routeros.css","hash":"170a0c7f80668f3012676bb29ef6cdcd098183e3","modified":1635678906278},{"_id":"themes/white/source/css/partial/highlight/shades-of-purple.css","hash":"41d8f8210d7b13bb1d31c0be2c10427954535b80","modified":1635678906279},{"_id":"themes/white/source/css/partial/highlight/solarized-dark.css","hash":"a624f1a85e915db688949b648754a84b215efa72","modified":1635678906279},{"_id":"themes/white/source/css/partial/highlight/srcery.css","hash":"c1634ac1680f6df5efc1fecb51a7912d46aceaa8","modified":1635678906279},{"_id":"themes/white/source/css/partial/highlight/solarized-light.css","hash":"3a8097995857f8557a1ab53db360175227a638cb","modified":1635678906279},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night-blue.css","hash":"873e26f5cb802d941f88d4e83f2695bf23e17401","modified":1635678906279},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night-bright.css","hash":"d89269a86b0587c8011ea4940ebf90bd99d825bf","modified":1635678906279},{"_id":"themes/white/source/css/partial/highlight/sunburst.css","hash":"57e3690fe439c511c2585869f2b8f4f62cb3535e","modified":1635678906279},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night.css","hash":"9012ab4e1d73ed9d71ef9c11ed69d82f70f746cc","modified":1635678906280},{"_id":"themes/white/source/css/partial/highlight/tomorrow-night-eighties.css","hash":"217f8dd94f955b452d6055b3a3a802e9f2459f82","modified":1635678906280},{"_id":"themes/white/source/css/partial/highlight/vs2015.css","hash":"401f8ccde362ac62a3b1b3bfe79299de16a665db","modified":1635678906280},{"_id":"themes/white/source/css/partial/highlight/vs.css","hash":"0b06af7596e05b5d2928475fbb6902917ef3ed3f","modified":1635678906280},{"_id":"themes/white/source/css/partial/highlight/tomorrow.css","hash":"19c7cbb02b4486b3bc1e9cdda6fc77acb69f0b85","modified":1635678906280},{"_id":"themes/white/source/css/partial/highlight/xcode.css","hash":"e31ee8ee5e865909d89a06e776e4c95b084318a0","modified":1635678906280},{"_id":"themes/white/source/css/partial/highlight/xt256.css","hash":"63fde91354b505bc96fb6562f31397c6605a47d8","modified":1635678906281},{"_id":"themes/white/source/css/partial/highlight/zenburn.css","hash":"4fb2d4fc4e3e17d1b8c191c4965bed15191bbb61","modified":1635678906281},{"_id":"themes/white/source/css/partial/tag_plugin/note.styl","hash":"0d295163c86a09d3df21f30a893b2c3bd058cf83","modified":1635678906282},{"_id":"themes/white/source/css/partial/tag_plugin/tags.styl","hash":"cd60b8d86aa6a038ee629663d57c3334bb1c04fe","modified":1635678906282},{"_id":"themes/white/source/img/avatar.jpg","hash":"876ce1a2cdd0c80e936aec9a0878272854438c92","modified":1635680116718},{"_id":"themes/white/source/img/wechat.jpg","hash":"4cd2f1b5c12750f66f32a1bf150dc755beb0ff58","modified":1635678906286},{"_id":"themes/white/source/img/alipay.jpg","hash":"432585449232dd4fd89a5e4761332747ba5ecc73","modified":1635678906284},{"_id":"public/404.html","hash":"2ff6ea3011791ab884d845bad44ef138cef44bc2","modified":1646320268516},{"_id":"public/2022/03/03/Learn-shared-ptr-by-Error/index.html","hash":"4d797cdc1ab001a74780adeddc8422793197a4ac","modified":1646320268516},{"_id":"public/2021/11/08/MQTT基础文档翻译-一-MQTT协议介绍/index.html","hash":"c3f77de484d9668f4f399ee6139987aea64f85b3","modified":1646320268516},{"_id":"public/archives/index.html","hash":"ab6267e6f9bf3aafd38a3683c3596de0d4b162e3","modified":1646320268516},{"_id":"public/archives/2021/index.html","hash":"e130ea4c1535bca0e0733ef174b2655622163d0b","modified":1646320268516},{"_id":"public/archives/2021/11/index.html","hash":"1501bf6a7d9fbeecff3f99a2557e0e2476423c12","modified":1646320268516},{"_id":"public/archives/2021/12/index.html","hash":"8e8b7efb187149c8f53013dc6cdb6dce05bad662","modified":1646320268516},{"_id":"public/archives/2022/index.html","hash":"521daac9e4c9d303b3c3e5fbf0c6d09c2407014e","modified":1646320268516},{"_id":"public/archives/2022/02/index.html","hash":"bc0af6a5bd819a020b846431d8aadd566bb33dff","modified":1646320268516},{"_id":"public/archives/2022/03/index.html","hash":"65c36754918e85dedb08eabfe2b569998414e021","modified":1646320268516},{"_id":"public/tags/C-、shared-ptr/index.html","hash":"6ebed9a67cb22ff0d5a7362ee353af74da986f60","modified":1646320268516},{"_id":"public/tags/MQTT/index.html","hash":"0c7fbbbb3c4be954408bcc25a02cee88243f8df7","modified":1646320268516},{"_id":"public/tags/Protobuf/index.html","hash":"c66f7ab1ba341e03fddadff1614b3a8669474d61","modified":1646320268516},{"_id":"public/tags/Qt/index.html","hash":"a9989d814f2ed33d754984a29442c897e4ed41de","modified":1646320268516},{"_id":"public/2022/03/02/MQTT基础文档翻译-五-话题和相关的实践/index.html","hash":"97f8a71c03ef352c8c3e0ab0281aa6c9b29d786b","modified":1646320268516},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/index.html","hash":"f0e1d154eac5d9dc25f7e257626b55cec79fbc85","modified":1646320268516},{"_id":"public/2021/12/01/ProtoBuf为什么比Json快/index.html","hash":"686cbcc9c6faa6410d6b9a20051cae5240481646","modified":1646320268516},{"_id":"public/2021/11/14/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/index.html","hash":"2b4a8c63c3d687b4b06a7dab80bb9665e3fe01a0","modified":1646320268516},{"_id":"public/2021/11/10/MQTT基础文档翻译-二-发布和订阅/index.html","hash":"4dcd54ce2a0a013fd227d20488f1f0be644cd2e8","modified":1646320268516},{"_id":"public/2021/11/02/Qt信号槽机制浅析/index.html","hash":"5da61396778560c4f71dab991baf608b2da62837","modified":1646320268516},{"_id":"public/index.html","hash":"32edb928df2ae574a725574f635b80e0658c03b0","modified":1646320268516},{"_id":"public/CNAME","hash":"54d62e828f45ebd3ebd60b87f6d332379198381a","modified":1646320014794},{"_id":"public/fonts/chinese-zodiac.woff2","hash":"96af181d987ecc97bf9f1fe12df883102bdc18a4","modified":1646320014794},{"_id":"public/img/alipay.svg","hash":"292ea040e865c1d0be259703ff850570b3bdfc97","modified":1646320014794},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1646320014794},{"_id":"public/fonts/chinese-zodiac.woff","hash":"bf8137ae4b8a1e11bc5480ba5af2d44244d13f99","modified":1646320014794},{"_id":"public/fonts/chinese-zodiac.eot","hash":"e3ea84e00f4fae1bbf157650ed09000299ea8c7b","modified":1646320014794},{"_id":"public/img/loading.gif","hash":"dabf141cac0a42a8dbfb8844e9a8fb1d1f3fceab","modified":1646320014794},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1646320014794},{"_id":"public/img/paypal.svg","hash":"1dfd643ce13dec27c63847acd6acf3eb17bb598e","modified":1646320014794},{"_id":"public/img/wechat.svg","hash":"6d08667c5881e66d20df72bf2214bae55396554b","modified":1646320014794},{"_id":"public/2021/11/14/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connack1.png","hash":"b542c7e60067cda6a88dccdb5ad9f7668602f6eb","modified":1646320014794},{"_id":"public/2021/11/14/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connect-flow.gif","hash":"79e4ae8e65dc2b243ff142d14a0b9d5881f980c2","modified":1646320014794},{"_id":"public/2021/11/14/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connect.png","hash":"6859d17c03eb36266436572fbd11fe2e7dcc281f","modified":1646320014794},{"_id":"public/2021/11/14/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/mqtt-tcp-ip-stack.png","hash":"cc5d9dc3a7ec7ee1cea4487519991d7ca4929fa8","modified":1646320014794},{"_id":"public/2022/03/02/MQTT基础文档翻译-五-话题和相关的实践/topic_basics.png","hash":"682a4ba240c2c1d09959872788eff9efe9f3071c","modified":1646320014794},{"_id":"public/2021/11/14/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/retcode.png","hash":"553220db2f0b8065f8ed6dff10aad2c173bb4612","modified":1646320014794},{"_id":"public/2022/03/02/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_hash.png","hash":"a5cd8a62e6c2be07444abc0a5f44b68fa922a920","modified":1646320014794},{"_id":"public/2022/03/02/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_plus.png","hash":"afc2763e9e71945a3fb03af9387b6474611745e5","modified":1646320014794},{"_id":"public/2022/03/02/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_plus_example.png","hash":"5038f5a437033f7aa7d72bf3eb229a20d676553b","modified":1646320014794},{"_id":"public/2021/12/01/ProtoBuf为什么比Json快/wire_types.png","hash":"d0683780eeca7b87a44b26b56d67e20fde09996e","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/publish_flow.png","hash":"53debbe98c9b5163e34e017fa58aa8ec635a760c","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/publish_packet.png","hash":"9ca2eb21303351f6f9c8943b8a0caa9cae72af30","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/return_code.png","hash":"75c011702040352538d844d14de443688fb45674","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/subscribe_flow.png","hash":"03942ac175d33f9284d97bd76df9893c03bfae25","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/suback_packet.png","hash":"9ea37b67f389572502dd3bcf4c7fd86caccb3632","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/subscribe_packet.png","hash":"760a3477e43a5e14625c08afb8e4236664abdfb8","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsuback_packet.png","hash":"43dbfb04b3f687a83ced79f8fc31e04d62846330","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsubscribe_flow.png","hash":"d332bbad21ad75055c35ff534bb604c45067a68d","modified":1646320014794},{"_id":"public/2022/02/17/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsubscribe_packet.png","hash":"884300d567428cd1ed22f2d6f2f6489acdf4de6a","modified":1646320014794},{"_id":"public/img/avatar.jpg","hash":"876ce1a2cdd0c80e936aec9a0878272854438c92","modified":1646320014794},{"_id":"public/img/wechat.jpg","hash":"4cd2f1b5c12750f66f32a1bf150dc755beb0ff58","modified":1646320014794},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646320014794},{"_id":"public/js/firework.js","hash":"e9f29679ebb2f581ccadd39ef18c89cfc44e0710","modified":1646320014794},{"_id":"public/js/script.js","hash":"7bdd6dcc73e8d756961a1dfc6d80700a7112c45a","modified":1646320014794},{"_id":"public/js/todark.js","hash":"09d8e17071e73aeeff1957827c46e39c1fb050f5","modified":1646320014794},{"_id":"public/js/local-search.js","hash":"7235f78007bde4ddc94911596128346364eefe3b","modified":1646320014794},{"_id":"public/css/partial/dark.css","hash":"c217e67aebe0eb5b3e39c893a41822630343af6d","modified":1646320014794},{"_id":"public/css/partial/header.css","hash":"84e3557546f3d654a11bde08f83c0ca59feac9d2","modified":1646320014794},{"_id":"public/css/partial/local-search.css","hash":"a7a352b4086aef84a7db40032db0e25017d51c67","modified":1646320014794},{"_id":"public/css/partial/fonts.css","hash":"2718dc708c8a838af3c649e9737289467a1439d1","modified":1646320014794},{"_id":"public/css/partial/media.css","hash":"61f59c34250aa5e3a76cb3d23d521ec688398214","modified":1646320014794},{"_id":"public/css/partial/highlight.css","hash":"8b41ab31476e1cf2ca195733d0cfb7316708be53","modified":1646320014794},{"_id":"public/css/partial/post.css","hash":"868c5e6be6df407d62f62419340472bac9d43753","modified":1646320014794},{"_id":"public/css/partial/recent-posts.css","hash":"06471b0f4d18c702eb3a149ba9add2cf40ec069f","modified":1646320014794},{"_id":"public/css/partial/highlight/a11y-dark.css","hash":"367b81c201179eb6b9e8448be7d9afe900324d0e","modified":1646320014794},{"_id":"public/css/partial/reward.css","hash":"844196795eb7251f53b120b406dbd411b592800d","modified":1646320014794},{"_id":"public/css/partial/highlight/agate.css","hash":"2c53b6f63569eb43a3d3c32b0d2920389e9ec397","modified":1646320014794},{"_id":"public/css/partial/highlight/a11y-light.css","hash":"6b964117406a7ddab93d598e14441eb9f1f6929a","modified":1646320014794},{"_id":"public/css/partial/highlight/an-old-hope.css","hash":"b77c50f80832cd26919775863cc49e694e84b888","modified":1646320014794},{"_id":"public/css/partial/highlight/androidstudio.css","hash":"4cf3233b038bbd5083471904025eb4446c08e983","modified":1646320014794},{"_id":"public/css/partial/highlight/arta.css","hash":"4dea73980726ac09d27927b8d38f6196644b6821","modified":1646320014794},{"_id":"public/css/partial/highlight/arduino-light.css","hash":"a6b27a3e53fe933317531b6bba1ec0887508f0b6","modified":1646320014794},{"_id":"public/css/partial/highlight/ascetic.css","hash":"5e2ac91bc9c3852359ccf4ce7eefdea012a903ab","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-cave-dark.css","hash":"9fb89fd8a8109a7c7c2450b1ebc55f5cee9d4a59","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-cave-light.css","hash":"135f95e783576f0d4721702c2af6b2c03204efc4","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-dune-dark.css","hash":"4bae8ae51072e23b81ee860671ac28a951620c57","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-estuary-dark.css","hash":"d9f91f0f440a838cc189eca4fe90dae85f1da6a0","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-dune-light.css","hash":"c9c95f9665bf6bc52fed3a2141fbe600fc6a25f8","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-estuary-light.css","hash":"594a205e0c988db4ca461131573525185208587f","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-forest-dark.css","hash":"931630149abdee4fdcc8469705af6a4205fe7fbf","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-forest-light.css","hash":"c47a06662c4bba5b24d5982bf9280b0c65d7b8f0","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-heath-dark.css","hash":"0d079c2ab3a7c308186923a205a31fcfab3a7ce4","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-lakeside-dark.css","hash":"8de3d9a1e817bdeb73c0234bf6672b4b381af8ac","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-heath-light.css","hash":"fb2f704e83309a0886a933b2f9c1efe25078f67e","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-lakeside-light.css","hash":"3340cb6b25a35adfe377e7f24b8ee6729b8aaaf1","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-plateau-light.css","hash":"e7d8ba7ba12a5ed46353e647a6f9eec54e039cf0","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-savanna-light.css","hash":"42438235ccf575c31c80710b5fd2dff2973159c2","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-plateau-dark.css","hash":"9f941857191f79cec8bc2899181ce0aadfdcf3dd","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-savanna-dark.css","hash":"62ae162ac812e39b3c739d7d9e8d06c10883d8a9","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-seaside-dark.css","hash":"ef85351aaffa777ad7c4f2ecc107e429abe6de6a","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-seaside-light.css","hash":"5f7d74ade8accb86da766ecc8616b29b2c365c8a","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-sulphurpool-dark.css","hash":"aad41fad6f7e1c9624f31f17dbcad6f8c3489a78","modified":1646320014794},{"_id":"public/css/partial/highlight/atelier-sulphurpool-light.css","hash":"04061783a48ee2f07225b7d46209a1fc222ca6d4","modified":1646320014794},{"_id":"public/css/partial/highlight/atom-one-dark-reasonable.css","hash":"95edd5336a61bf3676cbae6c918cf939379720cd","modified":1646320014794},{"_id":"public/css/partial/highlight/atom-one-light.css","hash":"c394de897c2807066e334b6b01e77d3a11a7217c","modified":1646320014794},{"_id":"public/css/partial/highlight/atom-one-dark.css","hash":"6d02e151baa92610cb313e54241178464a2f69be","modified":1646320014794},{"_id":"public/css/partial/highlight/brown-paper.css","hash":"2a17689adfeee7cf84362855c02a200be2d7456d","modified":1646320014794},{"_id":"public/css/partial/highlight/codepen-embed.css","hash":"c6bc815b975213b5ea318097e985dadd69bee815","modified":1646320014794},{"_id":"public/css/partial/highlight/color-brewer.css","hash":"bfe58ef6622dd52d03530eb1a39a754e9b819fa9","modified":1646320014794},{"_id":"public/css/partial/highlight/darcula.css","hash":"e1eb3d715fff66e16e045dadfe185c168413962f","modified":1646320014794},{"_id":"public/css/partial/highlight/dark.css","hash":"d64ff770effb3a4e7ac0e90874cca3c01d64d73f","modified":1646320014794},{"_id":"public/css/partial/highlight/default.css","hash":"5e21e8bdb737a7aa21abaa308723f3b48d193f0f","modified":1646320014794},{"_id":"public/css/partial/highlight/far.css","hash":"a35ee476520d0ccb73b0db2f4fb1ef78eed128bc","modified":1646320014794},{"_id":"public/css/partial/highlight/dracula.css","hash":"c1f03c28c6c1175e1ab9ab791732496706781ad5","modified":1646320014794},{"_id":"public/css/partial/highlight/github-gist.css","hash":"7a725cdf0a5a7fe6a4c89dfed0dd39eaee66cf28","modified":1646320014794},{"_id":"public/css/partial/highlight/docco.css","hash":"028e4784745ad867cb9d0cd217a4d136fcdc753b","modified":1646320014794},{"_id":"public/css/partial/highlight/foundation.css","hash":"642fe4ccbb66961ae8c1b42a7b27c777a4e0e97e","modified":1646320014794},{"_id":"public/css/partial/highlight/gml.css","hash":"c5b0d8ccb337a7083dbfefd16c156e5ea8865a09","modified":1646320014794},{"_id":"public/css/partial/highlight/github.css","hash":"b809480f9810347dfab9f59e5c2130ee79e38447","modified":1646320014794},{"_id":"public/css/partial/highlight/googlecode.css","hash":"d4249c5c0cb209198b1ae39070d4ac0494bd75d3","modified":1646320014794},{"_id":"public/css/partial/highlight/gradient-dark.css","hash":"8f52973d429abfb6c40877e33bbcd4d376d75c8d","modified":1646320014794},{"_id":"public/css/partial/highlight/grayscale.css","hash":"eeadee4c164d031af437a4efa328a46005295069","modified":1646320014794},{"_id":"public/css/partial/highlight/hopscotch.css","hash":"bb42de173ac5d1fa98a58a6106d492e5246bf37e","modified":1646320014794},{"_id":"public/css/partial/highlight/gruvbox-light.css","hash":"6e7b8002c973f285c1e1aac467935c3c436eebef","modified":1646320014794},{"_id":"public/css/partial/highlight/gruvbox-dark.css","hash":"8efce969f84bce90b94b2b314fb53ffd1e4c7b7f","modified":1646320014794},{"_id":"public/css/partial/highlight/hybrid.css","hash":"eda993d88b47ec034a4f6aed869659b1ea867026","modified":1646320014794},{"_id":"public/css/partial/highlight/idea.css","hash":"b30e1d3146011d366e9b9b6e23c37a517e49dade","modified":1646320014794},{"_id":"public/css/partial/highlight/isbl-editor-dark.css","hash":"1fe15d663c00100aaf908f6188d2893a15524b86","modified":1646320014794},{"_id":"public/css/partial/highlight/ir-black.css","hash":"390ed2b3efbac173d11951045bd90b9a044ea820","modified":1646320014794},{"_id":"public/css/partial/highlight/kimbie.dark.css","hash":"2463bb13e10c97b94a639f7044b04d6b391a64bc","modified":1646320014794},{"_id":"public/css/partial/highlight/lightfair.css","hash":"eaebc4f9cfdadd9acb0751d0a47188da8ad1ac4d","modified":1646320014794},{"_id":"public/css/partial/highlight/isbl-editor-light.css","hash":"0db445b5c066fc3d6f352d709f7d90bd3d7ba4f6","modified":1646320014794},{"_id":"public/css/partial/highlight/kimbie.light.css","hash":"1a76eadba3c337fd4ccf6aa3b433c1b7668a6310","modified":1646320014794},{"_id":"public/css/partial/highlight/magula.css","hash":"495d8f104ab5df5d0dcf65f53048d653d9dfadd8","modified":1646320014794},{"_id":"public/css/partial/highlight/monokai.css","hash":"936b3ae6c4c4950fea3198155b30b57a19b5c055","modified":1646320014794},{"_id":"public/css/partial/highlight/lioshi.css","hash":"709ad976d4b7382c422e7bca97abfc31b04681ca","modified":1646320014794},{"_id":"public/css/partial/highlight/mono-blue.css","hash":"e973d7daa3c1b74af50c67f0b97785ae5685d439","modified":1646320014794},{"_id":"public/css/partial/highlight/monokai-sublime.css","hash":"6e2bad0d17a40791131d1c5e750301daed1835c5","modified":1646320014794},{"_id":"public/css/partial/highlight/night-owl.css","hash":"1f0b40ea850d6859217a6b0d7f1ef34a30247179","modified":1646320014794},{"_id":"public/css/partial/highlight/nnfx-dark.css","hash":"588aae57cb53e3fb14c3083124b6926f145750a6","modified":1646320014794},{"_id":"public/css/partial/highlight/obsidian.css","hash":"2c0a9736f49e437632fd4a227905d9ed717580c1","modified":1646320014794},{"_id":"public/css/partial/highlight/nnfx.css","hash":"c5af08d34fc8ca4c67a11f331d695ad17583c033","modified":1646320014794},{"_id":"public/css/partial/highlight/nord.css","hash":"6a530eb93c40437100aa7439fd24e49c02df47d0","modified":1646320014794},{"_id":"public/css/partial/highlight/ocean.css","hash":"b00ee1c8c10e9ba41c4e486385c32a93c4797ea2","modified":1646320014794},{"_id":"public/css/partial/highlight/paraiso-dark.css","hash":"1cbd1d197fe2590e3961f5d69702831b3f94bea4","modified":1646320014794},{"_id":"public/css/partial/highlight/paraiso-light.css","hash":"04eb75b6505d05177417eb106e9a011b0aaad433","modified":1646320014794},{"_id":"public/css/partial/highlight/pojoaque.css","hash":"74122ef5f293a8090501f557cc0ef746a6baa650","modified":1646320014794},{"_id":"public/css/partial/highlight/qtcreator_dark.css","hash":"6e218a94e5faad66c32027091538a136a0e288b5","modified":1646320014794},{"_id":"public/css/partial/highlight/purebasic.css","hash":"e0c272f695a8f2c5602a29fdda8886e74678cbdc","modified":1646320014794},{"_id":"public/css/partial/highlight/railscasts.css","hash":"d234cb0568e7978c91b87dbf0fef95b236e1c7a5","modified":1646320014794},{"_id":"public/css/partial/highlight/qtcreator_light.css","hash":"2f1992092014efa68e89f348f5941f30f497ca60","modified":1646320014794},{"_id":"public/css/partial/highlight/rainbow.css","hash":"b4d98e83c87685c2c265c1fae28977f110447ec2","modified":1646320014794},{"_id":"public/css/partial/highlight/school-book.css","hash":"9714b72124d6938bbe618bf9b53dd9efed7d99f4","modified":1646320014794},{"_id":"public/css/partial/highlight/routeros.css","hash":"40c1ea8a64e8116fd198ba838f42e4b55523be22","modified":1646320014794},{"_id":"public/css/partial/highlight/solarized-dark.css","hash":"ab2bc774a8e87a9ffe44dda605ac199d5886eb3f","modified":1646320014794},{"_id":"public/css/partial/highlight/shades-of-purple.css","hash":"bf790e81c1b8afacf5e4e5a5255293f74509aec0","modified":1646320014794},{"_id":"public/css/partial/highlight/solarized-light.css","hash":"aeced4941ebbf08aca54217ab23bed26688541c0","modified":1646320014794},{"_id":"public/css/partial/highlight/srcery.css","hash":"478313579d78c3b80e6a8c91b82037885bd145df","modified":1646320014794},{"_id":"public/css/partial/highlight/tomorrow-night-blue.css","hash":"43ab7bc48046b19ba1f4d8eaa687010993f875e0","modified":1646320014794},{"_id":"public/css/partial/highlight/sunburst.css","hash":"bf7115046b33b271912c1c39a78fd0390066e400","modified":1646320014794},{"_id":"public/css/partial/highlight/tomorrow-night-bright.css","hash":"e5f1bfe6a4687a0550c5e9e8e6dee84783a4704d","modified":1646320014794},{"_id":"public/css/partial/highlight/tomorrow-night-eighties.css","hash":"8837ee6872ebd55426709ec09d853b0d9085d1e8","modified":1646320014794},{"_id":"public/css/partial/highlight/tomorrow-night.css","hash":"271b0b04244e1413ce2cd4ea490f8977829f4bfd","modified":1646320014794},{"_id":"public/css/partial/highlight/vs.css","hash":"f85a1da5246d6aadd3913e47c307c20022480226","modified":1646320014794},{"_id":"public/css/partial/highlight/tomorrow.css","hash":"899dfaf57008e078e28983a36c8cd4a4bbdff877","modified":1646320014794},{"_id":"public/css/partial/highlight/vs2015.css","hash":"e534297cb05adb51668933f9a3076f2489111e20","modified":1646320014794},{"_id":"public/css/partial/highlight/xt256.css","hash":"868a0c5befc4ee888692c65734f0326d14841fab","modified":1646320014794},{"_id":"public/css/partial/highlight/xcode.css","hash":"09c36aa7f35c5959c2c1418deee2053b7dbf24d4","modified":1646320014794},{"_id":"public/css/partial/highlight/zenburn.css","hash":"161020d112780b3f5243ba8fc4e4599d88769fe4","modified":1646320014794},{"_id":"public/css/partial/tag_plugin/note.css","hash":"5029617b4fddf2c3e88686d15be13e3b5b283e9e","modified":1646320014794},{"_id":"public/css/partial/tag_plugin/tags.css","hash":"60995fb4af0be08a146d153862a90a3758cbfd7f","modified":1646320014794},{"_id":"public/css/style.css","hash":"240de5a29cbcc0aa0328f505a135bd638d068b15","modified":1646320014794},{"_id":"public/img/alipay.jpg","hash":"432585449232dd4fd89a5e4761332747ba5ecc73","modified":1646320014794},{"_id":"public/2021/11/10/MQTT基础文档翻译-二-发布和订阅/mqtt-publish-subscribe.svg","hash":"cea410816d440b3b9e8bf97334795e235467bad6","modified":1646320014794},{"_id":"public/2021/12/01/ProtoBuf为什么比Json快/debug_protoc.png","hash":"83312fe7ffc6dca3c57d7e9d813cfc1066cccdf9","modified":1646320014794}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Learn shared_ptr by Error","date":"2022-03-03T13:46:10.000Z","_content":"\n> Shared_ptr is a smart pointer that retains shared ownership of an object through a pointer.\n<!--more-->\nshared_ptr 是一个通过指针来保有对象共享所有权的智能指针。 <br/>\n智能指针是现代C++的重要特性之一，简单来说智能指针的出现就是为了解决原生指针使用时非常容易出现内存泄漏(例如忘记delete、函数异常提前退出、数据的所有权不明确)的问题。而智能指针有两个必须要实现的基本功能：\n- 形如原生指针。智能指针的使用方法、对应操作的结果，以及在多态情况下的行为都应该与原生指针一致。\n- 自动内存管理。使用智能指针时，程序员应该不需要负责内存的回收、并且在出现异常时应保证不会发生内存泄漏。\n\n本文以shared_ptr为例子，通过不断的 **遇到问题(内存泄漏、编译错误、与原生指针行为不一致等)->找寻对应解决方案** 的模式，来阐述一份shared_ptr是如何从0到1实现、并完成以上两个功能的。\n\n#### 工具准备\n- 源代码: [shared_ptr](https://github.com/protocolbuffers/protobuf/blob/3.5.x/src/google/protobuf/stubs/shared_ptr.h) protocolbuffers库早期版本中使用的shared_ptr实现。简洁，易于学习。是本文主要参考的代码。\n- 编译环境: Windows、MSVC2019\n- 内存检测工具: [Visual Leak Detector](https://kinddragon.github.io/vld/)\n\n## 正文\n","source":"_posts/Learn-shared-ptr-by-Error.md","raw":"---\ntitle: Learn shared_ptr by Error\ndate: 2022-03-03 21:46:10\ntags: C++、shared_ptr\n---\n\n> Shared_ptr is a smart pointer that retains shared ownership of an object through a pointer.\n<!--more-->\nshared_ptr 是一个通过指针来保有对象共享所有权的智能指针。 <br/>\n智能指针是现代C++的重要特性之一，简单来说智能指针的出现就是为了解决原生指针使用时非常容易出现内存泄漏(例如忘记delete、函数异常提前退出、数据的所有权不明确)的问题。而智能指针有两个必须要实现的基本功能：\n- 形如原生指针。智能指针的使用方法、对应操作的结果，以及在多态情况下的行为都应该与原生指针一致。\n- 自动内存管理。使用智能指针时，程序员应该不需要负责内存的回收、并且在出现异常时应保证不会发生内存泄漏。\n\n本文以shared_ptr为例子，通过不断的 **遇到问题(内存泄漏、编译错误、与原生指针行为不一致等)->找寻对应解决方案** 的模式，来阐述一份shared_ptr是如何从0到1实现、并完成以上两个功能的。\n\n#### 工具准备\n- 源代码: [shared_ptr](https://github.com/protocolbuffers/protobuf/blob/3.5.x/src/google/protobuf/stubs/shared_ptr.h) protocolbuffers库早期版本中使用的shared_ptr实现。简洁，易于学习。是本文主要参考的代码。\n- 编译环境: Windows、MSVC2019\n- 内存检测工具: [Visual Leak Detector](https://kinddragon.github.io/vld/)\n\n## 正文\n","slug":"Learn-shared-ptr-by-Error","published":1,"updated":"2022-03-03T15:08:36.939Z","_id":"cl0b4dtq20000vsvi0e1fck8x","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Shared_ptr is a smart pointer that retains shared ownership of an object through a pointer.</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>shared_ptr 是一个通过指针来保有对象共享所有权的智能指针。 <br/><br>智能指针是现代C++的重要特性之一，简单来说智能指针的出现就是为了解决原生指针使用时非常容易出现内存泄漏(例如忘记delete、函数异常提前退出、数据的所有权不明确)的问题。而智能指针有两个必须要实现的基本功能：</p>\n<ul>\n<li>形如原生指针。智能指针的使用方法、对应操作的结果，以及在多态情况下的行为都应该与原生指针一致。</li>\n<li>自动内存管理。使用智能指针时，程序员应该不需要负责内存的回收、并且在出现异常时应保证不会发生内存泄漏。</li>\n</ul>\n<p>本文以shared_ptr为例子，通过不断的 <strong>遇到问题(内存泄漏、编译错误、与原生指针行为不一致等)-&gt;找寻对应解决方案</strong> 的模式，来阐述一份shared_ptr是如何从0到1实现、并完成以上两个功能的。</p>\n<h4 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h4><ul>\n<li>源代码: <a href=\"https://github.com/protocolbuffers/protobuf/blob/3.5.x/src/google/protobuf/stubs/shared_ptr.h\">shared_ptr</a> protocolbuffers库早期版本中使用的shared_ptr实现。简洁，易于学习。是本文主要参考的代码。</li>\n<li>编译环境: Windows、MSVC2019</li>\n<li>内存检测工具: <a href=\"https://kinddragon.github.io/vld/\">Visual Leak Detector</a></li>\n</ul>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2>","site":{"data":{}},"excerpt":"<blockquote>\n<p>Shared_ptr is a smart pointer that retains shared ownership of an object through a pointer.</p>\n</blockquote>","more":"<p>shared_ptr 是一个通过指针来保有对象共享所有权的智能指针。 <br/><br>智能指针是现代C++的重要特性之一，简单来说智能指针的出现就是为了解决原生指针使用时非常容易出现内存泄漏(例如忘记delete、函数异常提前退出、数据的所有权不明确)的问题。而智能指针有两个必须要实现的基本功能：</p>\n<ul>\n<li>形如原生指针。智能指针的使用方法、对应操作的结果，以及在多态情况下的行为都应该与原生指针一致。</li>\n<li>自动内存管理。使用智能指针时，程序员应该不需要负责内存的回收、并且在出现异常时应保证不会发生内存泄漏。</li>\n</ul>\n<p>本文以shared_ptr为例子，通过不断的 <strong>遇到问题(内存泄漏、编译错误、与原生指针行为不一致等)-&gt;找寻对应解决方案</strong> 的模式，来阐述一份shared_ptr是如何从0到1实现、并完成以上两个功能的。</p>\n<h4 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h4><ul>\n<li>源代码: <a href=\"https://github.com/protocolbuffers/protobuf/blob/3.5.x/src/google/protobuf/stubs/shared_ptr.h\">shared_ptr</a> protocolbuffers库早期版本中使用的shared_ptr实现。简洁，易于学习。是本文主要参考的代码。</li>\n<li>编译环境: Windows、MSVC2019</li>\n<li>内存检测工具: <a href=\"https://kinddragon.github.io/vld/\">Visual Leak Detector</a></li>\n</ul>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2>"},{"title":"MQTT基础文档翻译(一):MQTT协议介绍","date":"2021-11-08T14:19:22.000Z","_content":"\n## 原文链接\n[Introducing the MQTT Protocol - MQTT Essentials: Part 1](https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/)\n<!--more-->\n## 正文\n欢迎阅读MQTT系列文章: 一个讲述MQTT协议核心特性和概念的系列博客，分为十个部分。这一篇博客概述了我们计划覆盖的内容，为你快速介绍MQTT，并提供一些关于这个协议有趣的背景故事。\n\n### 周一与MQTT见面!\n一年的初始是开启一件新事物的绝好时机。本着这种精神，我们正一步步完善我们的博客去覆盖更广的关于MQTT的话题。这些新的系列文章会对安全性和客户端程序库有深入的讲解，这里有许多很棒的内容可以帮助到你。每周一我们将会发布一篇新的关于MQTT的博客。所以，如果你对MQTT感兴趣，请定期查阅我们的博客。更好的方式是，订阅我们的简讯，然后就可以在博客发布的第一时间在邮箱中收到通知。<br/>\n我们希望这些文章可以让你快速、成功的明白和实现MQTT <br/>\n在这篇文章的末尾，我们有一个视频对这篇博客做补充，我们建议你阅读本文，并通过视频获取更多信息。\n\n### MQTT要点: 为什么，是什么，什么不是\n在我们进入今天的话题之前，先来解释以下为什么我们写这系列文章，这篇文章的受众是谁，还有在接下来的日子我们将覆盖哪些内容。HiveMQ团队长期做MQTT相关的工作。我们的专家每天在会议和网络上为客户回答关于MQTT核心概念的问题。这些问题关于 publish/subscribe，quality of services，和其他话题。 在MQTT系列文章中，我们希望去解释MQTT的主要概念并为用户提供一个简单易懂的参考指南。MQTT是一个开源的协议，我们认为如何使用MQTT的信息也应该开源。我们对于这项技术感到非常兴奋，也希望你可以从内容中获得帮助 <br />\n首先我们将探讨基础概念(publish/subscribe，client/broker)和MQTT的基础功能(Connect,Publish,Subscribe)。接下来，我们将关注一些特性: Quality of Service, Retained Messages, Persistent Session,Last Will 和 Testament, Keep Alive和其他。 <br />\n在系列文章中不会包含安全相关信息，安全性是MQTT一个很大的话题。事实上，他是一个特别重要的话题，我们发布了另一个系列文章来讲述MQTT安全相关的内容。\n\n### 介绍MQTT\n\"MQTT是一个客户端服务器，发布订阅模型的消息传输协议。它轻量级、开源、简单、易实现，这些特性使其成为许多情况下使用的理想选择，包括机器到机器通信(M2M)和物联网(IoT)等需要小内存占用，或带宽非常昂贵的受限环境。\" MQTT 3.1.1 specification 引文<br />\n上述引文很好的描述了MQTT是什么，它是一个非常轻量的二进制协议，并且由于它非常小的数据包开销，MQTT比HTTP协议更适合在电线间传输数据。MQTT协议另一个重要的优点是在客户端的实现非常容易。易用性是MQTT开发过程中的一个关键考量，这也让MQTT如今完美的适配了资源有限制的被约束设备。\n\n### 一些历史\nMQTT协议在1999年被 Andy Stanford-Clark (IBM) 和 Arlen Nipper (Arcom, now Cirrus Link) 发明出，他们需要一个低电量消耗、低带宽消耗的协议，用于通过卫星与输油管道连接。这两位发明者为此协议定下了一些必须的要求:\n\n- 实现简单\n- 保证数据传输的质量\n- 轻量级并且高效使用带宽\n- Data agnostic\n- Continuous session awareness\n\n这些目标一直是MQTT的核心。然而，协议最专注的部分已经由嵌入式设备转换到物联网应用上了。这个转换使MQTT所代表的全拼词语有了一些争议。简短的答案是，MQTT不再是一个缩写，而是一个协议的名称。<br />\n较为详细的答案是 MQTT在之前是MQ Telemetry Transport的缩写 <br />\n\"MQ\"代表的是IBM为了支持MQ Telemetry Transport开发的产品，当Andy和Arlen在1999年创造这个协议时，他们在IBM产品之后将其命名为MQTT。 许多地方错误的将MQTT解释为消息队列协议。MQTT不是一个传统的消息队列解决方案(尽管MQTT在一些特殊情况可能会用队列缓冲消息，我们在后面的章节会讲到)。在1999之后的10年里，IBM在内部使用这个协议，直到2010年他们发布了MQTT3.1作为一个无版权的发布版本。从那时开始，每个人都被欢迎去开发和使用MQTT协议。<br />\n我们在2012年开始了解MQTT，并在同年发布了HiveMQ的第一个版本。2013年，我们公开发布了HiveMQ。随着协议规范的发布，IBM捐献MQTT客户端实现给Eclipse基金会新成立的Paho课题。这些件事对MQTT协议有重大的影响，因为没有生态支持的协议很难被广泛的使用。\n### OASIS标准和当前版本\n大约在MQTT初始版本发布三年后，MQTT将由OASIS（一个致力于推进标准化的开源组织）定制标准。AMQP,SAML,和DocBook只是OASIS标准的一部分。标准化进程持续了大约一年，在2014年10月29日MQTT成为一个正式批准的OASIS标准。从3.1到3.1.1的小版本变化展现了和之前版本的变化。对于这些变化的细节信息，看另一篇博客 3.1.1带来的优势。 <br />\n在2019年3月，OASIS批准了新的MQTT5规范。新的MQTT版本引进了将物联网程序部署在云平台上所必须的特性，其中要求在实现关键消息的传输时需要有更高的可靠性和完善的错误处理。如果想要更多的了解MQTT5，请查看我们MQTT5相关系列文章。\n\n> 我们强烈建议使用MQTT 5。\n\n到了我们系列文章第一篇的结尾了，希望你阅读愉快并且了解到一些MQTT的新闻。感谢你的阅读请在下周继续关注我们的下篇介绍文章，关于发布和订阅模式还有MQTT与消息队列的不同之处 <br />\n\n如果你有任何反馈或问题，请在评论中告诉我们。\n","source":"_posts/MQTT基础文档翻译-一-MQTT协议介绍.md","raw":"---\ntitle: 'MQTT基础文档翻译(一):MQTT协议介绍'\ndate: 2021-11-08 22:19:22\ntags: MQTT\n---\n\n## 原文链接\n[Introducing the MQTT Protocol - MQTT Essentials: Part 1](https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/)\n<!--more-->\n## 正文\n欢迎阅读MQTT系列文章: 一个讲述MQTT协议核心特性和概念的系列博客，分为十个部分。这一篇博客概述了我们计划覆盖的内容，为你快速介绍MQTT，并提供一些关于这个协议有趣的背景故事。\n\n### 周一与MQTT见面!\n一年的初始是开启一件新事物的绝好时机。本着这种精神，我们正一步步完善我们的博客去覆盖更广的关于MQTT的话题。这些新的系列文章会对安全性和客户端程序库有深入的讲解，这里有许多很棒的内容可以帮助到你。每周一我们将会发布一篇新的关于MQTT的博客。所以，如果你对MQTT感兴趣，请定期查阅我们的博客。更好的方式是，订阅我们的简讯，然后就可以在博客发布的第一时间在邮箱中收到通知。<br/>\n我们希望这些文章可以让你快速、成功的明白和实现MQTT <br/>\n在这篇文章的末尾，我们有一个视频对这篇博客做补充，我们建议你阅读本文，并通过视频获取更多信息。\n\n### MQTT要点: 为什么，是什么，什么不是\n在我们进入今天的话题之前，先来解释以下为什么我们写这系列文章，这篇文章的受众是谁，还有在接下来的日子我们将覆盖哪些内容。HiveMQ团队长期做MQTT相关的工作。我们的专家每天在会议和网络上为客户回答关于MQTT核心概念的问题。这些问题关于 publish/subscribe，quality of services，和其他话题。 在MQTT系列文章中，我们希望去解释MQTT的主要概念并为用户提供一个简单易懂的参考指南。MQTT是一个开源的协议，我们认为如何使用MQTT的信息也应该开源。我们对于这项技术感到非常兴奋，也希望你可以从内容中获得帮助 <br />\n首先我们将探讨基础概念(publish/subscribe，client/broker)和MQTT的基础功能(Connect,Publish,Subscribe)。接下来，我们将关注一些特性: Quality of Service, Retained Messages, Persistent Session,Last Will 和 Testament, Keep Alive和其他。 <br />\n在系列文章中不会包含安全相关信息，安全性是MQTT一个很大的话题。事实上，他是一个特别重要的话题，我们发布了另一个系列文章来讲述MQTT安全相关的内容。\n\n### 介绍MQTT\n\"MQTT是一个客户端服务器，发布订阅模型的消息传输协议。它轻量级、开源、简单、易实现，这些特性使其成为许多情况下使用的理想选择，包括机器到机器通信(M2M)和物联网(IoT)等需要小内存占用，或带宽非常昂贵的受限环境。\" MQTT 3.1.1 specification 引文<br />\n上述引文很好的描述了MQTT是什么，它是一个非常轻量的二进制协议，并且由于它非常小的数据包开销，MQTT比HTTP协议更适合在电线间传输数据。MQTT协议另一个重要的优点是在客户端的实现非常容易。易用性是MQTT开发过程中的一个关键考量，这也让MQTT如今完美的适配了资源有限制的被约束设备。\n\n### 一些历史\nMQTT协议在1999年被 Andy Stanford-Clark (IBM) 和 Arlen Nipper (Arcom, now Cirrus Link) 发明出，他们需要一个低电量消耗、低带宽消耗的协议，用于通过卫星与输油管道连接。这两位发明者为此协议定下了一些必须的要求:\n\n- 实现简单\n- 保证数据传输的质量\n- 轻量级并且高效使用带宽\n- Data agnostic\n- Continuous session awareness\n\n这些目标一直是MQTT的核心。然而，协议最专注的部分已经由嵌入式设备转换到物联网应用上了。这个转换使MQTT所代表的全拼词语有了一些争议。简短的答案是，MQTT不再是一个缩写，而是一个协议的名称。<br />\n较为详细的答案是 MQTT在之前是MQ Telemetry Transport的缩写 <br />\n\"MQ\"代表的是IBM为了支持MQ Telemetry Transport开发的产品，当Andy和Arlen在1999年创造这个协议时，他们在IBM产品之后将其命名为MQTT。 许多地方错误的将MQTT解释为消息队列协议。MQTT不是一个传统的消息队列解决方案(尽管MQTT在一些特殊情况可能会用队列缓冲消息，我们在后面的章节会讲到)。在1999之后的10年里，IBM在内部使用这个协议，直到2010年他们发布了MQTT3.1作为一个无版权的发布版本。从那时开始，每个人都被欢迎去开发和使用MQTT协议。<br />\n我们在2012年开始了解MQTT，并在同年发布了HiveMQ的第一个版本。2013年，我们公开发布了HiveMQ。随着协议规范的发布，IBM捐献MQTT客户端实现给Eclipse基金会新成立的Paho课题。这些件事对MQTT协议有重大的影响，因为没有生态支持的协议很难被广泛的使用。\n### OASIS标准和当前版本\n大约在MQTT初始版本发布三年后，MQTT将由OASIS（一个致力于推进标准化的开源组织）定制标准。AMQP,SAML,和DocBook只是OASIS标准的一部分。标准化进程持续了大约一年，在2014年10月29日MQTT成为一个正式批准的OASIS标准。从3.1到3.1.1的小版本变化展现了和之前版本的变化。对于这些变化的细节信息，看另一篇博客 3.1.1带来的优势。 <br />\n在2019年3月，OASIS批准了新的MQTT5规范。新的MQTT版本引进了将物联网程序部署在云平台上所必须的特性，其中要求在实现关键消息的传输时需要有更高的可靠性和完善的错误处理。如果想要更多的了解MQTT5，请查看我们MQTT5相关系列文章。\n\n> 我们强烈建议使用MQTT 5。\n\n到了我们系列文章第一篇的结尾了，希望你阅读愉快并且了解到一些MQTT的新闻。感谢你的阅读请在下周继续关注我们的下篇介绍文章，关于发布和订阅模式还有MQTT与消息队列的不同之处 <br />\n\n如果你有任何反馈或问题，请在评论中告诉我们。\n","slug":"MQTT基础文档翻译-一-MQTT协议介绍","published":1,"updated":"2021-11-13T07:27:12.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0b4dtq60001vsvi7rp6f8yw","content":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/\">Introducing the MQTT Protocol - MQTT Essentials: Part 1</a></p>\n<span id=\"more\"></span>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎阅读MQTT系列文章: 一个讲述MQTT协议核心特性和概念的系列博客，分为十个部分。这一篇博客概述了我们计划覆盖的内容，为你快速介绍MQTT，并提供一些关于这个协议有趣的背景故事。</p>\n<h3 id=\"周一与MQTT见面\"><a href=\"#周一与MQTT见面\" class=\"headerlink\" title=\"周一与MQTT见面!\"></a>周一与MQTT见面!</h3><p>一年的初始是开启一件新事物的绝好时机。本着这种精神，我们正一步步完善我们的博客去覆盖更广的关于MQTT的话题。这些新的系列文章会对安全性和客户端程序库有深入的讲解，这里有许多很棒的内容可以帮助到你。每周一我们将会发布一篇新的关于MQTT的博客。所以，如果你对MQTT感兴趣，请定期查阅我们的博客。更好的方式是，订阅我们的简讯，然后就可以在博客发布的第一时间在邮箱中收到通知。<br/><br>我们希望这些文章可以让你快速、成功的明白和实现MQTT <br/><br>在这篇文章的末尾，我们有一个视频对这篇博客做补充，我们建议你阅读本文，并通过视频获取更多信息。</p>\n<h3 id=\"MQTT要点-为什么，是什么，什么不是\"><a href=\"#MQTT要点-为什么，是什么，什么不是\" class=\"headerlink\" title=\"MQTT要点: 为什么，是什么，什么不是\"></a>MQTT要点: 为什么，是什么，什么不是</h3><p>在我们进入今天的话题之前，先来解释以下为什么我们写这系列文章，这篇文章的受众是谁，还有在接下来的日子我们将覆盖哪些内容。HiveMQ团队长期做MQTT相关的工作。我们的专家每天在会议和网络上为客户回答关于MQTT核心概念的问题。这些问题关于 publish/subscribe，quality of services，和其他话题。 在MQTT系列文章中，我们希望去解释MQTT的主要概念并为用户提供一个简单易懂的参考指南。MQTT是一个开源的协议，我们认为如何使用MQTT的信息也应该开源。我们对于这项技术感到非常兴奋，也希望你可以从内容中获得帮助 <br /><br>首先我们将探讨基础概念(publish/subscribe，client/broker)和MQTT的基础功能(Connect,Publish,Subscribe)。接下来，我们将关注一些特性: Quality of Service, Retained Messages, Persistent Session,Last Will 和 Testament, Keep Alive和其他。 <br /><br>在系列文章中不会包含安全相关信息，安全性是MQTT一个很大的话题。事实上，他是一个特别重要的话题，我们发布了另一个系列文章来讲述MQTT安全相关的内容。</p>\n<h3 id=\"介绍MQTT\"><a href=\"#介绍MQTT\" class=\"headerlink\" title=\"介绍MQTT\"></a>介绍MQTT</h3><p>“MQTT是一个客户端服务器，发布订阅模型的消息传输协议。它轻量级、开源、简单、易实现，这些特性使其成为许多情况下使用的理想选择，包括机器到机器通信(M2M)和物联网(IoT)等需要小内存占用，或带宽非常昂贵的受限环境。” MQTT 3.1.1 specification 引文<br /><br>上述引文很好的描述了MQTT是什么，它是一个非常轻量的二进制协议，并且由于它非常小的数据包开销，MQTT比HTTP协议更适合在电线间传输数据。MQTT协议另一个重要的优点是在客户端的实现非常容易。易用性是MQTT开发过程中的一个关键考量，这也让MQTT如今完美的适配了资源有限制的被约束设备。</p>\n<h3 id=\"一些历史\"><a href=\"#一些历史\" class=\"headerlink\" title=\"一些历史\"></a>一些历史</h3><p>MQTT协议在1999年被 Andy Stanford-Clark (IBM) 和 Arlen Nipper (Arcom, now Cirrus Link) 发明出，他们需要一个低电量消耗、低带宽消耗的协议，用于通过卫星与输油管道连接。这两位发明者为此协议定下了一些必须的要求:</p>\n<ul>\n<li>实现简单</li>\n<li>保证数据传输的质量</li>\n<li>轻量级并且高效使用带宽</li>\n<li>Data agnostic</li>\n<li>Continuous session awareness</li>\n</ul>\n<p>这些目标一直是MQTT的核心。然而，协议最专注的部分已经由嵌入式设备转换到物联网应用上了。这个转换使MQTT所代表的全拼词语有了一些争议。简短的答案是，MQTT不再是一个缩写，而是一个协议的名称。<br /><br>较为详细的答案是 MQTT在之前是MQ Telemetry Transport的缩写 <br /><br>“MQ”代表的是IBM为了支持MQ Telemetry Transport开发的产品，当Andy和Arlen在1999年创造这个协议时，他们在IBM产品之后将其命名为MQTT。 许多地方错误的将MQTT解释为消息队列协议。MQTT不是一个传统的消息队列解决方案(尽管MQTT在一些特殊情况可能会用队列缓冲消息，我们在后面的章节会讲到)。在1999之后的10年里，IBM在内部使用这个协议，直到2010年他们发布了MQTT3.1作为一个无版权的发布版本。从那时开始，每个人都被欢迎去开发和使用MQTT协议。<br /><br>我们在2012年开始了解MQTT，并在同年发布了HiveMQ的第一个版本。2013年，我们公开发布了HiveMQ。随着协议规范的发布，IBM捐献MQTT客户端实现给Eclipse基金会新成立的Paho课题。这些件事对MQTT协议有重大的影响，因为没有生态支持的协议很难被广泛的使用。</p>\n<h3 id=\"OASIS标准和当前版本\"><a href=\"#OASIS标准和当前版本\" class=\"headerlink\" title=\"OASIS标准和当前版本\"></a>OASIS标准和当前版本</h3><p>大约在MQTT初始版本发布三年后，MQTT将由OASIS（一个致力于推进标准化的开源组织）定制标准。AMQP,SAML,和DocBook只是OASIS标准的一部分。标准化进程持续了大约一年，在2014年10月29日MQTT成为一个正式批准的OASIS标准。从3.1到3.1.1的小版本变化展现了和之前版本的变化。对于这些变化的细节信息，看另一篇博客 3.1.1带来的优势。 <br /><br>在2019年3月，OASIS批准了新的MQTT5规范。新的MQTT版本引进了将物联网程序部署在云平台上所必须的特性，其中要求在实现关键消息的传输时需要有更高的可靠性和完善的错误处理。如果想要更多的了解MQTT5，请查看我们MQTT5相关系列文章。</p>\n<blockquote>\n<p>我们强烈建议使用MQTT 5。</p>\n</blockquote>\n<p>到了我们系列文章第一篇的结尾了，希望你阅读愉快并且了解到一些MQTT的新闻。感谢你的阅读请在下周继续关注我们的下篇介绍文章，关于发布和订阅模式还有MQTT与消息队列的不同之处 <br /></p>\n<p>如果你有任何反馈或问题，请在评论中告诉我们。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt/\">Introducing the MQTT Protocol - MQTT Essentials: Part 1</a></p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎阅读MQTT系列文章: 一个讲述MQTT协议核心特性和概念的系列博客，分为十个部分。这一篇博客概述了我们计划覆盖的内容，为你快速介绍MQTT，并提供一些关于这个协议有趣的背景故事。</p>\n<h3 id=\"周一与MQTT见面\"><a href=\"#周一与MQTT见面\" class=\"headerlink\" title=\"周一与MQTT见面!\"></a>周一与MQTT见面!</h3><p>一年的初始是开启一件新事物的绝好时机。本着这种精神，我们正一步步完善我们的博客去覆盖更广的关于MQTT的话题。这些新的系列文章会对安全性和客户端程序库有深入的讲解，这里有许多很棒的内容可以帮助到你。每周一我们将会发布一篇新的关于MQTT的博客。所以，如果你对MQTT感兴趣，请定期查阅我们的博客。更好的方式是，订阅我们的简讯，然后就可以在博客发布的第一时间在邮箱中收到通知。<br/><br>我们希望这些文章可以让你快速、成功的明白和实现MQTT <br/><br>在这篇文章的末尾，我们有一个视频对这篇博客做补充，我们建议你阅读本文，并通过视频获取更多信息。</p>\n<h3 id=\"MQTT要点-为什么，是什么，什么不是\"><a href=\"#MQTT要点-为什么，是什么，什么不是\" class=\"headerlink\" title=\"MQTT要点: 为什么，是什么，什么不是\"></a>MQTT要点: 为什么，是什么，什么不是</h3><p>在我们进入今天的话题之前，先来解释以下为什么我们写这系列文章，这篇文章的受众是谁，还有在接下来的日子我们将覆盖哪些内容。HiveMQ团队长期做MQTT相关的工作。我们的专家每天在会议和网络上为客户回答关于MQTT核心概念的问题。这些问题关于 publish/subscribe，quality of services，和其他话题。 在MQTT系列文章中，我们希望去解释MQTT的主要概念并为用户提供一个简单易懂的参考指南。MQTT是一个开源的协议，我们认为如何使用MQTT的信息也应该开源。我们对于这项技术感到非常兴奋，也希望你可以从内容中获得帮助 <br /><br>首先我们将探讨基础概念(publish/subscribe，client/broker)和MQTT的基础功能(Connect,Publish,Subscribe)。接下来，我们将关注一些特性: Quality of Service, Retained Messages, Persistent Session,Last Will 和 Testament, Keep Alive和其他。 <br /><br>在系列文章中不会包含安全相关信息，安全性是MQTT一个很大的话题。事实上，他是一个特别重要的话题，我们发布了另一个系列文章来讲述MQTT安全相关的内容。</p>\n<h3 id=\"介绍MQTT\"><a href=\"#介绍MQTT\" class=\"headerlink\" title=\"介绍MQTT\"></a>介绍MQTT</h3><p>“MQTT是一个客户端服务器，发布订阅模型的消息传输协议。它轻量级、开源、简单、易实现，这些特性使其成为许多情况下使用的理想选择，包括机器到机器通信(M2M)和物联网(IoT)等需要小内存占用，或带宽非常昂贵的受限环境。” MQTT 3.1.1 specification 引文<br /><br>上述引文很好的描述了MQTT是什么，它是一个非常轻量的二进制协议，并且由于它非常小的数据包开销，MQTT比HTTP协议更适合在电线间传输数据。MQTT协议另一个重要的优点是在客户端的实现非常容易。易用性是MQTT开发过程中的一个关键考量，这也让MQTT如今完美的适配了资源有限制的被约束设备。</p>\n<h3 id=\"一些历史\"><a href=\"#一些历史\" class=\"headerlink\" title=\"一些历史\"></a>一些历史</h3><p>MQTT协议在1999年被 Andy Stanford-Clark (IBM) 和 Arlen Nipper (Arcom, now Cirrus Link) 发明出，他们需要一个低电量消耗、低带宽消耗的协议，用于通过卫星与输油管道连接。这两位发明者为此协议定下了一些必须的要求:</p>\n<ul>\n<li>实现简单</li>\n<li>保证数据传输的质量</li>\n<li>轻量级并且高效使用带宽</li>\n<li>Data agnostic</li>\n<li>Continuous session awareness</li>\n</ul>\n<p>这些目标一直是MQTT的核心。然而，协议最专注的部分已经由嵌入式设备转换到物联网应用上了。这个转换使MQTT所代表的全拼词语有了一些争议。简短的答案是，MQTT不再是一个缩写，而是一个协议的名称。<br /><br>较为详细的答案是 MQTT在之前是MQ Telemetry Transport的缩写 <br /><br>“MQ”代表的是IBM为了支持MQ Telemetry Transport开发的产品，当Andy和Arlen在1999年创造这个协议时，他们在IBM产品之后将其命名为MQTT。 许多地方错误的将MQTT解释为消息队列协议。MQTT不是一个传统的消息队列解决方案(尽管MQTT在一些特殊情况可能会用队列缓冲消息，我们在后面的章节会讲到)。在1999之后的10年里，IBM在内部使用这个协议，直到2010年他们发布了MQTT3.1作为一个无版权的发布版本。从那时开始，每个人都被欢迎去开发和使用MQTT协议。<br /><br>我们在2012年开始了解MQTT，并在同年发布了HiveMQ的第一个版本。2013年，我们公开发布了HiveMQ。随着协议规范的发布，IBM捐献MQTT客户端实现给Eclipse基金会新成立的Paho课题。这些件事对MQTT协议有重大的影响，因为没有生态支持的协议很难被广泛的使用。</p>\n<h3 id=\"OASIS标准和当前版本\"><a href=\"#OASIS标准和当前版本\" class=\"headerlink\" title=\"OASIS标准和当前版本\"></a>OASIS标准和当前版本</h3><p>大约在MQTT初始版本发布三年后，MQTT将由OASIS（一个致力于推进标准化的开源组织）定制标准。AMQP,SAML,和DocBook只是OASIS标准的一部分。标准化进程持续了大约一年，在2014年10月29日MQTT成为一个正式批准的OASIS标准。从3.1到3.1.1的小版本变化展现了和之前版本的变化。对于这些变化的细节信息，看另一篇博客 3.1.1带来的优势。 <br /><br>在2019年3月，OASIS批准了新的MQTT5规范。新的MQTT版本引进了将物联网程序部署在云平台上所必须的特性，其中要求在实现关键消息的传输时需要有更高的可靠性和完善的错误处理。如果想要更多的了解MQTT5，请查看我们MQTT5相关系列文章。</p>\n<blockquote>\n<p>我们强烈建议使用MQTT 5。</p>\n</blockquote>\n<p>到了我们系列文章第一篇的结尾了，希望你阅读愉快并且了解到一些MQTT的新闻。感谢你的阅读请在下周继续关注我们的下篇介绍文章，关于发布和订阅模式还有MQTT与消息队列的不同之处 <br /></p>\n<p>如果你有任何反馈或问题，请在评论中告诉我们。</p>"},{"title":"MQTT基础文档翻译(二):发布和订阅","date":"2021-11-10T15:54:54.000Z","_content":"## 原文链接\n[Publish & Subscribe - MQTT Essentials: Part 2](https://www.hivemq.com/blog/mqtt-essentials-part2-publish-subscribe/)\n<!--more-->\n## 正文\n欢迎来到MQTT要点系列的第二版，分为十章的关于MQTT协议核心特点和概念的系列文章。在系列文章的第一章，我们介绍了MQTT并讨论了MQTT协议的来源和历史。如果你错过了第一章，你绝对应该看一看。 <br/>\n我们有一个关于发布订阅模式的视频在文章末尾来帮助你补充相关知识\n### 发布/订阅模式\n发布订阅/模式提供了一种传统客户端-服务器架构的替代品。在客户端-服务器模型中，客户端直接与端点通信。而发布/订阅模型将消息发送者和接收者解耦，发布消息的客户端被称为发布者，接收消息的客户端被称为订阅者。发布者和订阅者永远不会直接通信。事实上，他们甚至不知道对方的存在。他们之间的通信被第三方组件(the broker)处理。broker的工作是过滤所有到来的消息，然后将消息分发给正确的订阅者。接下来，让我们深入了解一下发布订阅的相关特性。\n![](mqtt-publish-subscribe.svg)\n发布订阅模式最重要的特性是消息发送者和接收者的解耦，这种解耦有几个方面\n\n- 空间解耦: 发布者和订阅者不需要知道对方(例如，不需要知道ip地址和端口)\n- 时间解耦: 发布者和订阅者不需要在同一时间运行\n- 同步解耦: 在两个组件上的操作在发布或接收消息时不需要被中断\n\n总的来说，发布/订阅模式移除了消息发布者和接收者的直接交流。通过broker的过滤可以控制订阅者接收到哪些消息。它在三方面解耦:空间、时间、同步性\n### 可扩展性\n发布\\订阅模式的可扩展性好于传统的客户端服务器架构。因为broker的操作有很高的并行性，而且消息可以以事件驱动的模式去处理。消息缓存和合理的路由选择通常是提高可扩展性的关键因素。尽管如此，拓展到百万级别的连接数仍然是一个挑战。这样高级别的连接数可以通过broker节点集群和负载均衡来解决(这个话题超过了这篇文章讲述的范围，我们在另外的文章中讲述相关的消息)\n### 消息过滤\n显而易见，broker在发布/订阅过程中扮演了重要的角色。那么,broker是如何管理所有的消息并在传输给某个订阅者消息时，只传递他感兴趣的话题下的消息呢?正如你所看到的，broker有一些过滤选项。\n> 选项一: 基于主题的过滤\n\n过滤的过程基于每条消息中的主题或话题。接收方客户端向broker订阅感兴趣的话题，从订阅之后开始，broker确保接收方客户端会收到所有被订阅主题下的消息。通常情况下，主题是一个有层次结构的字符串并借此结构可以实现基于有限数量表达式的过滤。\n> 选项二: 基于内容的过滤\n\n在基于内容的过滤中，broker基于内容中特殊的过滤语言来过滤消息。接收方客户端向broker订阅他感兴趣的查询条件。这个方法重大的缺点是消息内容必须提前知晓，而且不能被加密或有任何简单的变化。\n> 选项三: 基于类型的过滤\n\n在我们使用面向对象语言时，基于类型的过滤是一种常见的做法。例如，一个订阅者可以订阅所有\"异常\"类型的消息，或任何其他的子类型<br/>\n当然，发布/订阅模式并非适应于所有的情况。在使用这种模式之前，你需要考虑一些事情。对发布者和订阅者的解耦是发布/订阅模式的关键，这为我们带来了一些挑战。比如说，你需要提前明白被发布的消息是如何组织的。针对基于主题的过滤，发布者和订阅者双发都需要知道要使用哪一个话题。另一个需要注意的事情是消息交付。发布者不能认为被发出的消息有被任何一方所监听，在某些时候，一条消息不属于任何订阅者的情况是存在的。\n### MQTT\n现在我们来探索发布/订阅模式的一种实际应用——MQTT。正如你所想，MQTT体现了之前提到的发布/订阅模式所有特性:\n\n- MQTT在空间上解耦了发布者和订阅者，为了发布或订阅消息，发布者和订阅者只需要知道broker的主机名/IP地址和端口\n- MQTT实现了时间解耦。尽管MQTT通常会实时传递消息。但如果有需要，broker可以在客户端不在线时存储消息。(存储消息必须满足条件:客户端曾有一个持续会话，并且订阅话题时设置QoS级别大于0)\n- MQTT使用异步的方式工作。因为大多数客户端类库基于回调或类似的模型用异步的方式工作。任务在等待消息或者发布消息时不会阻塞。在特定的情况下，需要同步模式去等待一个特定的消息，一些开发库有同步的API，但是工作流通常时异步的。\n\nMQTT另一个值得被提到的事是他在客户端一方非常易用。大多数发布/订阅模式系统相关的逻辑都在broker一方。当在运用MQTT客户端库时符合了发布/订阅模式的特性，并且让他成为一个适用于资源受限设备的轻量协议。<br/>\nMQTT使用基于主题的消息过滤。每条消息带有一个主题，所以broker可以用主题信息来决定将这个消息发向哪个订阅者。在第五篇文章中，我们会了解更多关于主题的内容。如果需要，你也可以使用HiveMQ和我们的自定义扩展系统建立一个基于内容过滤的MQTT broker。 <br/>\n为了解决发布/订阅系统带来的挑战，MQTT有三个服务质量(Quality of Service)级别。你可以简单的认为消息成功的发布到broker，或成功的从broker发出。然而，存在一种情况:没有一个订阅者订阅某个特定的话题。如果这会带来一些问题，broker必须知道该如何处理这种情况。例如，HiveMQ MQTT broker有一个插件系统可以处理这种情况。你可以让broker采取一些行为，或者简单的将每条消息打印到数据中方便查阅。为了保持话题树结构的灵活性，必须认真的设计话题树并且为未来可能的变化留有足够的空间。如果你遵循这些策略，MQTT是一个完美的协议帮助你搭建产品。\n### 与消息队列的区别\n关于MQTT名称的由来和此协议是否有消息队列的实现有许多争议。我们将在这个主题上阐明一些观点，并说明MQTT和消息队列的区别。在我们上一篇文章中，我们提到MQTT中MQ是IBM的MQ系列产品，和消息队列无关。不管名字的来源具体是什么，有必要了解一些MQTT和传统消息队列的区别:\n\n- 消息队列存储着消息知道他们被消费。在你使用消息队列时，收到的每个消息都被存储在队列中，直到他们被客户端(通常被称为消费者)取走。如果没有消费者取走消息，那么消息会一直存储在队列中，直到被取走。在消息队列中，一条消息没有被任何客户端所处理就丢弃是不可能的。但是在MQTT中是可能的，例如没有客户端订阅某个话题时，发往该话题的消息将被丢弃。\n- 一条消息只被一个客户端处理。另一个巨大的区别是在传统的消息队列中，一条消息只能被一个消费者处理。所有消费者等待一个队列。 在MQTT中，行为是完全相反的，每一个订阅某个主题的订阅者都会获得消息。\n- 队列需要被命名而且需要被明确的创建。一个队列比话题更加死板。在一个队列可以使用之前，队列必须被另外的命令明确的创建，只有在被明确创建并命名后才可以用于生产和消费消息。相反，MQTT 话题更加灵活，可以被任意的创建。\n\n如果您可以想到任何其他的不同被我们忽略了，希望可以在评论中指出。 <br/>\n系列文章的第二篇结束了。下一周我们去仔细了解以下什么是MQTT客户端和broker还有他们是如何连接的。","source":"_posts/MQTT基础文档翻译-二-发布和订阅.md","raw":"---\ntitle: 'MQTT基础文档翻译(二):发布和订阅'\ndate: 2021-11-10 23:54:54\ntags: MQTT\n---\n## 原文链接\n[Publish & Subscribe - MQTT Essentials: Part 2](https://www.hivemq.com/blog/mqtt-essentials-part2-publish-subscribe/)\n<!--more-->\n## 正文\n欢迎来到MQTT要点系列的第二版，分为十章的关于MQTT协议核心特点和概念的系列文章。在系列文章的第一章，我们介绍了MQTT并讨论了MQTT协议的来源和历史。如果你错过了第一章，你绝对应该看一看。 <br/>\n我们有一个关于发布订阅模式的视频在文章末尾来帮助你补充相关知识\n### 发布/订阅模式\n发布订阅/模式提供了一种传统客户端-服务器架构的替代品。在客户端-服务器模型中，客户端直接与端点通信。而发布/订阅模型将消息发送者和接收者解耦，发布消息的客户端被称为发布者，接收消息的客户端被称为订阅者。发布者和订阅者永远不会直接通信。事实上，他们甚至不知道对方的存在。他们之间的通信被第三方组件(the broker)处理。broker的工作是过滤所有到来的消息，然后将消息分发给正确的订阅者。接下来，让我们深入了解一下发布订阅的相关特性。\n![](mqtt-publish-subscribe.svg)\n发布订阅模式最重要的特性是消息发送者和接收者的解耦，这种解耦有几个方面\n\n- 空间解耦: 发布者和订阅者不需要知道对方(例如，不需要知道ip地址和端口)\n- 时间解耦: 发布者和订阅者不需要在同一时间运行\n- 同步解耦: 在两个组件上的操作在发布或接收消息时不需要被中断\n\n总的来说，发布/订阅模式移除了消息发布者和接收者的直接交流。通过broker的过滤可以控制订阅者接收到哪些消息。它在三方面解耦:空间、时间、同步性\n### 可扩展性\n发布\\订阅模式的可扩展性好于传统的客户端服务器架构。因为broker的操作有很高的并行性，而且消息可以以事件驱动的模式去处理。消息缓存和合理的路由选择通常是提高可扩展性的关键因素。尽管如此，拓展到百万级别的连接数仍然是一个挑战。这样高级别的连接数可以通过broker节点集群和负载均衡来解决(这个话题超过了这篇文章讲述的范围，我们在另外的文章中讲述相关的消息)\n### 消息过滤\n显而易见，broker在发布/订阅过程中扮演了重要的角色。那么,broker是如何管理所有的消息并在传输给某个订阅者消息时，只传递他感兴趣的话题下的消息呢?正如你所看到的，broker有一些过滤选项。\n> 选项一: 基于主题的过滤\n\n过滤的过程基于每条消息中的主题或话题。接收方客户端向broker订阅感兴趣的话题，从订阅之后开始，broker确保接收方客户端会收到所有被订阅主题下的消息。通常情况下，主题是一个有层次结构的字符串并借此结构可以实现基于有限数量表达式的过滤。\n> 选项二: 基于内容的过滤\n\n在基于内容的过滤中，broker基于内容中特殊的过滤语言来过滤消息。接收方客户端向broker订阅他感兴趣的查询条件。这个方法重大的缺点是消息内容必须提前知晓，而且不能被加密或有任何简单的变化。\n> 选项三: 基于类型的过滤\n\n在我们使用面向对象语言时，基于类型的过滤是一种常见的做法。例如，一个订阅者可以订阅所有\"异常\"类型的消息，或任何其他的子类型<br/>\n当然，发布/订阅模式并非适应于所有的情况。在使用这种模式之前，你需要考虑一些事情。对发布者和订阅者的解耦是发布/订阅模式的关键，这为我们带来了一些挑战。比如说，你需要提前明白被发布的消息是如何组织的。针对基于主题的过滤，发布者和订阅者双发都需要知道要使用哪一个话题。另一个需要注意的事情是消息交付。发布者不能认为被发出的消息有被任何一方所监听，在某些时候，一条消息不属于任何订阅者的情况是存在的。\n### MQTT\n现在我们来探索发布/订阅模式的一种实际应用——MQTT。正如你所想，MQTT体现了之前提到的发布/订阅模式所有特性:\n\n- MQTT在空间上解耦了发布者和订阅者，为了发布或订阅消息，发布者和订阅者只需要知道broker的主机名/IP地址和端口\n- MQTT实现了时间解耦。尽管MQTT通常会实时传递消息。但如果有需要，broker可以在客户端不在线时存储消息。(存储消息必须满足条件:客户端曾有一个持续会话，并且订阅话题时设置QoS级别大于0)\n- MQTT使用异步的方式工作。因为大多数客户端类库基于回调或类似的模型用异步的方式工作。任务在等待消息或者发布消息时不会阻塞。在特定的情况下，需要同步模式去等待一个特定的消息，一些开发库有同步的API，但是工作流通常时异步的。\n\nMQTT另一个值得被提到的事是他在客户端一方非常易用。大多数发布/订阅模式系统相关的逻辑都在broker一方。当在运用MQTT客户端库时符合了发布/订阅模式的特性，并且让他成为一个适用于资源受限设备的轻量协议。<br/>\nMQTT使用基于主题的消息过滤。每条消息带有一个主题，所以broker可以用主题信息来决定将这个消息发向哪个订阅者。在第五篇文章中，我们会了解更多关于主题的内容。如果需要，你也可以使用HiveMQ和我们的自定义扩展系统建立一个基于内容过滤的MQTT broker。 <br/>\n为了解决发布/订阅系统带来的挑战，MQTT有三个服务质量(Quality of Service)级别。你可以简单的认为消息成功的发布到broker，或成功的从broker发出。然而，存在一种情况:没有一个订阅者订阅某个特定的话题。如果这会带来一些问题，broker必须知道该如何处理这种情况。例如，HiveMQ MQTT broker有一个插件系统可以处理这种情况。你可以让broker采取一些行为，或者简单的将每条消息打印到数据中方便查阅。为了保持话题树结构的灵活性，必须认真的设计话题树并且为未来可能的变化留有足够的空间。如果你遵循这些策略，MQTT是一个完美的协议帮助你搭建产品。\n### 与消息队列的区别\n关于MQTT名称的由来和此协议是否有消息队列的实现有许多争议。我们将在这个主题上阐明一些观点，并说明MQTT和消息队列的区别。在我们上一篇文章中，我们提到MQTT中MQ是IBM的MQ系列产品，和消息队列无关。不管名字的来源具体是什么，有必要了解一些MQTT和传统消息队列的区别:\n\n- 消息队列存储着消息知道他们被消费。在你使用消息队列时，收到的每个消息都被存储在队列中，直到他们被客户端(通常被称为消费者)取走。如果没有消费者取走消息，那么消息会一直存储在队列中，直到被取走。在消息队列中，一条消息没有被任何客户端所处理就丢弃是不可能的。但是在MQTT中是可能的，例如没有客户端订阅某个话题时，发往该话题的消息将被丢弃。\n- 一条消息只被一个客户端处理。另一个巨大的区别是在传统的消息队列中，一条消息只能被一个消费者处理。所有消费者等待一个队列。 在MQTT中，行为是完全相反的，每一个订阅某个主题的订阅者都会获得消息。\n- 队列需要被命名而且需要被明确的创建。一个队列比话题更加死板。在一个队列可以使用之前，队列必须被另外的命令明确的创建，只有在被明确创建并命名后才可以用于生产和消费消息。相反，MQTT 话题更加灵活，可以被任意的创建。\n\n如果您可以想到任何其他的不同被我们忽略了，希望可以在评论中指出。 <br/>\n系列文章的第二篇结束了。下一周我们去仔细了解以下什么是MQTT客户端和broker还有他们是如何连接的。","slug":"MQTT基础文档翻译-二-发布和订阅","published":1,"updated":"2021-11-13T07:57:41.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0b4dtq80003vsvi8eqdf8yy","content":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part2-publish-subscribe/\">Publish &amp; Subscribe - MQTT Essentials: Part 2</a></p>\n<span id=\"more\"></span>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到MQTT要点系列的第二版，分为十章的关于MQTT协议核心特点和概念的系列文章。在系列文章的第一章，我们介绍了MQTT并讨论了MQTT协议的来源和历史。如果你错过了第一章，你绝对应该看一看。 <br/><br>我们有一个关于发布订阅模式的视频在文章末尾来帮助你补充相关知识</p>\n<h3 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布/订阅模式\"></a>发布/订阅模式</h3><p>发布订阅/模式提供了一种传统客户端-服务器架构的替代品。在客户端-服务器模型中，客户端直接与端点通信。而发布/订阅模型将消息发送者和接收者解耦，发布消息的客户端被称为发布者，接收消息的客户端被称为订阅者。发布者和订阅者永远不会直接通信。事实上，他们甚至不知道对方的存在。他们之间的通信被第三方组件(the broker)处理。broker的工作是过滤所有到来的消息，然后将消息分发给正确的订阅者。接下来，让我们深入了解一下发布订阅的相关特性。<br><img src= \"/img/loading.gif\" data-src=\"/2021/11/10/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8C-%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/mqtt-publish-subscribe.svg\"><br>发布订阅模式最重要的特性是消息发送者和接收者的解耦，这种解耦有几个方面</p>\n<ul>\n<li>空间解耦: 发布者和订阅者不需要知道对方(例如，不需要知道ip地址和端口)</li>\n<li>时间解耦: 发布者和订阅者不需要在同一时间运行</li>\n<li>同步解耦: 在两个组件上的操作在发布或接收消息时不需要被中断</li>\n</ul>\n<p>总的来说，发布/订阅模式移除了消息发布者和接收者的直接交流。通过broker的过滤可以控制订阅者接收到哪些消息。它在三方面解耦:空间、时间、同步性</p>\n<h3 id=\"可扩展性\"><a href=\"#可扩展性\" class=\"headerlink\" title=\"可扩展性\"></a>可扩展性</h3><p>发布\\订阅模式的可扩展性好于传统的客户端服务器架构。因为broker的操作有很高的并行性，而且消息可以以事件驱动的模式去处理。消息缓存和合理的路由选择通常是提高可扩展性的关键因素。尽管如此，拓展到百万级别的连接数仍然是一个挑战。这样高级别的连接数可以通过broker节点集群和负载均衡来解决(这个话题超过了这篇文章讲述的范围，我们在另外的文章中讲述相关的消息)</p>\n<h3 id=\"消息过滤\"><a href=\"#消息过滤\" class=\"headerlink\" title=\"消息过滤\"></a>消息过滤</h3><p>显而易见，broker在发布/订阅过程中扮演了重要的角色。那么,broker是如何管理所有的消息并在传输给某个订阅者消息时，只传递他感兴趣的话题下的消息呢?正如你所看到的，broker有一些过滤选项。</p>\n<blockquote>\n<p>选项一: 基于主题的过滤</p>\n</blockquote>\n<p>过滤的过程基于每条消息中的主题或话题。接收方客户端向broker订阅感兴趣的话题，从订阅之后开始，broker确保接收方客户端会收到所有被订阅主题下的消息。通常情况下，主题是一个有层次结构的字符串并借此结构可以实现基于有限数量表达式的过滤。</p>\n<blockquote>\n<p>选项二: 基于内容的过滤</p>\n</blockquote>\n<p>在基于内容的过滤中，broker基于内容中特殊的过滤语言来过滤消息。接收方客户端向broker订阅他感兴趣的查询条件。这个方法重大的缺点是消息内容必须提前知晓，而且不能被加密或有任何简单的变化。</p>\n<blockquote>\n<p>选项三: 基于类型的过滤</p>\n</blockquote>\n<p>在我们使用面向对象语言时，基于类型的过滤是一种常见的做法。例如，一个订阅者可以订阅所有”异常”类型的消息，或任何其他的子类型<br/><br>当然，发布/订阅模式并非适应于所有的情况。在使用这种模式之前，你需要考虑一些事情。对发布者和订阅者的解耦是发布/订阅模式的关键，这为我们带来了一些挑战。比如说，你需要提前明白被发布的消息是如何组织的。针对基于主题的过滤，发布者和订阅者双发都需要知道要使用哪一个话题。另一个需要注意的事情是消息交付。发布者不能认为被发出的消息有被任何一方所监听，在某些时候，一条消息不属于任何订阅者的情况是存在的。</p>\n<h3 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h3><p>现在我们来探索发布/订阅模式的一种实际应用——MQTT。正如你所想，MQTT体现了之前提到的发布/订阅模式所有特性:</p>\n<ul>\n<li>MQTT在空间上解耦了发布者和订阅者，为了发布或订阅消息，发布者和订阅者只需要知道broker的主机名/IP地址和端口</li>\n<li>MQTT实现了时间解耦。尽管MQTT通常会实时传递消息。但如果有需要，broker可以在客户端不在线时存储消息。(存储消息必须满足条件:客户端曾有一个持续会话，并且订阅话题时设置QoS级别大于0)</li>\n<li>MQTT使用异步的方式工作。因为大多数客户端类库基于回调或类似的模型用异步的方式工作。任务在等待消息或者发布消息时不会阻塞。在特定的情况下，需要同步模式去等待一个特定的消息，一些开发库有同步的API，但是工作流通常时异步的。</li>\n</ul>\n<p>MQTT另一个值得被提到的事是他在客户端一方非常易用。大多数发布/订阅模式系统相关的逻辑都在broker一方。当在运用MQTT客户端库时符合了发布/订阅模式的特性，并且让他成为一个适用于资源受限设备的轻量协议。<br/><br>MQTT使用基于主题的消息过滤。每条消息带有一个主题，所以broker可以用主题信息来决定将这个消息发向哪个订阅者。在第五篇文章中，我们会了解更多关于主题的内容。如果需要，你也可以使用HiveMQ和我们的自定义扩展系统建立一个基于内容过滤的MQTT broker。 <br/><br>为了解决发布/订阅系统带来的挑战，MQTT有三个服务质量(Quality of Service)级别。你可以简单的认为消息成功的发布到broker，或成功的从broker发出。然而，存在一种情况:没有一个订阅者订阅某个特定的话题。如果这会带来一些问题，broker必须知道该如何处理这种情况。例如，HiveMQ MQTT broker有一个插件系统可以处理这种情况。你可以让broker采取一些行为，或者简单的将每条消息打印到数据中方便查阅。为了保持话题树结构的灵活性，必须认真的设计话题树并且为未来可能的变化留有足够的空间。如果你遵循这些策略，MQTT是一个完美的协议帮助你搭建产品。</p>\n<h3 id=\"与消息队列的区别\"><a href=\"#与消息队列的区别\" class=\"headerlink\" title=\"与消息队列的区别\"></a>与消息队列的区别</h3><p>关于MQTT名称的由来和此协议是否有消息队列的实现有许多争议。我们将在这个主题上阐明一些观点，并说明MQTT和消息队列的区别。在我们上一篇文章中，我们提到MQTT中MQ是IBM的MQ系列产品，和消息队列无关。不管名字的来源具体是什么，有必要了解一些MQTT和传统消息队列的区别:</p>\n<ul>\n<li>消息队列存储着消息知道他们被消费。在你使用消息队列时，收到的每个消息都被存储在队列中，直到他们被客户端(通常被称为消费者)取走。如果没有消费者取走消息，那么消息会一直存储在队列中，直到被取走。在消息队列中，一条消息没有被任何客户端所处理就丢弃是不可能的。但是在MQTT中是可能的，例如没有客户端订阅某个话题时，发往该话题的消息将被丢弃。</li>\n<li>一条消息只被一个客户端处理。另一个巨大的区别是在传统的消息队列中，一条消息只能被一个消费者处理。所有消费者等待一个队列。 在MQTT中，行为是完全相反的，每一个订阅某个主题的订阅者都会获得消息。</li>\n<li>队列需要被命名而且需要被明确的创建。一个队列比话题更加死板。在一个队列可以使用之前，队列必须被另外的命令明确的创建，只有在被明确创建并命名后才可以用于生产和消费消息。相反，MQTT 话题更加灵活，可以被任意的创建。</li>\n</ul>\n<p>如果您可以想到任何其他的不同被我们忽略了，希望可以在评论中指出。 <br/><br>系列文章的第二篇结束了。下一周我们去仔细了解以下什么是MQTT客户端和broker还有他们是如何连接的。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part2-publish-subscribe/\">Publish &amp; Subscribe - MQTT Essentials: Part 2</a></p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到MQTT要点系列的第二版，分为十章的关于MQTT协议核心特点和概念的系列文章。在系列文章的第一章，我们介绍了MQTT并讨论了MQTT协议的来源和历史。如果你错过了第一章，你绝对应该看一看。 <br/><br>我们有一个关于发布订阅模式的视频在文章末尾来帮助你补充相关知识</p>\n<h3 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布/订阅模式\"></a>发布/订阅模式</h3><p>发布订阅/模式提供了一种传统客户端-服务器架构的替代品。在客户端-服务器模型中，客户端直接与端点通信。而发布/订阅模型将消息发送者和接收者解耦，发布消息的客户端被称为发布者，接收消息的客户端被称为订阅者。发布者和订阅者永远不会直接通信。事实上，他们甚至不知道对方的存在。他们之间的通信被第三方组件(the broker)处理。broker的工作是过滤所有到来的消息，然后将消息分发给正确的订阅者。接下来，让我们深入了解一下发布订阅的相关特性。<br><img src=\"/2021/11/10/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%8C-%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/mqtt-publish-subscribe.svg\"><br>发布订阅模式最重要的特性是消息发送者和接收者的解耦，这种解耦有几个方面</p>\n<ul>\n<li>空间解耦: 发布者和订阅者不需要知道对方(例如，不需要知道ip地址和端口)</li>\n<li>时间解耦: 发布者和订阅者不需要在同一时间运行</li>\n<li>同步解耦: 在两个组件上的操作在发布或接收消息时不需要被中断</li>\n</ul>\n<p>总的来说，发布/订阅模式移除了消息发布者和接收者的直接交流。通过broker的过滤可以控制订阅者接收到哪些消息。它在三方面解耦:空间、时间、同步性</p>\n<h3 id=\"可扩展性\"><a href=\"#可扩展性\" class=\"headerlink\" title=\"可扩展性\"></a>可扩展性</h3><p>发布\\订阅模式的可扩展性好于传统的客户端服务器架构。因为broker的操作有很高的并行性，而且消息可以以事件驱动的模式去处理。消息缓存和合理的路由选择通常是提高可扩展性的关键因素。尽管如此，拓展到百万级别的连接数仍然是一个挑战。这样高级别的连接数可以通过broker节点集群和负载均衡来解决(这个话题超过了这篇文章讲述的范围，我们在另外的文章中讲述相关的消息)</p>\n<h3 id=\"消息过滤\"><a href=\"#消息过滤\" class=\"headerlink\" title=\"消息过滤\"></a>消息过滤</h3><p>显而易见，broker在发布/订阅过程中扮演了重要的角色。那么,broker是如何管理所有的消息并在传输给某个订阅者消息时，只传递他感兴趣的话题下的消息呢?正如你所看到的，broker有一些过滤选项。</p>\n<blockquote>\n<p>选项一: 基于主题的过滤</p>\n</blockquote>\n<p>过滤的过程基于每条消息中的主题或话题。接收方客户端向broker订阅感兴趣的话题，从订阅之后开始，broker确保接收方客户端会收到所有被订阅主题下的消息。通常情况下，主题是一个有层次结构的字符串并借此结构可以实现基于有限数量表达式的过滤。</p>\n<blockquote>\n<p>选项二: 基于内容的过滤</p>\n</blockquote>\n<p>在基于内容的过滤中，broker基于内容中特殊的过滤语言来过滤消息。接收方客户端向broker订阅他感兴趣的查询条件。这个方法重大的缺点是消息内容必须提前知晓，而且不能被加密或有任何简单的变化。</p>\n<blockquote>\n<p>选项三: 基于类型的过滤</p>\n</blockquote>\n<p>在我们使用面向对象语言时，基于类型的过滤是一种常见的做法。例如，一个订阅者可以订阅所有”异常”类型的消息，或任何其他的子类型<br/><br>当然，发布/订阅模式并非适应于所有的情况。在使用这种模式之前，你需要考虑一些事情。对发布者和订阅者的解耦是发布/订阅模式的关键，这为我们带来了一些挑战。比如说，你需要提前明白被发布的消息是如何组织的。针对基于主题的过滤，发布者和订阅者双发都需要知道要使用哪一个话题。另一个需要注意的事情是消息交付。发布者不能认为被发出的消息有被任何一方所监听，在某些时候，一条消息不属于任何订阅者的情况是存在的。</p>\n<h3 id=\"MQTT\"><a href=\"#MQTT\" class=\"headerlink\" title=\"MQTT\"></a>MQTT</h3><p>现在我们来探索发布/订阅模式的一种实际应用——MQTT。正如你所想，MQTT体现了之前提到的发布/订阅模式所有特性:</p>\n<ul>\n<li>MQTT在空间上解耦了发布者和订阅者，为了发布或订阅消息，发布者和订阅者只需要知道broker的主机名/IP地址和端口</li>\n<li>MQTT实现了时间解耦。尽管MQTT通常会实时传递消息。但如果有需要，broker可以在客户端不在线时存储消息。(存储消息必须满足条件:客户端曾有一个持续会话，并且订阅话题时设置QoS级别大于0)</li>\n<li>MQTT使用异步的方式工作。因为大多数客户端类库基于回调或类似的模型用异步的方式工作。任务在等待消息或者发布消息时不会阻塞。在特定的情况下，需要同步模式去等待一个特定的消息，一些开发库有同步的API，但是工作流通常时异步的。</li>\n</ul>\n<p>MQTT另一个值得被提到的事是他在客户端一方非常易用。大多数发布/订阅模式系统相关的逻辑都在broker一方。当在运用MQTT客户端库时符合了发布/订阅模式的特性，并且让他成为一个适用于资源受限设备的轻量协议。<br/><br>MQTT使用基于主题的消息过滤。每条消息带有一个主题，所以broker可以用主题信息来决定将这个消息发向哪个订阅者。在第五篇文章中，我们会了解更多关于主题的内容。如果需要，你也可以使用HiveMQ和我们的自定义扩展系统建立一个基于内容过滤的MQTT broker。 <br/><br>为了解决发布/订阅系统带来的挑战，MQTT有三个服务质量(Quality of Service)级别。你可以简单的认为消息成功的发布到broker，或成功的从broker发出。然而，存在一种情况:没有一个订阅者订阅某个特定的话题。如果这会带来一些问题，broker必须知道该如何处理这种情况。例如，HiveMQ MQTT broker有一个插件系统可以处理这种情况。你可以让broker采取一些行为，或者简单的将每条消息打印到数据中方便查阅。为了保持话题树结构的灵活性，必须认真的设计话题树并且为未来可能的变化留有足够的空间。如果你遵循这些策略，MQTT是一个完美的协议帮助你搭建产品。</p>\n<h3 id=\"与消息队列的区别\"><a href=\"#与消息队列的区别\" class=\"headerlink\" title=\"与消息队列的区别\"></a>与消息队列的区别</h3><p>关于MQTT名称的由来和此协议是否有消息队列的实现有许多争议。我们将在这个主题上阐明一些观点，并说明MQTT和消息队列的区别。在我们上一篇文章中，我们提到MQTT中MQ是IBM的MQ系列产品，和消息队列无关。不管名字的来源具体是什么，有必要了解一些MQTT和传统消息队列的区别:</p>\n<ul>\n<li>消息队列存储着消息知道他们被消费。在你使用消息队列时，收到的每个消息都被存储在队列中，直到他们被客户端(通常被称为消费者)取走。如果没有消费者取走消息，那么消息会一直存储在队列中，直到被取走。在消息队列中，一条消息没有被任何客户端所处理就丢弃是不可能的。但是在MQTT中是可能的，例如没有客户端订阅某个话题时，发往该话题的消息将被丢弃。</li>\n<li>一条消息只被一个客户端处理。另一个巨大的区别是在传统的消息队列中，一条消息只能被一个消费者处理。所有消费者等待一个队列。 在MQTT中，行为是完全相反的，每一个订阅某个主题的订阅者都会获得消息。</li>\n<li>队列需要被命名而且需要被明确的创建。一个队列比话题更加死板。在一个队列可以使用之前，队列必须被另外的命令明确的创建，只有在被明确创建并命名后才可以用于生产和消费消息。相反，MQTT 话题更加灵活，可以被任意的创建。</li>\n</ul>\n<p>如果您可以想到任何其他的不同被我们忽略了，希望可以在评论中指出。 <br/><br>系列文章的第二篇结束了。下一周我们去仔细了解以下什么是MQTT客户端和broker还有他们是如何连接的。</p>"},{"title":"MQTT基础文档翻译(三):MQTT客户端和Broker和MQTT服务器和连接建立的解释","date":"2021-11-14T15:41:40.000Z","_content":"## 原文链接\n[MQTT Client and Broker and MQTT Server and Connection Establishment Explained - MQTT Essentials: Part 3](https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/)\n<!--more-->\n## 正文\n欢迎来到关于MQTT核心特性和概念系列文章的第三篇。在这篇文章中，我们将讨论MQTT客户端和broker的角色，连接MQTT服务器时的参数和选项，并解释MQTT服务器连接的建立。<br/>\n在文章的末尾，我们有一个视频来补充这篇文章，我们建议你阅读完文章之后观看视频获取补充内容。<br/>\n上周，我们解释了发布/订阅模式是如何工作的以及在MQTT中是如何应用这一模式的，下面是核心内容的回顾。\n\n- 发布/订阅模式解耦了消息发送方客户端即发布者和消息接收方客户端即订阅者。\n- MQTT使用消息中的话题(topic)信息来决定这条消息被发送给哪个订阅者。话题是一个有层次结构的字符串，可以用来过滤和路由消息。\n\n上篇文章我们从高级别的抽象介绍了发布/订阅模式还有发布/订阅模式与传统消息队列的区别。这篇文章我们将讲述一些更加贴近实际的内容: MQTT客户端和broker的定义，MQTT连接的基础，MQTT连接时的参数和通过broker的确认(Ack)来确立连接。\n\n### 简介\n因为MQTT解耦了发布者和订阅者，客户端连接通常被broker所处理，在我们了解连接的细节之前，我们需要先清楚客户端和broker的意义。\n\n- 客户端(Client)\n\n当我们谈论客户端，通常指的是MQTT客户端，包括发布者和订阅者。发布者和订阅者的区别在于客户端正在发布消息还是正在订阅一个主题，并接收消息。(发布和订阅可以同时实现在一个客户端中)。一个MQTT客户端可以是运行着MQTT库并且通过网络和一个MQTT broker连接的任意设备(从微型控制器到大型服务器)。例如，MQTT客户端可以是一个非常小的、资源受限的设备拥有一个最小的实现库，通过无线网连接broker。MQTT客户端也可以是一台有MQTT客户端图形界面用来测试的计算机。总之，通过在TCP/IP之上的MQTT进行数据交互的设备都可以称为MQTT客户端。客户端实现MQTT协议是非常容易的。由于易于实现的特性MQTT特别适合体积小的设备。MQTT客户端开发库有许多语言的版本，例如Android,Arduino,C,C++,C#,Go,iOS,Java,JavaScript,和.NET。你可以在MQTT维基上看到完整的列表。\n\n- Broker\n\nMQTT客户端对应的是MQTT broker。 broker是发布/订阅模式的核心。根据实现，broker可以同时处理百万以上的MQTT客户端。<br/>\nbroker的责任是接收全部消息，过滤消息，确定由谁订阅了某条消息，并将消息发送给订阅该话题的客户端。broker持有所有持续会话客户端的会话信息，包括订阅和错过的消息。broker的另一个责任是授权和认证客户端。\n通常，broker是可扩展的，这有助于定制授权、认证和集成到后端系统。因为broker通常是直接暴露到网络的模块、处理许多客户端、并且需要传递消息到下游的分析和处理系统所以集成是非常重要的。像上篇文章讨论的那样，订阅消息并不是唯一的选择。简而言之，broker是一个每个消息必须通过的消息枢纽。所以，它必须高度可扩展，易于集成到后端系统，易于监控，具有稳定性。HiveMQ通过使用先进的事件驱动网络、开放的扩展系统和提供标准监控来实现这些需求。\n### MQTT Connection\nMQTT是基于TCP/IP的，客户端和broker都需要拥有TCP/IP协议栈。\n![](mqtt-tcp-ip-stack.png)\nMQTT连接总是在客户端和broker之间，客户端之间不会直接连接。为了初始化一个连接，客户端发送CONNECT消息给broker。broker回复一个CONNACK消息和状态码。一旦连接被建立。broker会保持连接打开，直到客户端发送断开命令或者连接中断。\n![](connect-flow.gif)\n\n- MQTT通过NAT(network address translation)连接\n\n在许多实际情况中，MQTT客户端处于一个使用NAT的路由器之后。路由器会完成一个公有地址到私有地址(像192.168.x.x,10.0.x.x)的转换。正如我们之前提到的，MQTT客户端通过发送CONNECT消息来建立连接。broker有一个公网IP地址，并且在收到CONNECT消息之后，就有了与客户端双向通信的能力，所以即便客户端在一个NAT网络之后不会有什么问题。\n\n- 客户端通过CONNECT消息初始化连接\n\n现在我们来看一看MQTT的CONNECT消息。为了初始化连接，客户端发送一个命令消息给broker。如果这条消息格式是错误的，或者打开网络socket和发送连接消息之间花费了太多时间，broker会关闭这个连接。这样可以防止恶意的客户端降低broker的速度。一个正确的MQTT客户端会发送一个以下内容的消息:\n![](connect.png)\nCONNECT消息中包含的一些内容可能是面向MQTT库实现者而不是使用者的，更多细节，查看MQTT3.1.1规范。我们将关注以下几个选项。\n\n- ClientId\n\n客户端标识符用来区分连接到MQTT broker的每一个MQTT客户端。broker通过使用ClientId来验证客户端和客户端当前的状态。所以，这个id需要是唯一的。在MQTT 3.1.1中，你可以发送一个空的ClientId，如果你不需要broker记录状态。空的ClientId会使一个连接没有任何状态信息，在这种情况下，清空会话的标志必须被设置成true，否则broker会拒绝这个连接。\n\n- CleanSession\n\nCleanSession标志告诉broker客户端是否想要建立一个持久会话。当标志为假时建立持久会话，broker会存储客户端所有的订阅和所有客户端错过的服务质量为1或2的消息。当标志为真时建立非持久会话，broker不会为客户端存储任何信息，并且会删除之前持久会话的所有信息。\n\n- Username/Password\n\nMQTT可以通过发送用户名和密码来进行认证和授权。然而，如果这些信息没有被加密或者hash处理，密码会被明文传输，我们强烈建议用户名和密码通过安全的方式传输。HiveMQ可以通过SSL认证来鉴定客户端，所以不需要用户名和密码。\n\n- Will Message\n\nlast will 消息是MQTT Last Will 和 Testament 特性的一部分。这条消息会在客户端非正常关闭时通知其他客户端。当客户端连接上之后，它可以向broker的CONNECT消息中提供last will消息的话题和消息内容。如果客户端非正常关闭，broker会代替客户端发送LWT消息，你可以在系列文章的第九部分了解更多关于LWT的内容。\n\n- KeepAlive\n\nkeep alive 是一个以秒为单位的时间间隔，由客户端在连接建立时指定。这个时间间隔定义了broker和客户端可以忍受没有消息发送的最长时间间隔。 通常，客户端发送常规的PING消息，broker回复PING回复消息。这种方法允许两端都可以判断对方是否仍然在线。系列文章的第十章详细讲述了MQTT的keep alive功能。<br/>\n基本上，这是为了连接MQTT3.1.1客户端连接MQTT broker所需要的全部信息。不同的实现通常会有一些可以配置的附加选项。比如，在某些实现中可以设置存储消息的方法。\n\n- Broker response with a CONNACK message\n\n当broker收到一条CONNECT消息，他有义务回复一条CONNACK消息。<br />\nCONNACK消息包含两条内容:\n\n- Session Present flag\n\n会话状态标志告诉客户端broker是否已经有一个持久会话在与此客户端之前的沟通中建立。当客户端连接时设置Clean Session为真时，session persent flag总是被设置成false，因为这样不会有可用的会话。当客户端连接时设置Clean Session为假时，这里有两种可能，如果此clientId有可以用的会话信息，并且broker存储着会话信息，则session present flag被设为真。否则，如果broker没有任何这个clientId相关的会话信息，session present flag被设置为假。这个标志在MQTT3.1.1中被加入用来帮助客户端判断他们是需要订阅话题或者订阅信息已经被存储在持久会话相关信息中。\n\n- Connect return code\nCONNACK消息中第二个标志是连接确认标志，这个标志会包含一个结果码，会告诉客户端这次连接请求是否成功。\n![](connack1.png)\n\n返回码定义\n![](retcode.png)\n更多细节的定义请查阅MQTT文档。\n\n### 结语\n你可能想直到MQTT在没有消息发送的时候是如何保持连接的，或者如何知道连接已经失效。不要担心，我们会在后续的文章中讲述相关话题。<br\\>\nMQTT系列文章的第三篇文章结束了，希望文章中有可以帮到你的内容，下周我们将会发布关于发布、订阅、取消订阅相关内容的文章。\n","source":"_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释.md","raw":"---\ntitle: 'MQTT基础文档翻译(三):MQTT客户端和Broker和MQTT服务器和连接建立的解释'\ndate: 2021-11-14 23:41:40\ntags: MQTT\n---\n## 原文链接\n[MQTT Client and Broker and MQTT Server and Connection Establishment Explained - MQTT Essentials: Part 3](https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/)\n<!--more-->\n## 正文\n欢迎来到关于MQTT核心特性和概念系列文章的第三篇。在这篇文章中，我们将讨论MQTT客户端和broker的角色，连接MQTT服务器时的参数和选项，并解释MQTT服务器连接的建立。<br/>\n在文章的末尾，我们有一个视频来补充这篇文章，我们建议你阅读完文章之后观看视频获取补充内容。<br/>\n上周，我们解释了发布/订阅模式是如何工作的以及在MQTT中是如何应用这一模式的，下面是核心内容的回顾。\n\n- 发布/订阅模式解耦了消息发送方客户端即发布者和消息接收方客户端即订阅者。\n- MQTT使用消息中的话题(topic)信息来决定这条消息被发送给哪个订阅者。话题是一个有层次结构的字符串，可以用来过滤和路由消息。\n\n上篇文章我们从高级别的抽象介绍了发布/订阅模式还有发布/订阅模式与传统消息队列的区别。这篇文章我们将讲述一些更加贴近实际的内容: MQTT客户端和broker的定义，MQTT连接的基础，MQTT连接时的参数和通过broker的确认(Ack)来确立连接。\n\n### 简介\n因为MQTT解耦了发布者和订阅者，客户端连接通常被broker所处理，在我们了解连接的细节之前，我们需要先清楚客户端和broker的意义。\n\n- 客户端(Client)\n\n当我们谈论客户端，通常指的是MQTT客户端，包括发布者和订阅者。发布者和订阅者的区别在于客户端正在发布消息还是正在订阅一个主题，并接收消息。(发布和订阅可以同时实现在一个客户端中)。一个MQTT客户端可以是运行着MQTT库并且通过网络和一个MQTT broker连接的任意设备(从微型控制器到大型服务器)。例如，MQTT客户端可以是一个非常小的、资源受限的设备拥有一个最小的实现库，通过无线网连接broker。MQTT客户端也可以是一台有MQTT客户端图形界面用来测试的计算机。总之，通过在TCP/IP之上的MQTT进行数据交互的设备都可以称为MQTT客户端。客户端实现MQTT协议是非常容易的。由于易于实现的特性MQTT特别适合体积小的设备。MQTT客户端开发库有许多语言的版本，例如Android,Arduino,C,C++,C#,Go,iOS,Java,JavaScript,和.NET。你可以在MQTT维基上看到完整的列表。\n\n- Broker\n\nMQTT客户端对应的是MQTT broker。 broker是发布/订阅模式的核心。根据实现，broker可以同时处理百万以上的MQTT客户端。<br/>\nbroker的责任是接收全部消息，过滤消息，确定由谁订阅了某条消息，并将消息发送给订阅该话题的客户端。broker持有所有持续会话客户端的会话信息，包括订阅和错过的消息。broker的另一个责任是授权和认证客户端。\n通常，broker是可扩展的，这有助于定制授权、认证和集成到后端系统。因为broker通常是直接暴露到网络的模块、处理许多客户端、并且需要传递消息到下游的分析和处理系统所以集成是非常重要的。像上篇文章讨论的那样，订阅消息并不是唯一的选择。简而言之，broker是一个每个消息必须通过的消息枢纽。所以，它必须高度可扩展，易于集成到后端系统，易于监控，具有稳定性。HiveMQ通过使用先进的事件驱动网络、开放的扩展系统和提供标准监控来实现这些需求。\n### MQTT Connection\nMQTT是基于TCP/IP的，客户端和broker都需要拥有TCP/IP协议栈。\n![](mqtt-tcp-ip-stack.png)\nMQTT连接总是在客户端和broker之间，客户端之间不会直接连接。为了初始化一个连接，客户端发送CONNECT消息给broker。broker回复一个CONNACK消息和状态码。一旦连接被建立。broker会保持连接打开，直到客户端发送断开命令或者连接中断。\n![](connect-flow.gif)\n\n- MQTT通过NAT(network address translation)连接\n\n在许多实际情况中，MQTT客户端处于一个使用NAT的路由器之后。路由器会完成一个公有地址到私有地址(像192.168.x.x,10.0.x.x)的转换。正如我们之前提到的，MQTT客户端通过发送CONNECT消息来建立连接。broker有一个公网IP地址，并且在收到CONNECT消息之后，就有了与客户端双向通信的能力，所以即便客户端在一个NAT网络之后不会有什么问题。\n\n- 客户端通过CONNECT消息初始化连接\n\n现在我们来看一看MQTT的CONNECT消息。为了初始化连接，客户端发送一个命令消息给broker。如果这条消息格式是错误的，或者打开网络socket和发送连接消息之间花费了太多时间，broker会关闭这个连接。这样可以防止恶意的客户端降低broker的速度。一个正确的MQTT客户端会发送一个以下内容的消息:\n![](connect.png)\nCONNECT消息中包含的一些内容可能是面向MQTT库实现者而不是使用者的，更多细节，查看MQTT3.1.1规范。我们将关注以下几个选项。\n\n- ClientId\n\n客户端标识符用来区分连接到MQTT broker的每一个MQTT客户端。broker通过使用ClientId来验证客户端和客户端当前的状态。所以，这个id需要是唯一的。在MQTT 3.1.1中，你可以发送一个空的ClientId，如果你不需要broker记录状态。空的ClientId会使一个连接没有任何状态信息，在这种情况下，清空会话的标志必须被设置成true，否则broker会拒绝这个连接。\n\n- CleanSession\n\nCleanSession标志告诉broker客户端是否想要建立一个持久会话。当标志为假时建立持久会话，broker会存储客户端所有的订阅和所有客户端错过的服务质量为1或2的消息。当标志为真时建立非持久会话，broker不会为客户端存储任何信息，并且会删除之前持久会话的所有信息。\n\n- Username/Password\n\nMQTT可以通过发送用户名和密码来进行认证和授权。然而，如果这些信息没有被加密或者hash处理，密码会被明文传输，我们强烈建议用户名和密码通过安全的方式传输。HiveMQ可以通过SSL认证来鉴定客户端，所以不需要用户名和密码。\n\n- Will Message\n\nlast will 消息是MQTT Last Will 和 Testament 特性的一部分。这条消息会在客户端非正常关闭时通知其他客户端。当客户端连接上之后，它可以向broker的CONNECT消息中提供last will消息的话题和消息内容。如果客户端非正常关闭，broker会代替客户端发送LWT消息，你可以在系列文章的第九部分了解更多关于LWT的内容。\n\n- KeepAlive\n\nkeep alive 是一个以秒为单位的时间间隔，由客户端在连接建立时指定。这个时间间隔定义了broker和客户端可以忍受没有消息发送的最长时间间隔。 通常，客户端发送常规的PING消息，broker回复PING回复消息。这种方法允许两端都可以判断对方是否仍然在线。系列文章的第十章详细讲述了MQTT的keep alive功能。<br/>\n基本上，这是为了连接MQTT3.1.1客户端连接MQTT broker所需要的全部信息。不同的实现通常会有一些可以配置的附加选项。比如，在某些实现中可以设置存储消息的方法。\n\n- Broker response with a CONNACK message\n\n当broker收到一条CONNECT消息，他有义务回复一条CONNACK消息。<br />\nCONNACK消息包含两条内容:\n\n- Session Present flag\n\n会话状态标志告诉客户端broker是否已经有一个持久会话在与此客户端之前的沟通中建立。当客户端连接时设置Clean Session为真时，session persent flag总是被设置成false，因为这样不会有可用的会话。当客户端连接时设置Clean Session为假时，这里有两种可能，如果此clientId有可以用的会话信息，并且broker存储着会话信息，则session present flag被设为真。否则，如果broker没有任何这个clientId相关的会话信息，session present flag被设置为假。这个标志在MQTT3.1.1中被加入用来帮助客户端判断他们是需要订阅话题或者订阅信息已经被存储在持久会话相关信息中。\n\n- Connect return code\nCONNACK消息中第二个标志是连接确认标志，这个标志会包含一个结果码，会告诉客户端这次连接请求是否成功。\n![](connack1.png)\n\n返回码定义\n![](retcode.png)\n更多细节的定义请查阅MQTT文档。\n\n### 结语\n你可能想直到MQTT在没有消息发送的时候是如何保持连接的，或者如何知道连接已经失效。不要担心，我们会在后续的文章中讲述相关话题。<br\\>\nMQTT系列文章的第三篇文章结束了，希望文章中有可以帮到你的内容，下周我们将会发布关于发布、订阅、取消订阅相关内容的文章。\n","slug":"MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释","published":1,"updated":"2021-12-01T16:02:38.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0b4dtq90004vsvi89p18g8s","content":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/\">MQTT Client and Broker and MQTT Server and Connection Establishment Explained - MQTT Essentials: Part 3</a></p>\n<span id=\"more\"></span>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到关于MQTT核心特性和概念系列文章的第三篇。在这篇文章中，我们将讨论MQTT客户端和broker的角色，连接MQTT服务器时的参数和选项，并解释MQTT服务器连接的建立。<br/><br>在文章的末尾，我们有一个视频来补充这篇文章，我们建议你阅读完文章之后观看视频获取补充内容。<br/><br>上周，我们解释了发布/订阅模式是如何工作的以及在MQTT中是如何应用这一模式的，下面是核心内容的回顾。</p>\n<ul>\n<li>发布/订阅模式解耦了消息发送方客户端即发布者和消息接收方客户端即订阅者。</li>\n<li>MQTT使用消息中的话题(topic)信息来决定这条消息被发送给哪个订阅者。话题是一个有层次结构的字符串，可以用来过滤和路由消息。</li>\n</ul>\n<p>上篇文章我们从高级别的抽象介绍了发布/订阅模式还有发布/订阅模式与传统消息队列的区别。这篇文章我们将讲述一些更加贴近实际的内容: MQTT客户端和broker的定义，MQTT连接的基础，MQTT连接时的参数和通过broker的确认(Ack)来确立连接。</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>因为MQTT解耦了发布者和订阅者，客户端连接通常被broker所处理，在我们了解连接的细节之前，我们需要先清楚客户端和broker的意义。</p>\n<ul>\n<li>客户端(Client)</li>\n</ul>\n<p>当我们谈论客户端，通常指的是MQTT客户端，包括发布者和订阅者。发布者和订阅者的区别在于客户端正在发布消息还是正在订阅一个主题，并接收消息。(发布和订阅可以同时实现在一个客户端中)。一个MQTT客户端可以是运行着MQTT库并且通过网络和一个MQTT broker连接的任意设备(从微型控制器到大型服务器)。例如，MQTT客户端可以是一个非常小的、资源受限的设备拥有一个最小的实现库，通过无线网连接broker。MQTT客户端也可以是一台有MQTT客户端图形界面用来测试的计算机。总之，通过在TCP/IP之上的MQTT进行数据交互的设备都可以称为MQTT客户端。客户端实现MQTT协议是非常容易的。由于易于实现的特性MQTT特别适合体积小的设备。MQTT客户端开发库有许多语言的版本，例如Android,Arduino,C,C++,C#,Go,iOS,Java,JavaScript,和.NET。你可以在MQTT维基上看到完整的列表。</p>\n<ul>\n<li>Broker</li>\n</ul>\n<p>MQTT客户端对应的是MQTT broker。 broker是发布/订阅模式的核心。根据实现，broker可以同时处理百万以上的MQTT客户端。<br/><br>broker的责任是接收全部消息，过滤消息，确定由谁订阅了某条消息，并将消息发送给订阅该话题的客户端。broker持有所有持续会话客户端的会话信息，包括订阅和错过的消息。broker的另一个责任是授权和认证客户端。<br>通常，broker是可扩展的，这有助于定制授权、认证和集成到后端系统。因为broker通常是直接暴露到网络的模块、处理许多客户端、并且需要传递消息到下游的分析和处理系统所以集成是非常重要的。像上篇文章讨论的那样，订阅消息并不是唯一的选择。简而言之，broker是一个每个消息必须通过的消息枢纽。所以，它必须高度可扩展，易于集成到后端系统，易于监控，具有稳定性。HiveMQ通过使用先进的事件驱动网络、开放的扩展系统和提供标准监控来实现这些需求。</p>\n<h3 id=\"MQTT-Connection\"><a href=\"#MQTT-Connection\" class=\"headerlink\" title=\"MQTT Connection\"></a>MQTT Connection</h3><p>MQTT是基于TCP/IP的，客户端和broker都需要拥有TCP/IP协议栈。<br><img src= \"/img/loading.gif\" data-src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/mqtt-tcp-ip-stack.png\"><br>MQTT连接总是在客户端和broker之间，客户端之间不会直接连接。为了初始化一个连接，客户端发送CONNECT消息给broker。broker回复一个CONNACK消息和状态码。一旦连接被建立。broker会保持连接打开，直到客户端发送断开命令或者连接中断。<br><img src= \"/img/loading.gif\" data-src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/connect-flow.gif\"></p>\n<ul>\n<li>MQTT通过NAT(network address translation)连接</li>\n</ul>\n<p>在许多实际情况中，MQTT客户端处于一个使用NAT的路由器之后。路由器会完成一个公有地址到私有地址(像192.168.x.x,10.0.x.x)的转换。正如我们之前提到的，MQTT客户端通过发送CONNECT消息来建立连接。broker有一个公网IP地址，并且在收到CONNECT消息之后，就有了与客户端双向通信的能力，所以即便客户端在一个NAT网络之后不会有什么问题。</p>\n<ul>\n<li>客户端通过CONNECT消息初始化连接</li>\n</ul>\n<p>现在我们来看一看MQTT的CONNECT消息。为了初始化连接，客户端发送一个命令消息给broker。如果这条消息格式是错误的，或者打开网络socket和发送连接消息之间花费了太多时间，broker会关闭这个连接。这样可以防止恶意的客户端降低broker的速度。一个正确的MQTT客户端会发送一个以下内容的消息:<br><img src= \"/img/loading.gif\" data-src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/connect.png\"><br>CONNECT消息中包含的一些内容可能是面向MQTT库实现者而不是使用者的，更多细节，查看MQTT3.1.1规范。我们将关注以下几个选项。</p>\n<ul>\n<li>ClientId</li>\n</ul>\n<p>客户端标识符用来区分连接到MQTT broker的每一个MQTT客户端。broker通过使用ClientId来验证客户端和客户端当前的状态。所以，这个id需要是唯一的。在MQTT 3.1.1中，你可以发送一个空的ClientId，如果你不需要broker记录状态。空的ClientId会使一个连接没有任何状态信息，在这种情况下，清空会话的标志必须被设置成true，否则broker会拒绝这个连接。</p>\n<ul>\n<li>CleanSession</li>\n</ul>\n<p>CleanSession标志告诉broker客户端是否想要建立一个持久会话。当标志为假时建立持久会话，broker会存储客户端所有的订阅和所有客户端错过的服务质量为1或2的消息。当标志为真时建立非持久会话，broker不会为客户端存储任何信息，并且会删除之前持久会话的所有信息。</p>\n<ul>\n<li>Username/Password</li>\n</ul>\n<p>MQTT可以通过发送用户名和密码来进行认证和授权。然而，如果这些信息没有被加密或者hash处理，密码会被明文传输，我们强烈建议用户名和密码通过安全的方式传输。HiveMQ可以通过SSL认证来鉴定客户端，所以不需要用户名和密码。</p>\n<ul>\n<li>Will Message</li>\n</ul>\n<p>last will 消息是MQTT Last Will 和 Testament 特性的一部分。这条消息会在客户端非正常关闭时通知其他客户端。当客户端连接上之后，它可以向broker的CONNECT消息中提供last will消息的话题和消息内容。如果客户端非正常关闭，broker会代替客户端发送LWT消息，你可以在系列文章的第九部分了解更多关于LWT的内容。</p>\n<ul>\n<li>KeepAlive</li>\n</ul>\n<p>keep alive 是一个以秒为单位的时间间隔，由客户端在连接建立时指定。这个时间间隔定义了broker和客户端可以忍受没有消息发送的最长时间间隔。 通常，客户端发送常规的PING消息，broker回复PING回复消息。这种方法允许两端都可以判断对方是否仍然在线。系列文章的第十章详细讲述了MQTT的keep alive功能。<br/><br>基本上，这是为了连接MQTT3.1.1客户端连接MQTT broker所需要的全部信息。不同的实现通常会有一些可以配置的附加选项。比如，在某些实现中可以设置存储消息的方法。</p>\n<ul>\n<li>Broker response with a CONNACK message</li>\n</ul>\n<p>当broker收到一条CONNECT消息，他有义务回复一条CONNACK消息。<br /><br>CONNACK消息包含两条内容:</p>\n<ul>\n<li>Session Present flag</li>\n</ul>\n<p>会话状态标志告诉客户端broker是否已经有一个持久会话在与此客户端之前的沟通中建立。当客户端连接时设置Clean Session为真时，session persent flag总是被设置成false，因为这样不会有可用的会话。当客户端连接时设置Clean Session为假时，这里有两种可能，如果此clientId有可以用的会话信息，并且broker存储着会话信息，则session present flag被设为真。否则，如果broker没有任何这个clientId相关的会话信息，session present flag被设置为假。这个标志在MQTT3.1.1中被加入用来帮助客户端判断他们是需要订阅话题或者订阅信息已经被存储在持久会话相关信息中。</p>\n<ul>\n<li>Connect return code<br>CONNACK消息中第二个标志是连接确认标志，这个标志会包含一个结果码，会告诉客户端这次连接请求是否成功。<br><img src= \"/img/loading.gif\" data-src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/connack1.png\"></li>\n</ul>\n<p>返回码定义<br><img src= \"/img/loading.gif\" data-src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/retcode.png\"><br>更多细节的定义请查阅MQTT文档。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>你可能想直到MQTT在没有消息发送的时候是如何保持连接的，或者如何知道连接已经失效。不要担心，我们会在后续的文章中讲述相关话题。&lt;br&gt;<br>MQTT系列文章的第三篇文章结束了，希望文章中有可以帮到你的内容，下周我们将会发布关于发布、订阅、取消订阅相关内容的文章。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-3-client-broker-connection-establishment/\">MQTT Client and Broker and MQTT Server and Connection Establishment Explained - MQTT Essentials: Part 3</a></p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到关于MQTT核心特性和概念系列文章的第三篇。在这篇文章中，我们将讨论MQTT客户端和broker的角色，连接MQTT服务器时的参数和选项，并解释MQTT服务器连接的建立。<br/><br>在文章的末尾，我们有一个视频来补充这篇文章，我们建议你阅读完文章之后观看视频获取补充内容。<br/><br>上周，我们解释了发布/订阅模式是如何工作的以及在MQTT中是如何应用这一模式的，下面是核心内容的回顾。</p>\n<ul>\n<li>发布/订阅模式解耦了消息发送方客户端即发布者和消息接收方客户端即订阅者。</li>\n<li>MQTT使用消息中的话题(topic)信息来决定这条消息被发送给哪个订阅者。话题是一个有层次结构的字符串，可以用来过滤和路由消息。</li>\n</ul>\n<p>上篇文章我们从高级别的抽象介绍了发布/订阅模式还有发布/订阅模式与传统消息队列的区别。这篇文章我们将讲述一些更加贴近实际的内容: MQTT客户端和broker的定义，MQTT连接的基础，MQTT连接时的参数和通过broker的确认(Ack)来确立连接。</p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>因为MQTT解耦了发布者和订阅者，客户端连接通常被broker所处理，在我们了解连接的细节之前，我们需要先清楚客户端和broker的意义。</p>\n<ul>\n<li>客户端(Client)</li>\n</ul>\n<p>当我们谈论客户端，通常指的是MQTT客户端，包括发布者和订阅者。发布者和订阅者的区别在于客户端正在发布消息还是正在订阅一个主题，并接收消息。(发布和订阅可以同时实现在一个客户端中)。一个MQTT客户端可以是运行着MQTT库并且通过网络和一个MQTT broker连接的任意设备(从微型控制器到大型服务器)。例如，MQTT客户端可以是一个非常小的、资源受限的设备拥有一个最小的实现库，通过无线网连接broker。MQTT客户端也可以是一台有MQTT客户端图形界面用来测试的计算机。总之，通过在TCP/IP之上的MQTT进行数据交互的设备都可以称为MQTT客户端。客户端实现MQTT协议是非常容易的。由于易于实现的特性MQTT特别适合体积小的设备。MQTT客户端开发库有许多语言的版本，例如Android,Arduino,C,C++,C#,Go,iOS,Java,JavaScript,和.NET。你可以在MQTT维基上看到完整的列表。</p>\n<ul>\n<li>Broker</li>\n</ul>\n<p>MQTT客户端对应的是MQTT broker。 broker是发布/订阅模式的核心。根据实现，broker可以同时处理百万以上的MQTT客户端。<br/><br>broker的责任是接收全部消息，过滤消息，确定由谁订阅了某条消息，并将消息发送给订阅该话题的客户端。broker持有所有持续会话客户端的会话信息，包括订阅和错过的消息。broker的另一个责任是授权和认证客户端。<br>通常，broker是可扩展的，这有助于定制授权、认证和集成到后端系统。因为broker通常是直接暴露到网络的模块、处理许多客户端、并且需要传递消息到下游的分析和处理系统所以集成是非常重要的。像上篇文章讨论的那样，订阅消息并不是唯一的选择。简而言之，broker是一个每个消息必须通过的消息枢纽。所以，它必须高度可扩展，易于集成到后端系统，易于监控，具有稳定性。HiveMQ通过使用先进的事件驱动网络、开放的扩展系统和提供标准监控来实现这些需求。</p>\n<h3 id=\"MQTT-Connection\"><a href=\"#MQTT-Connection\" class=\"headerlink\" title=\"MQTT Connection\"></a>MQTT Connection</h3><p>MQTT是基于TCP/IP的，客户端和broker都需要拥有TCP/IP协议栈。<br><img src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/mqtt-tcp-ip-stack.png\"><br>MQTT连接总是在客户端和broker之间，客户端之间不会直接连接。为了初始化一个连接，客户端发送CONNECT消息给broker。broker回复一个CONNACK消息和状态码。一旦连接被建立。broker会保持连接打开，直到客户端发送断开命令或者连接中断。<br><img src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/connect-flow.gif\"></p>\n<ul>\n<li>MQTT通过NAT(network address translation)连接</li>\n</ul>\n<p>在许多实际情况中，MQTT客户端处于一个使用NAT的路由器之后。路由器会完成一个公有地址到私有地址(像192.168.x.x,10.0.x.x)的转换。正如我们之前提到的，MQTT客户端通过发送CONNECT消息来建立连接。broker有一个公网IP地址，并且在收到CONNECT消息之后，就有了与客户端双向通信的能力，所以即便客户端在一个NAT网络之后不会有什么问题。</p>\n<ul>\n<li>客户端通过CONNECT消息初始化连接</li>\n</ul>\n<p>现在我们来看一看MQTT的CONNECT消息。为了初始化连接，客户端发送一个命令消息给broker。如果这条消息格式是错误的，或者打开网络socket和发送连接消息之间花费了太多时间，broker会关闭这个连接。这样可以防止恶意的客户端降低broker的速度。一个正确的MQTT客户端会发送一个以下内容的消息:<br><img src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/connect.png\"><br>CONNECT消息中包含的一些内容可能是面向MQTT库实现者而不是使用者的，更多细节，查看MQTT3.1.1规范。我们将关注以下几个选项。</p>\n<ul>\n<li>ClientId</li>\n</ul>\n<p>客户端标识符用来区分连接到MQTT broker的每一个MQTT客户端。broker通过使用ClientId来验证客户端和客户端当前的状态。所以，这个id需要是唯一的。在MQTT 3.1.1中，你可以发送一个空的ClientId，如果你不需要broker记录状态。空的ClientId会使一个连接没有任何状态信息，在这种情况下，清空会话的标志必须被设置成true，否则broker会拒绝这个连接。</p>\n<ul>\n<li>CleanSession</li>\n</ul>\n<p>CleanSession标志告诉broker客户端是否想要建立一个持久会话。当标志为假时建立持久会话，broker会存储客户端所有的订阅和所有客户端错过的服务质量为1或2的消息。当标志为真时建立非持久会话，broker不会为客户端存储任何信息，并且会删除之前持久会话的所有信息。</p>\n<ul>\n<li>Username/Password</li>\n</ul>\n<p>MQTT可以通过发送用户名和密码来进行认证和授权。然而，如果这些信息没有被加密或者hash处理，密码会被明文传输，我们强烈建议用户名和密码通过安全的方式传输。HiveMQ可以通过SSL认证来鉴定客户端，所以不需要用户名和密码。</p>\n<ul>\n<li>Will Message</li>\n</ul>\n<p>last will 消息是MQTT Last Will 和 Testament 特性的一部分。这条消息会在客户端非正常关闭时通知其他客户端。当客户端连接上之后，它可以向broker的CONNECT消息中提供last will消息的话题和消息内容。如果客户端非正常关闭，broker会代替客户端发送LWT消息，你可以在系列文章的第九部分了解更多关于LWT的内容。</p>\n<ul>\n<li>KeepAlive</li>\n</ul>\n<p>keep alive 是一个以秒为单位的时间间隔，由客户端在连接建立时指定。这个时间间隔定义了broker和客户端可以忍受没有消息发送的最长时间间隔。 通常，客户端发送常规的PING消息，broker回复PING回复消息。这种方法允许两端都可以判断对方是否仍然在线。系列文章的第十章详细讲述了MQTT的keep alive功能。<br/><br>基本上，这是为了连接MQTT3.1.1客户端连接MQTT broker所需要的全部信息。不同的实现通常会有一些可以配置的附加选项。比如，在某些实现中可以设置存储消息的方法。</p>\n<ul>\n<li>Broker response with a CONNACK message</li>\n</ul>\n<p>当broker收到一条CONNECT消息，他有义务回复一条CONNACK消息。<br /><br>CONNACK消息包含两条内容:</p>\n<ul>\n<li>Session Present flag</li>\n</ul>\n<p>会话状态标志告诉客户端broker是否已经有一个持久会话在与此客户端之前的沟通中建立。当客户端连接时设置Clean Session为真时，session persent flag总是被设置成false，因为这样不会有可用的会话。当客户端连接时设置Clean Session为假时，这里有两种可能，如果此clientId有可以用的会话信息，并且broker存储着会话信息，则session present flag被设为真。否则，如果broker没有任何这个clientId相关的会话信息，session present flag被设置为假。这个标志在MQTT3.1.1中被加入用来帮助客户端判断他们是需要订阅话题或者订阅信息已经被存储在持久会话相关信息中。</p>\n<ul>\n<li>Connect return code<br>CONNACK消息中第二个标志是连接确认标志，这个标志会包含一个结果码，会告诉客户端这次连接请求是否成功。<br><img src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/connack1.png\"></li>\n</ul>\n<p>返回码定义<br><img src=\"/2021/11/14/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%B8%89-MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8CBroker%E5%92%8CMQTT%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%A7%A3%E9%87%8A/retcode.png\"><br>更多细节的定义请查阅MQTT文档。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>你可能想直到MQTT在没有消息发送的时候是如何保持连接的，或者如何知道连接已经失效。不要担心，我们会在后续的文章中讲述相关话题。&lt;br&gt;<br>MQTT系列文章的第三篇文章结束了，希望文章中有可以帮到你的内容，下周我们将会发布关于发布、订阅、取消订阅相关内容的文章。</p>"},{"title":"MQTT基础文档翻译(五):话题和相关的实践","date":"2022-03-01T16:06:43.000Z","_content":"## 原文链接\n[MQTT Topics & Best Practices - MQTT Essentials: Part 5](https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-Topics-best-practices/)<!--more-->\n## 正文\n欢迎来到关于MQTT核心特性和概念系列文章的第五篇。在这篇文章中，我们将专注于MQTT的Topic和相关的最佳实践。正如我们之前提到的，MQTT的broker通过消息中的Topic信息来决定哪一个客户端将收到消息。我们还将看到一些特殊的系统Topic，这些Topic代表了一些关于broker状态的Topic。\n\n### Topic\n在MQTT中，Topic代表一个被broker用来为每个已连接的客户端筛选消息的UTF-8字符串。Topic由一级或多级组成。每一级之间通过正斜杠来划分。\n![](topic_basics.png)\n\n和消息队列相比，MQTTTopic是非常轻量的。客户端在发布或订阅一条消息之前，不需要提前创建一个Topic。broker会在没有任何初始化的情况下接受所有正确的Topic。<br/>\n这里有一些Topic的例子:\n```\nmyhome/groundfloor/livingroom/temperature\nUSA/California/San Francisco/Silicon Valley\n5ff4a2ce-e485-40f4-826c-b1a5d81be9b6/status\nGermany/Bavaria/car/2382340923453/latitude\n```\n注意，每个Topic必须含有至少一个字符，并且Topic字符串允许空字符串。 Topic 是大小写敏感的。例如 myhome/temperature 和 MyHome/Temperature 是两个不同的Topic。另外，单一的正斜杠是一个合法的Topic。\n\n### 通配符\n当一个客户端订阅一个Topic，它可以精确的订阅一个Topic，也可以通过通配符同时订阅多个Topic。通配符只可以被用于订阅Topic，不可以用于发布消息。这里有两种不同的通配符:单层和多层。\n\n#### 单层通配符: +\n正如名字所表示的含义，一个单层通配符可以替换一级Topic。在Topic的字符串中，加号代表着一个单层通配符。\n![](topic_wildcard_plus.png)\n\n当Topic的某一级为通配符时，在这一级有任何字符串都可以被匹配。例如 一条形如 myhome/groundfloor/+/temperature 的订阅消息对一下的Topic会产生不同的结果:\n![](topic_wildcard_plus_example.png)\n\n#### 多层通配符: #\n多层通配符可以覆盖Topic中多层字符，'#'符号在Topic字符串中代表一个多层通配符。为了让broker可以确定哪些Topic可以被匹配，多层通配符必须是Topic字符串的字符，并且倒数第二个字符为正斜杠。\n![](topic_wildcard_hash.png)\n\n当一个客户端使用多层通配符订阅Topic，它将会收到以通配符之前字符串开头的所有消息，不管这条消息有多长。如果你只把 '#' 符号作为一条Topic。你会收到所有发往MQTT broker的消息。如果你想要高吞吐量，就不应该只使用一个'#'作为Topic。\n\n### 以 '$' 符号开头的话题\n一般来说，你可以给MQTT Topic任意的名字。但是，这有一个例外， 以'\\$'符号开头的Topic被borker保留用来做内部的计数。客户端不可以给这些话题推送消息。同时，这些Topic没有被官方标准化。通常 \\$SYS/ 被用于代表以下消息，但不同的实现可以能有不同的意义。 [MQTT GitHub Wiki](https://github.com/mqtt/mqtt.org/wiki/SYS-Topics)中有\\$SYS 相关Topic的建议。这里有一些例子:\n\n```\n$SYS/broker/clients/connected\n$SYS/broker/clients/disconnected\n$SYS/broker/clients/total\n$SYS/broker/messages/sent\n$SYS/broker/uptime\n```\n### 总结\n上述是一些关于MQTT消息的基础知识。如你所见，MQTT Topic是动态并且具有灵活性的。当你在真实的程序中使用通配符时，有一些挑战需要你留心。下面我们会讲一些从很多MQTT项目的实践中总结出的一些MQTT Topic相关的最佳实践，你有任何想法都可以和我们讨论。\n\n## 最佳实践\n- 不要使用正斜杠作为Topic的首字符 \n正斜杠作为Topic首字符在MQTT中是被允许的，例如, /myhome/groundfloor/livingroom. 然而，前导正斜杠带来了一个没有任何字符的多余层级，这没有带来任何好处并且容易产生误解。\n- 不要在Topic中使用空格\n空格是所有程序员的敌人。当事情没有按预期发生时，Topic中的空格会加大查找问题的代价。和前导正斜杠一样，一些行为被允许不代表它是对的。UTF-8有许多中不同类型的空格，实践中应该避免这样不统一的字符。\n- 保持Topic的精简\n每个Topic将被所有关于它的消息携带，所以应该尽可能的让Topics变得精简。在一些小型设备上，每一个字节都有很大的影响。\n- 只使用ASCII字符，避免使用不可打印的字符\n因为非 ASCII的 UTF-8字符经常不可以正常显示。所以如果不是迫不得已，我们建议避免在Topic中使用任何的非ASCII字符。\n- 将唯一ID或客户端ID加入到Topic中\n将唯一ID或客户端ID加入到Topic中是非常有帮助的，这可以帮助你明确是哪个客户端发出的消息。Topic内置ID可以用来控制权限。只有当一个客户端和Topic拥有相同ID时才被允许向Topic发布消息。例如，一个客户端的ID为 'clent1',它可以向client1/status发布消息。但不可以向 client2/status 发布消息。\n- 不要订阅 '#'\n在有些场景中，我们必须订阅通过broker的所有消息。例如，将所有消息持久化到数据库。不要通过使用一个客户端订阅 '#' Topic的方式来获取所有消息。一般来说，一个客户端很难承担所有消息的负载(特别是消息吞吐量大时)。\n我们推荐给MQTT broker实现一个插件。例如，使用plugin system of HiveMQ 你可以给broker添加一个钩子，异步的将所有消息存入数据库。\n- 不要忘记可扩展性\nTopics 是一个灵活的概念，并且在任何情况下都不需要提前配置它。然而，发布者和订阅者都必须知道用来通信的Topic。思考如何设计Topic可以有助于为项目添加新特性是非常重要的。例如，为智能家居添加新的传感器时，尽量将他们添加到Topic树的一部分，而不是修改整个Topic的结构。\n- 使用特定的话题\n当你给一个Topic命名时，不要使用给队列命名时相同的习惯。尽量使不同的Topic之间便于区分。例如，如果你有三个传感器在卧室中，创建这样的三个Topic:\n```\nmyhome/livingroom/temperature\nmyhome/livingroom/brightness\nmyhome/livingroom/humidity. \n```\n不要通过 myhome/livingroom发送所有消息。使用特定的消息有助于使用其他MQTT的特性，例如 retained messages;\n\n## 结语\nMQTT系列文章的第五篇文章结束了，下一章我们将主要讲解服务质量(Quality of Service)相关的内容。","source":"_posts/MQTT基础文档翻译-五-话题和相关的实践.md","raw":"---\ntitle: 'MQTT基础文档翻译(五):话题和相关的实践'\ndate: 2022-03-02 00:06:43\ntags: MQTT\n---\n## 原文链接\n[MQTT Topics & Best Practices - MQTT Essentials: Part 5](https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-Topics-best-practices/)<!--more-->\n## 正文\n欢迎来到关于MQTT核心特性和概念系列文章的第五篇。在这篇文章中，我们将专注于MQTT的Topic和相关的最佳实践。正如我们之前提到的，MQTT的broker通过消息中的Topic信息来决定哪一个客户端将收到消息。我们还将看到一些特殊的系统Topic，这些Topic代表了一些关于broker状态的Topic。\n\n### Topic\n在MQTT中，Topic代表一个被broker用来为每个已连接的客户端筛选消息的UTF-8字符串。Topic由一级或多级组成。每一级之间通过正斜杠来划分。\n![](topic_basics.png)\n\n和消息队列相比，MQTTTopic是非常轻量的。客户端在发布或订阅一条消息之前，不需要提前创建一个Topic。broker会在没有任何初始化的情况下接受所有正确的Topic。<br/>\n这里有一些Topic的例子:\n```\nmyhome/groundfloor/livingroom/temperature\nUSA/California/San Francisco/Silicon Valley\n5ff4a2ce-e485-40f4-826c-b1a5d81be9b6/status\nGermany/Bavaria/car/2382340923453/latitude\n```\n注意，每个Topic必须含有至少一个字符，并且Topic字符串允许空字符串。 Topic 是大小写敏感的。例如 myhome/temperature 和 MyHome/Temperature 是两个不同的Topic。另外，单一的正斜杠是一个合法的Topic。\n\n### 通配符\n当一个客户端订阅一个Topic，它可以精确的订阅一个Topic，也可以通过通配符同时订阅多个Topic。通配符只可以被用于订阅Topic，不可以用于发布消息。这里有两种不同的通配符:单层和多层。\n\n#### 单层通配符: +\n正如名字所表示的含义，一个单层通配符可以替换一级Topic。在Topic的字符串中，加号代表着一个单层通配符。\n![](topic_wildcard_plus.png)\n\n当Topic的某一级为通配符时，在这一级有任何字符串都可以被匹配。例如 一条形如 myhome/groundfloor/+/temperature 的订阅消息对一下的Topic会产生不同的结果:\n![](topic_wildcard_plus_example.png)\n\n#### 多层通配符: #\n多层通配符可以覆盖Topic中多层字符，'#'符号在Topic字符串中代表一个多层通配符。为了让broker可以确定哪些Topic可以被匹配，多层通配符必须是Topic字符串的字符，并且倒数第二个字符为正斜杠。\n![](topic_wildcard_hash.png)\n\n当一个客户端使用多层通配符订阅Topic，它将会收到以通配符之前字符串开头的所有消息，不管这条消息有多长。如果你只把 '#' 符号作为一条Topic。你会收到所有发往MQTT broker的消息。如果你想要高吞吐量，就不应该只使用一个'#'作为Topic。\n\n### 以 '$' 符号开头的话题\n一般来说，你可以给MQTT Topic任意的名字。但是，这有一个例外， 以'\\$'符号开头的Topic被borker保留用来做内部的计数。客户端不可以给这些话题推送消息。同时，这些Topic没有被官方标准化。通常 \\$SYS/ 被用于代表以下消息，但不同的实现可以能有不同的意义。 [MQTT GitHub Wiki](https://github.com/mqtt/mqtt.org/wiki/SYS-Topics)中有\\$SYS 相关Topic的建议。这里有一些例子:\n\n```\n$SYS/broker/clients/connected\n$SYS/broker/clients/disconnected\n$SYS/broker/clients/total\n$SYS/broker/messages/sent\n$SYS/broker/uptime\n```\n### 总结\n上述是一些关于MQTT消息的基础知识。如你所见，MQTT Topic是动态并且具有灵活性的。当你在真实的程序中使用通配符时，有一些挑战需要你留心。下面我们会讲一些从很多MQTT项目的实践中总结出的一些MQTT Topic相关的最佳实践，你有任何想法都可以和我们讨论。\n\n## 最佳实践\n- 不要使用正斜杠作为Topic的首字符 \n正斜杠作为Topic首字符在MQTT中是被允许的，例如, /myhome/groundfloor/livingroom. 然而，前导正斜杠带来了一个没有任何字符的多余层级，这没有带来任何好处并且容易产生误解。\n- 不要在Topic中使用空格\n空格是所有程序员的敌人。当事情没有按预期发生时，Topic中的空格会加大查找问题的代价。和前导正斜杠一样，一些行为被允许不代表它是对的。UTF-8有许多中不同类型的空格，实践中应该避免这样不统一的字符。\n- 保持Topic的精简\n每个Topic将被所有关于它的消息携带，所以应该尽可能的让Topics变得精简。在一些小型设备上，每一个字节都有很大的影响。\n- 只使用ASCII字符，避免使用不可打印的字符\n因为非 ASCII的 UTF-8字符经常不可以正常显示。所以如果不是迫不得已，我们建议避免在Topic中使用任何的非ASCII字符。\n- 将唯一ID或客户端ID加入到Topic中\n将唯一ID或客户端ID加入到Topic中是非常有帮助的，这可以帮助你明确是哪个客户端发出的消息。Topic内置ID可以用来控制权限。只有当一个客户端和Topic拥有相同ID时才被允许向Topic发布消息。例如，一个客户端的ID为 'clent1',它可以向client1/status发布消息。但不可以向 client2/status 发布消息。\n- 不要订阅 '#'\n在有些场景中，我们必须订阅通过broker的所有消息。例如，将所有消息持久化到数据库。不要通过使用一个客户端订阅 '#' Topic的方式来获取所有消息。一般来说，一个客户端很难承担所有消息的负载(特别是消息吞吐量大时)。\n我们推荐给MQTT broker实现一个插件。例如，使用plugin system of HiveMQ 你可以给broker添加一个钩子，异步的将所有消息存入数据库。\n- 不要忘记可扩展性\nTopics 是一个灵活的概念，并且在任何情况下都不需要提前配置它。然而，发布者和订阅者都必须知道用来通信的Topic。思考如何设计Topic可以有助于为项目添加新特性是非常重要的。例如，为智能家居添加新的传感器时，尽量将他们添加到Topic树的一部分，而不是修改整个Topic的结构。\n- 使用特定的话题\n当你给一个Topic命名时，不要使用给队列命名时相同的习惯。尽量使不同的Topic之间便于区分。例如，如果你有三个传感器在卧室中，创建这样的三个Topic:\n```\nmyhome/livingroom/temperature\nmyhome/livingroom/brightness\nmyhome/livingroom/humidity. \n```\n不要通过 myhome/livingroom发送所有消息。使用特定的消息有助于使用其他MQTT的特性，例如 retained messages;\n\n## 结语\nMQTT系列文章的第五篇文章结束了，下一章我们将主要讲解服务质量(Quality of Service)相关的内容。","slug":"MQTT基础文档翻译-五-话题和相关的实践","published":1,"updated":"2022-03-01T16:08:27.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0b4dtq90005vsvi36ozc3hl","content":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-Topics-best-practices/\">MQTT Topics &amp; Best Practices - MQTT Essentials: Part 5</a><span id=\"more\"></span></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到关于MQTT核心特性和概念系列文章的第五篇。在这篇文章中，我们将专注于MQTT的Topic和相关的最佳实践。正如我们之前提到的，MQTT的broker通过消息中的Topic信息来决定哪一个客户端将收到消息。我们还将看到一些特殊的系统Topic，这些Topic代表了一些关于broker状态的Topic。</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>在MQTT中，Topic代表一个被broker用来为每个已连接的客户端筛选消息的UTF-8字符串。Topic由一级或多级组成。每一级之间通过正斜杠来划分。<br><img src= \"/img/loading.gif\" data-src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_basics.png\"></p>\n<p>和消息队列相比，MQTTTopic是非常轻量的。客户端在发布或订阅一条消息之前，不需要提前创建一个Topic。broker会在没有任何初始化的情况下接受所有正确的Topic。<br/><br>这里有一些Topic的例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myhome/groundfloor/livingroom/temperature</span><br><span class=\"line\">USA/California/San Francisco/Silicon Valley</span><br><span class=\"line\">5ff4a2ce-e485-40f4-826c-b1a5d81be9b6/status</span><br><span class=\"line\">Germany/Bavaria/car/2382340923453/latitude</span><br></pre></td></tr></table></figure>\n<p>注意，每个Topic必须含有至少一个字符，并且Topic字符串允许空字符串。 Topic 是大小写敏感的。例如 myhome/temperature 和 MyHome/Temperature 是两个不同的Topic。另外，单一的正斜杠是一个合法的Topic。</p>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><p>当一个客户端订阅一个Topic，它可以精确的订阅一个Topic，也可以通过通配符同时订阅多个Topic。通配符只可以被用于订阅Topic，不可以用于发布消息。这里有两种不同的通配符:单层和多层。</p>\n<h4 id=\"单层通配符\"><a href=\"#单层通配符\" class=\"headerlink\" title=\"单层通配符: +\"></a>单层通配符: +</h4><p>正如名字所表示的含义，一个单层通配符可以替换一级Topic。在Topic的字符串中，加号代表着一个单层通配符。<br><img src= \"/img/loading.gif\" data-src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_wildcard_plus.png\"></p>\n<p>当Topic的某一级为通配符时，在这一级有任何字符串都可以被匹配。例如 一条形如 myhome/groundfloor/+/temperature 的订阅消息对一下的Topic会产生不同的结果:<br><img src= \"/img/loading.gif\" data-src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_wildcard_plus_example.png\"></p>\n<h4 id=\"多层通配符\"><a href=\"#多层通配符\" class=\"headerlink\" title=\"多层通配符:\"></a>多层通配符:</h4><p>多层通配符可以覆盖Topic中多层字符，’#’符号在Topic字符串中代表一个多层通配符。为了让broker可以确定哪些Topic可以被匹配，多层通配符必须是Topic字符串的字符，并且倒数第二个字符为正斜杠。<br><img src= \"/img/loading.gif\" data-src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_wildcard_hash.png\"></p>\n<p>当一个客户端使用多层通配符订阅Topic，它将会收到以通配符之前字符串开头的所有消息，不管这条消息有多长。如果你只把 ‘#’ 符号作为一条Topic。你会收到所有发往MQTT broker的消息。如果你想要高吞吐量，就不应该只使用一个’#’作为Topic。</p>\n<h3 id=\"以-‘-’-符号开头的话题\"><a href=\"#以-‘-’-符号开头的话题\" class=\"headerlink\" title=\"以 ‘$’ 符号开头的话题\"></a>以 ‘$’ 符号开头的话题</h3><p>一般来说，你可以给MQTT Topic任意的名字。但是，这有一个例外， 以’$‘符号开头的Topic被borker保留用来做内部的计数。客户端不可以给这些话题推送消息。同时，这些Topic没有被官方标准化。通常 $SYS/ 被用于代表以下消息，但不同的实现可以能有不同的意义。 <a href=\"https://github.com/mqtt/mqtt.org/wiki/SYS-Topics\">MQTT GitHub Wiki</a>中有$SYS 相关Topic的建议。这里有一些例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$SYS/broker/clients/connected</span><br><span class=\"line\">$SYS/broker/clients/disconnected</span><br><span class=\"line\">$SYS/broker/clients/total</span><br><span class=\"line\">$SYS/broker/messages/sent</span><br><span class=\"line\">$SYS/broker/uptime</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上述是一些关于MQTT消息的基础知识。如你所见，MQTT Topic是动态并且具有灵活性的。当你在真实的程序中使用通配符时，有一些挑战需要你留心。下面我们会讲一些从很多MQTT项目的实践中总结出的一些MQTT Topic相关的最佳实践，你有任何想法都可以和我们讨论。</p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ul>\n<li>不要使用正斜杠作为Topic的首字符<br>正斜杠作为Topic首字符在MQTT中是被允许的，例如, /myhome/groundfloor/livingroom. 然而，前导正斜杠带来了一个没有任何字符的多余层级，这没有带来任何好处并且容易产生误解。</li>\n<li>不要在Topic中使用空格<br>空格是所有程序员的敌人。当事情没有按预期发生时，Topic中的空格会加大查找问题的代价。和前导正斜杠一样，一些行为被允许不代表它是对的。UTF-8有许多中不同类型的空格，实践中应该避免这样不统一的字符。</li>\n<li>保持Topic的精简<br>每个Topic将被所有关于它的消息携带，所以应该尽可能的让Topics变得精简。在一些小型设备上，每一个字节都有很大的影响。</li>\n<li>只使用ASCII字符，避免使用不可打印的字符<br>因为非 ASCII的 UTF-8字符经常不可以正常显示。所以如果不是迫不得已，我们建议避免在Topic中使用任何的非ASCII字符。</li>\n<li>将唯一ID或客户端ID加入到Topic中<br>将唯一ID或客户端ID加入到Topic中是非常有帮助的，这可以帮助你明确是哪个客户端发出的消息。Topic内置ID可以用来控制权限。只有当一个客户端和Topic拥有相同ID时才被允许向Topic发布消息。例如，一个客户端的ID为 ‘clent1’,它可以向client1/status发布消息。但不可以向 client2/status 发布消息。</li>\n<li>不要订阅 ‘#’<br>在有些场景中，我们必须订阅通过broker的所有消息。例如，将所有消息持久化到数据库。不要通过使用一个客户端订阅 ‘#’ Topic的方式来获取所有消息。一般来说，一个客户端很难承担所有消息的负载(特别是消息吞吐量大时)。<br>我们推荐给MQTT broker实现一个插件。例如，使用plugin system of HiveMQ 你可以给broker添加一个钩子，异步的将所有消息存入数据库。</li>\n<li>不要忘记可扩展性<br>Topics 是一个灵活的概念，并且在任何情况下都不需要提前配置它。然而，发布者和订阅者都必须知道用来通信的Topic。思考如何设计Topic可以有助于为项目添加新特性是非常重要的。例如，为智能家居添加新的传感器时，尽量将他们添加到Topic树的一部分，而不是修改整个Topic的结构。</li>\n<li>使用特定的话题<br>当你给一个Topic命名时，不要使用给队列命名时相同的习惯。尽量使不同的Topic之间便于区分。例如，如果你有三个传感器在卧室中，创建这样的三个Topic:<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myhome/livingroom/temperature</span><br><span class=\"line\">myhome/livingroom/brightness</span><br><span class=\"line\">myhome/livingroom/humidity. </span><br></pre></td></tr></table></figure>\n不要通过 myhome/livingroom发送所有消息。使用特定的消息有助于使用其他MQTT的特性，例如 retained messages;</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>MQTT系列文章的第五篇文章结束了，下一章我们将主要讲解服务质量(Quality of Service)相关的内容。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-Topics-best-practices/\">MQTT Topics &amp; Best Practices - MQTT Essentials: Part 5</a>","more":"</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到关于MQTT核心特性和概念系列文章的第五篇。在这篇文章中，我们将专注于MQTT的Topic和相关的最佳实践。正如我们之前提到的，MQTT的broker通过消息中的Topic信息来决定哪一个客户端将收到消息。我们还将看到一些特殊的系统Topic，这些Topic代表了一些关于broker状态的Topic。</p>\n<h3 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h3><p>在MQTT中，Topic代表一个被broker用来为每个已连接的客户端筛选消息的UTF-8字符串。Topic由一级或多级组成。每一级之间通过正斜杠来划分。<br><img src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_basics.png\"></p>\n<p>和消息队列相比，MQTTTopic是非常轻量的。客户端在发布或订阅一条消息之前，不需要提前创建一个Topic。broker会在没有任何初始化的情况下接受所有正确的Topic。<br/><br>这里有一些Topic的例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myhome/groundfloor/livingroom/temperature</span><br><span class=\"line\">USA/California/San Francisco/Silicon Valley</span><br><span class=\"line\">5ff4a2ce-e485-40f4-826c-b1a5d81be9b6/status</span><br><span class=\"line\">Germany/Bavaria/car/2382340923453/latitude</span><br></pre></td></tr></table></figure>\n<p>注意，每个Topic必须含有至少一个字符，并且Topic字符串允许空字符串。 Topic 是大小写敏感的。例如 myhome/temperature 和 MyHome/Temperature 是两个不同的Topic。另外，单一的正斜杠是一个合法的Topic。</p>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><p>当一个客户端订阅一个Topic，它可以精确的订阅一个Topic，也可以通过通配符同时订阅多个Topic。通配符只可以被用于订阅Topic，不可以用于发布消息。这里有两种不同的通配符:单层和多层。</p>\n<h4 id=\"单层通配符\"><a href=\"#单层通配符\" class=\"headerlink\" title=\"单层通配符: +\"></a>单层通配符: +</h4><p>正如名字所表示的含义，一个单层通配符可以替换一级Topic。在Topic的字符串中，加号代表着一个单层通配符。<br><img src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_wildcard_plus.png\"></p>\n<p>当Topic的某一级为通配符时，在这一级有任何字符串都可以被匹配。例如 一条形如 myhome/groundfloor/+/temperature 的订阅消息对一下的Topic会产生不同的结果:<br><img src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_wildcard_plus_example.png\"></p>\n<h4 id=\"多层通配符\"><a href=\"#多层通配符\" class=\"headerlink\" title=\"多层通配符:\"></a>多层通配符:</h4><p>多层通配符可以覆盖Topic中多层字符，’#’符号在Topic字符串中代表一个多层通配符。为了让broker可以确定哪些Topic可以被匹配，多层通配符必须是Topic字符串的字符，并且倒数第二个字符为正斜杠。<br><img src=\"/2022/03/02/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BA%94-%E8%AF%9D%E9%A2%98%E5%92%8C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%9E%E8%B7%B5/topic_wildcard_hash.png\"></p>\n<p>当一个客户端使用多层通配符订阅Topic，它将会收到以通配符之前字符串开头的所有消息，不管这条消息有多长。如果你只把 ‘#’ 符号作为一条Topic。你会收到所有发往MQTT broker的消息。如果你想要高吞吐量，就不应该只使用一个’#’作为Topic。</p>\n<h3 id=\"以-‘-’-符号开头的话题\"><a href=\"#以-‘-’-符号开头的话题\" class=\"headerlink\" title=\"以 ‘$’ 符号开头的话题\"></a>以 ‘$’ 符号开头的话题</h3><p>一般来说，你可以给MQTT Topic任意的名字。但是，这有一个例外， 以’$‘符号开头的Topic被borker保留用来做内部的计数。客户端不可以给这些话题推送消息。同时，这些Topic没有被官方标准化。通常 $SYS/ 被用于代表以下消息，但不同的实现可以能有不同的意义。 <a href=\"https://github.com/mqtt/mqtt.org/wiki/SYS-Topics\">MQTT GitHub Wiki</a>中有$SYS 相关Topic的建议。这里有一些例子:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$SYS/broker/clients/connected</span><br><span class=\"line\">$SYS/broker/clients/disconnected</span><br><span class=\"line\">$SYS/broker/clients/total</span><br><span class=\"line\">$SYS/broker/messages/sent</span><br><span class=\"line\">$SYS/broker/uptime</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上述是一些关于MQTT消息的基础知识。如你所见，MQTT Topic是动态并且具有灵活性的。当你在真实的程序中使用通配符时，有一些挑战需要你留心。下面我们会讲一些从很多MQTT项目的实践中总结出的一些MQTT Topic相关的最佳实践，你有任何想法都可以和我们讨论。</p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ul>\n<li>不要使用正斜杠作为Topic的首字符<br>正斜杠作为Topic首字符在MQTT中是被允许的，例如, /myhome/groundfloor/livingroom. 然而，前导正斜杠带来了一个没有任何字符的多余层级，这没有带来任何好处并且容易产生误解。</li>\n<li>不要在Topic中使用空格<br>空格是所有程序员的敌人。当事情没有按预期发生时，Topic中的空格会加大查找问题的代价。和前导正斜杠一样，一些行为被允许不代表它是对的。UTF-8有许多中不同类型的空格，实践中应该避免这样不统一的字符。</li>\n<li>保持Topic的精简<br>每个Topic将被所有关于它的消息携带，所以应该尽可能的让Topics变得精简。在一些小型设备上，每一个字节都有很大的影响。</li>\n<li>只使用ASCII字符，避免使用不可打印的字符<br>因为非 ASCII的 UTF-8字符经常不可以正常显示。所以如果不是迫不得已，我们建议避免在Topic中使用任何的非ASCII字符。</li>\n<li>将唯一ID或客户端ID加入到Topic中<br>将唯一ID或客户端ID加入到Topic中是非常有帮助的，这可以帮助你明确是哪个客户端发出的消息。Topic内置ID可以用来控制权限。只有当一个客户端和Topic拥有相同ID时才被允许向Topic发布消息。例如，一个客户端的ID为 ‘clent1’,它可以向client1/status发布消息。但不可以向 client2/status 发布消息。</li>\n<li>不要订阅 ‘#’<br>在有些场景中，我们必须订阅通过broker的所有消息。例如，将所有消息持久化到数据库。不要通过使用一个客户端订阅 ‘#’ Topic的方式来获取所有消息。一般来说，一个客户端很难承担所有消息的负载(特别是消息吞吐量大时)。<br>我们推荐给MQTT broker实现一个插件。例如，使用plugin system of HiveMQ 你可以给broker添加一个钩子，异步的将所有消息存入数据库。</li>\n<li>不要忘记可扩展性<br>Topics 是一个灵活的概念，并且在任何情况下都不需要提前配置它。然而，发布者和订阅者都必须知道用来通信的Topic。思考如何设计Topic可以有助于为项目添加新特性是非常重要的。例如，为智能家居添加新的传感器时，尽量将他们添加到Topic树的一部分，而不是修改整个Topic的结构。</li>\n<li>使用特定的话题<br>当你给一个Topic命名时，不要使用给队列命名时相同的习惯。尽量使不同的Topic之间便于区分。例如，如果你有三个传感器在卧室中，创建这样的三个Topic:<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myhome/livingroom/temperature</span><br><span class=\"line\">myhome/livingroom/brightness</span><br><span class=\"line\">myhome/livingroom/humidity. </span><br></pre></td></tr></table></figure>\n不要通过 myhome/livingroom发送所有消息。使用特定的消息有助于使用其他MQTT的特性，例如 retained messages;</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>MQTT系列文章的第五篇文章结束了，下一章我们将主要讲解服务质量(Quality of Service)相关的内容。</p>"},{"title":"MQTT基础文档翻译(四):发布、订阅和取消订阅","date":"2022-02-17T14:49:11.000Z","_content":"## 原文链接\n[MQTT Publish, Subscribe & Unsubscribe - MQTT Essentials: Part 4](https://www.hivemq.com/blog/mqtt-essentials-part-4-mqtt-publish-subscribe-unsubscribe/)\n<!--more-->\n## 正文\n欢迎来到MQTT系列文章的第四部分。在这篇文章中，我们将主要关注MQTT中的发布、订阅和取消订阅。在之前的文章中讲述了发布/订阅模型的基础概念。在这篇文章中我们专注于MQTT协议中发布/订阅相关特性。如果你没有阅读过之前关于发布订阅模型的基础知识介绍，我们强烈建议你先阅读相关的文章。 <br/>\n上周，我们主要关注在MQTT客户端和broker之间简历连接。这一周，我们以这些知识为基础来讨论发送和接收消息。在文章的末尾有一个关于这个话题的视频来补充文章的内容。\n\n### 发布(Publish)\n\n一个MQTT客户端只要建立起和broker的连接之后，就可以发布消息。 MQTT利用broker基于话题(Topic)的消息过滤方式。每一条消息必须含有一个Topic，这样broker就可以通过Topic信息来将消息转发到对这个Topic感兴趣的客户端。通常，每个消息有一块由字节格式数据组成的负载(payload)。MQTT是数据不可知的，客户端的使用方法决定了负载中数据的结构。发送消息的客户端(publisher)自由决定发送二进制数据或文本数据甚至是XML或者是JSON格式的数据。<br/>\n在MQTT中一个PUBLISH消息有许多我们想要细致讨论的属性。\n\n![](publish_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码，数据包ID只有在Qos级别大于0时生效。客户端程序库或者broker负责设置这个MQTT内部的识别ID。\n\n- Topic Name\n\n话题名称是一个使用斜杠作为分隔符的层次化简单字符串。 例如 \"myhome/livingroom/temperatur\" 或者 \"Germary/Munich/Octoberfest/people\". 更多关于Topics的细节请看第五章。\n\n- Qos\n\n这个数字表明了服务质量(Quality of Service)级别。总共有0，1，2三个级别。服务级别决定了对消息到达目的地(客户端或broker)提供了什么样的保证。更多关于Qos的细节请看第六章。\n\n- Retain Flag\n\n这个标志决定这条消息是否被broker保存来作为某个Topic的(last known good value)。当新的客户端订阅这个Topic，他们会收到这个Topic保存着的最后一条消息。 更多关于retained messages的细节请看第八章。\n\n- Payload\n\n这是消息的实际内容。内容可能包含图像、任何编码方式的文字、加密数据或任何二进制数据。\n\n- DUP flag\n\n这个标志表示这条消息是一个因为目标接受者没有确认原始消息而重传的复制数据。这个标志只有在 Qos 大于0时生效。通常，复制和重传的机制被MQTT客户端库或者broker实现。更多相关消息请看第六章。 <br/>\n当一个客户端向MQTT broker发布一条消息。broker读取并确认消息(取决于Qos级别)，然后处理消息。处理的过程包括确认哪些客户端订阅了当前主题，并将消息发送给他们。\n![](publish_flow.png)\n\n客户端发布消息时只关心将消息发送给broker的过程。当broker接收到被发布的消息，由broker负责将消息传递给所有的订阅者。发布消息的客户端不会知道是否有其他客户端对这条消息感兴趣，也不会知道有多少客户端从broker收到了这条消息。\n\n### 订阅(Subscribe)\n在没有任何人订阅(即没有任何客户端订阅相关话题)的情况下发布消息是无意义的。客户端通过发送一条订阅消息给broker来接收感兴趣的消息。订阅消息的格式非常简单，包含了一个唯一数据包ID和一个订阅话题列表。\n![](subscribe_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。\n\n- List of Subscriptions\n\n一条订阅消息可以包含多条订阅。每条订阅由Topic和Qos级别组成。订阅消息中的Topic可以包含通配符，这样可以匹配一类Topic而不是某个特定的Topic。如果某个客户端重复订阅了一个Topic，broker会按照其中Qos级别最高的一条来处理对应的消息。\n\n### Suback\n\n为了确认每一条订阅消息，broker会回复一个SUBACK消息给客户端。这条消息包含着对应的订阅消息的数据包ID，和一系列的返回码。\n![](suback_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码。和订阅消息中的ID一致。\n\n- Return Code\n\nbroker为在订阅消息中收到的每一个 Topic/Qos 对返回一个结果码。 例如，如果订阅消息包含5个订阅，则SUBACK消息包含5个结果码。结果码确认每一个Topic并且返回被broker使用的Qos级别。如果broker拒绝了某个订阅，SUBACK消息会包含一个代表失败的结果码给对应的订阅。例如客户端没有足够的权限去订阅某个Topic。\n\n![](return_code.png)\n\n![](subscribe_flow.png)\n\n在客户端成功的发送一条SUBSCRIBE消息，并且收到SUBACK消息之后。客户端会收到被订阅的话题下的每一条消息。\n\n### 取消订阅(Unsubscribe)\n\n和订阅(Subscribe)消息对应的是取消订阅(Unsubscribe)消息。这条消息为客户端删除一个订阅。取消订阅消息和订阅消息类似，包含一个数据包ID和一系列Topic。\n\n![](unsubscribe_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。\n\n- List of Topic\n\n话题列表可以包含多个客户端想要取消订阅的Topic。只需要发送Topic，不需要Qos。broker不管当前Topic属于什么Qos级别，都会为客户端取消对某个Topic的订阅。\n\n### Unsunack\n\n为了确认取消订阅消息，broker会发送一个UNSUBACK的确认消息给客户端。这条消息只包含着取消订阅消息的数据包ID(为了明确当前消息对应的取消订阅消息)。\n\n![](unsuback_packet.png)\n\n- Packet Identifier \n\n数据包ID是客户端和broker之间消息的唯一识别码。之前提到过，这个ID和UNSUBSCRIBE消息中的ID相等。\n\n![](unsubscribe_flow.png)\n\n当客户端从broker收到UNSUBACK消息后，客户端可以认为在UNSUBSCRIBE消息中包含的订阅已经被删除了。\n\n### 结语\n\n第四章的内容已经结束了，希望你有所收获。在下一章中我们将深入了解MQTT Topic的使用方法。 包括Topic的基础知识、如何使用通配符，并且会提供大量的例子。\n\n\n","source":"_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅.md","raw":"---\ntitle: 'MQTT基础文档翻译(四):发布、订阅和取消订阅'\ndate: 2022-02-17 22:49:11\ntags: MQTT\n---\n## 原文链接\n[MQTT Publish, Subscribe & Unsubscribe - MQTT Essentials: Part 4](https://www.hivemq.com/blog/mqtt-essentials-part-4-mqtt-publish-subscribe-unsubscribe/)\n<!--more-->\n## 正文\n欢迎来到MQTT系列文章的第四部分。在这篇文章中，我们将主要关注MQTT中的发布、订阅和取消订阅。在之前的文章中讲述了发布/订阅模型的基础概念。在这篇文章中我们专注于MQTT协议中发布/订阅相关特性。如果你没有阅读过之前关于发布订阅模型的基础知识介绍，我们强烈建议你先阅读相关的文章。 <br/>\n上周，我们主要关注在MQTT客户端和broker之间简历连接。这一周，我们以这些知识为基础来讨论发送和接收消息。在文章的末尾有一个关于这个话题的视频来补充文章的内容。\n\n### 发布(Publish)\n\n一个MQTT客户端只要建立起和broker的连接之后，就可以发布消息。 MQTT利用broker基于话题(Topic)的消息过滤方式。每一条消息必须含有一个Topic，这样broker就可以通过Topic信息来将消息转发到对这个Topic感兴趣的客户端。通常，每个消息有一块由字节格式数据组成的负载(payload)。MQTT是数据不可知的，客户端的使用方法决定了负载中数据的结构。发送消息的客户端(publisher)自由决定发送二进制数据或文本数据甚至是XML或者是JSON格式的数据。<br/>\n在MQTT中一个PUBLISH消息有许多我们想要细致讨论的属性。\n\n![](publish_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码，数据包ID只有在Qos级别大于0时生效。客户端程序库或者broker负责设置这个MQTT内部的识别ID。\n\n- Topic Name\n\n话题名称是一个使用斜杠作为分隔符的层次化简单字符串。 例如 \"myhome/livingroom/temperatur\" 或者 \"Germary/Munich/Octoberfest/people\". 更多关于Topics的细节请看第五章。\n\n- Qos\n\n这个数字表明了服务质量(Quality of Service)级别。总共有0，1，2三个级别。服务级别决定了对消息到达目的地(客户端或broker)提供了什么样的保证。更多关于Qos的细节请看第六章。\n\n- Retain Flag\n\n这个标志决定这条消息是否被broker保存来作为某个Topic的(last known good value)。当新的客户端订阅这个Topic，他们会收到这个Topic保存着的最后一条消息。 更多关于retained messages的细节请看第八章。\n\n- Payload\n\n这是消息的实际内容。内容可能包含图像、任何编码方式的文字、加密数据或任何二进制数据。\n\n- DUP flag\n\n这个标志表示这条消息是一个因为目标接受者没有确认原始消息而重传的复制数据。这个标志只有在 Qos 大于0时生效。通常，复制和重传的机制被MQTT客户端库或者broker实现。更多相关消息请看第六章。 <br/>\n当一个客户端向MQTT broker发布一条消息。broker读取并确认消息(取决于Qos级别)，然后处理消息。处理的过程包括确认哪些客户端订阅了当前主题，并将消息发送给他们。\n![](publish_flow.png)\n\n客户端发布消息时只关心将消息发送给broker的过程。当broker接收到被发布的消息，由broker负责将消息传递给所有的订阅者。发布消息的客户端不会知道是否有其他客户端对这条消息感兴趣，也不会知道有多少客户端从broker收到了这条消息。\n\n### 订阅(Subscribe)\n在没有任何人订阅(即没有任何客户端订阅相关话题)的情况下发布消息是无意义的。客户端通过发送一条订阅消息给broker来接收感兴趣的消息。订阅消息的格式非常简单，包含了一个唯一数据包ID和一个订阅话题列表。\n![](subscribe_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。\n\n- List of Subscriptions\n\n一条订阅消息可以包含多条订阅。每条订阅由Topic和Qos级别组成。订阅消息中的Topic可以包含通配符，这样可以匹配一类Topic而不是某个特定的Topic。如果某个客户端重复订阅了一个Topic，broker会按照其中Qos级别最高的一条来处理对应的消息。\n\n### Suback\n\n为了确认每一条订阅消息，broker会回复一个SUBACK消息给客户端。这条消息包含着对应的订阅消息的数据包ID，和一系列的返回码。\n![](suback_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码。和订阅消息中的ID一致。\n\n- Return Code\n\nbroker为在订阅消息中收到的每一个 Topic/Qos 对返回一个结果码。 例如，如果订阅消息包含5个订阅，则SUBACK消息包含5个结果码。结果码确认每一个Topic并且返回被broker使用的Qos级别。如果broker拒绝了某个订阅，SUBACK消息会包含一个代表失败的结果码给对应的订阅。例如客户端没有足够的权限去订阅某个Topic。\n\n![](return_code.png)\n\n![](subscribe_flow.png)\n\n在客户端成功的发送一条SUBSCRIBE消息，并且收到SUBACK消息之后。客户端会收到被订阅的话题下的每一条消息。\n\n### 取消订阅(Unsubscribe)\n\n和订阅(Subscribe)消息对应的是取消订阅(Unsubscribe)消息。这条消息为客户端删除一个订阅。取消订阅消息和订阅消息类似，包含一个数据包ID和一系列Topic。\n\n![](unsubscribe_packet.png)\n\n- Packet Identifier\n\n数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。\n\n- List of Topic\n\n话题列表可以包含多个客户端想要取消订阅的Topic。只需要发送Topic，不需要Qos。broker不管当前Topic属于什么Qos级别，都会为客户端取消对某个Topic的订阅。\n\n### Unsunack\n\n为了确认取消订阅消息，broker会发送一个UNSUBACK的确认消息给客户端。这条消息只包含着取消订阅消息的数据包ID(为了明确当前消息对应的取消订阅消息)。\n\n![](unsuback_packet.png)\n\n- Packet Identifier \n\n数据包ID是客户端和broker之间消息的唯一识别码。之前提到过，这个ID和UNSUBSCRIBE消息中的ID相等。\n\n![](unsubscribe_flow.png)\n\n当客户端从broker收到UNSUBACK消息后，客户端可以认为在UNSUBSCRIBE消息中包含的订阅已经被删除了。\n\n### 结语\n\n第四章的内容已经结束了，希望你有所收获。在下一章中我们将深入了解MQTT Topic的使用方法。 包括Topic的基础知识、如何使用通配符，并且会提供大量的例子。\n\n\n","slug":"MQTT基础文档翻译-四-发布、订阅和取消订阅","published":1,"updated":"2022-03-01T16:05:05.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0b4dtqa0008vsvifnyj9w9i","content":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-4-mqtt-publish-subscribe-unsubscribe/\">MQTT Publish, Subscribe &amp; Unsubscribe - MQTT Essentials: Part 4</a></p>\n<span id=\"more\"></span>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到MQTT系列文章的第四部分。在这篇文章中，我们将主要关注MQTT中的发布、订阅和取消订阅。在之前的文章中讲述了发布/订阅模型的基础概念。在这篇文章中我们专注于MQTT协议中发布/订阅相关特性。如果你没有阅读过之前关于发布订阅模型的基础知识介绍，我们强烈建议你先阅读相关的文章。 <br/><br>上周，我们主要关注在MQTT客户端和broker之间简历连接。这一周，我们以这些知识为基础来讨论发送和接收消息。在文章的末尾有一个关于这个话题的视频来补充文章的内容。</p>\n<h3 id=\"发布-Publish\"><a href=\"#发布-Publish\" class=\"headerlink\" title=\"发布(Publish)\"></a>发布(Publish)</h3><p>一个MQTT客户端只要建立起和broker的连接之后，就可以发布消息。 MQTT利用broker基于话题(Topic)的消息过滤方式。每一条消息必须含有一个Topic，这样broker就可以通过Topic信息来将消息转发到对这个Topic感兴趣的客户端。通常，每个消息有一块由字节格式数据组成的负载(payload)。MQTT是数据不可知的，客户端的使用方法决定了负载中数据的结构。发送消息的客户端(publisher)自由决定发送二进制数据或文本数据甚至是XML或者是JSON格式的数据。<br/><br>在MQTT中一个PUBLISH消息有许多我们想要细致讨论的属性。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/publish_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码，数据包ID只有在Qos级别大于0时生效。客户端程序库或者broker负责设置这个MQTT内部的识别ID。</p>\n<ul>\n<li>Topic Name</li>\n</ul>\n<p>话题名称是一个使用斜杠作为分隔符的层次化简单字符串。 例如 “myhome/livingroom/temperatur” 或者 “Germary/Munich/Octoberfest/people”. 更多关于Topics的细节请看第五章。</p>\n<ul>\n<li>Qos</li>\n</ul>\n<p>这个数字表明了服务质量(Quality of Service)级别。总共有0，1，2三个级别。服务级别决定了对消息到达目的地(客户端或broker)提供了什么样的保证。更多关于Qos的细节请看第六章。</p>\n<ul>\n<li>Retain Flag</li>\n</ul>\n<p>这个标志决定这条消息是否被broker保存来作为某个Topic的(last known good value)。当新的客户端订阅这个Topic，他们会收到这个Topic保存着的最后一条消息。 更多关于retained messages的细节请看第八章。</p>\n<ul>\n<li>Payload</li>\n</ul>\n<p>这是消息的实际内容。内容可能包含图像、任何编码方式的文字、加密数据或任何二进制数据。</p>\n<ul>\n<li>DUP flag</li>\n</ul>\n<p>这个标志表示这条消息是一个因为目标接受者没有确认原始消息而重传的复制数据。这个标志只有在 Qos 大于0时生效。通常，复制和重传的机制被MQTT客户端库或者broker实现。更多相关消息请看第六章。 <br/><br>当一个客户端向MQTT broker发布一条消息。broker读取并确认消息(取决于Qos级别)，然后处理消息。处理的过程包括确认哪些客户端订阅了当前主题，并将消息发送给他们。<br><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/publish_flow.png\"></p>\n<p>客户端发布消息时只关心将消息发送给broker的过程。当broker接收到被发布的消息，由broker负责将消息传递给所有的订阅者。发布消息的客户端不会知道是否有其他客户端对这条消息感兴趣，也不会知道有多少客户端从broker收到了这条消息。</p>\n<h3 id=\"订阅-Subscribe\"><a href=\"#订阅-Subscribe\" class=\"headerlink\" title=\"订阅(Subscribe)\"></a>订阅(Subscribe)</h3><p>在没有任何人订阅(即没有任何客户端订阅相关话题)的情况下发布消息是无意义的。客户端通过发送一条订阅消息给broker来接收感兴趣的消息。订阅消息的格式非常简单，包含了一个唯一数据包ID和一个订阅话题列表。<br><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/subscribe_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。</p>\n<ul>\n<li>List of Subscriptions</li>\n</ul>\n<p>一条订阅消息可以包含多条订阅。每条订阅由Topic和Qos级别组成。订阅消息中的Topic可以包含通配符，这样可以匹配一类Topic而不是某个特定的Topic。如果某个客户端重复订阅了一个Topic，broker会按照其中Qos级别最高的一条来处理对应的消息。</p>\n<h3 id=\"Suback\"><a href=\"#Suback\" class=\"headerlink\" title=\"Suback\"></a>Suback</h3><p>为了确认每一条订阅消息，broker会回复一个SUBACK消息给客户端。这条消息包含着对应的订阅消息的数据包ID，和一系列的返回码。<br><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/suback_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。和订阅消息中的ID一致。</p>\n<ul>\n<li>Return Code</li>\n</ul>\n<p>broker为在订阅消息中收到的每一个 Topic/Qos 对返回一个结果码。 例如，如果订阅消息包含5个订阅，则SUBACK消息包含5个结果码。结果码确认每一个Topic并且返回被broker使用的Qos级别。如果broker拒绝了某个订阅，SUBACK消息会包含一个代表失败的结果码给对应的订阅。例如客户端没有足够的权限去订阅某个Topic。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/return_code.png\"></p>\n<p><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/subscribe_flow.png\"></p>\n<p>在客户端成功的发送一条SUBSCRIBE消息，并且收到SUBACK消息之后。客户端会收到被订阅的话题下的每一条消息。</p>\n<h3 id=\"取消订阅-Unsubscribe\"><a href=\"#取消订阅-Unsubscribe\" class=\"headerlink\" title=\"取消订阅(Unsubscribe)\"></a>取消订阅(Unsubscribe)</h3><p>和订阅(Subscribe)消息对应的是取消订阅(Unsubscribe)消息。这条消息为客户端删除一个订阅。取消订阅消息和订阅消息类似，包含一个数据包ID和一系列Topic。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/unsubscribe_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。</p>\n<ul>\n<li>List of Topic</li>\n</ul>\n<p>话题列表可以包含多个客户端想要取消订阅的Topic。只需要发送Topic，不需要Qos。broker不管当前Topic属于什么Qos级别，都会为客户端取消对某个Topic的订阅。</p>\n<h3 id=\"Unsunack\"><a href=\"#Unsunack\" class=\"headerlink\" title=\"Unsunack\"></a>Unsunack</h3><p>为了确认取消订阅消息，broker会发送一个UNSUBACK的确认消息给客户端。这条消息只包含着取消订阅消息的数据包ID(为了明确当前消息对应的取消订阅消息)。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/unsuback_packet.png\"></p>\n<ul>\n<li>Packet Identifier </li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。之前提到过，这个ID和UNSUBSCRIBE消息中的ID相等。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/unsubscribe_flow.png\"></p>\n<p>当客户端从broker收到UNSUBACK消息后，客户端可以认为在UNSUBSCRIBE消息中包含的订阅已经被删除了。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>第四章的内容已经结束了，希望你有所收获。在下一章中我们将深入了解MQTT Topic的使用方法。 包括Topic的基础知识、如何使用通配符，并且会提供大量的例子。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h2><p><a href=\"https://www.hivemq.com/blog/mqtt-essentials-part-4-mqtt-publish-subscribe-unsubscribe/\">MQTT Publish, Subscribe &amp; Unsubscribe - MQTT Essentials: Part 4</a></p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>欢迎来到MQTT系列文章的第四部分。在这篇文章中，我们将主要关注MQTT中的发布、订阅和取消订阅。在之前的文章中讲述了发布/订阅模型的基础概念。在这篇文章中我们专注于MQTT协议中发布/订阅相关特性。如果你没有阅读过之前关于发布订阅模型的基础知识介绍，我们强烈建议你先阅读相关的文章。 <br/><br>上周，我们主要关注在MQTT客户端和broker之间简历连接。这一周，我们以这些知识为基础来讨论发送和接收消息。在文章的末尾有一个关于这个话题的视频来补充文章的内容。</p>\n<h3 id=\"发布-Publish\"><a href=\"#发布-Publish\" class=\"headerlink\" title=\"发布(Publish)\"></a>发布(Publish)</h3><p>一个MQTT客户端只要建立起和broker的连接之后，就可以发布消息。 MQTT利用broker基于话题(Topic)的消息过滤方式。每一条消息必须含有一个Topic，这样broker就可以通过Topic信息来将消息转发到对这个Topic感兴趣的客户端。通常，每个消息有一块由字节格式数据组成的负载(payload)。MQTT是数据不可知的，客户端的使用方法决定了负载中数据的结构。发送消息的客户端(publisher)自由决定发送二进制数据或文本数据甚至是XML或者是JSON格式的数据。<br/><br>在MQTT中一个PUBLISH消息有许多我们想要细致讨论的属性。</p>\n<p><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/publish_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码，数据包ID只有在Qos级别大于0时生效。客户端程序库或者broker负责设置这个MQTT内部的识别ID。</p>\n<ul>\n<li>Topic Name</li>\n</ul>\n<p>话题名称是一个使用斜杠作为分隔符的层次化简单字符串。 例如 “myhome/livingroom/temperatur” 或者 “Germary/Munich/Octoberfest/people”. 更多关于Topics的细节请看第五章。</p>\n<ul>\n<li>Qos</li>\n</ul>\n<p>这个数字表明了服务质量(Quality of Service)级别。总共有0，1，2三个级别。服务级别决定了对消息到达目的地(客户端或broker)提供了什么样的保证。更多关于Qos的细节请看第六章。</p>\n<ul>\n<li>Retain Flag</li>\n</ul>\n<p>这个标志决定这条消息是否被broker保存来作为某个Topic的(last known good value)。当新的客户端订阅这个Topic，他们会收到这个Topic保存着的最后一条消息。 更多关于retained messages的细节请看第八章。</p>\n<ul>\n<li>Payload</li>\n</ul>\n<p>这是消息的实际内容。内容可能包含图像、任何编码方式的文字、加密数据或任何二进制数据。</p>\n<ul>\n<li>DUP flag</li>\n</ul>\n<p>这个标志表示这条消息是一个因为目标接受者没有确认原始消息而重传的复制数据。这个标志只有在 Qos 大于0时生效。通常，复制和重传的机制被MQTT客户端库或者broker实现。更多相关消息请看第六章。 <br/><br>当一个客户端向MQTT broker发布一条消息。broker读取并确认消息(取决于Qos级别)，然后处理消息。处理的过程包括确认哪些客户端订阅了当前主题，并将消息发送给他们。<br><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/publish_flow.png\"></p>\n<p>客户端发布消息时只关心将消息发送给broker的过程。当broker接收到被发布的消息，由broker负责将消息传递给所有的订阅者。发布消息的客户端不会知道是否有其他客户端对这条消息感兴趣，也不会知道有多少客户端从broker收到了这条消息。</p>\n<h3 id=\"订阅-Subscribe\"><a href=\"#订阅-Subscribe\" class=\"headerlink\" title=\"订阅(Subscribe)\"></a>订阅(Subscribe)</h3><p>在没有任何人订阅(即没有任何客户端订阅相关话题)的情况下发布消息是无意义的。客户端通过发送一条订阅消息给broker来接收感兴趣的消息。订阅消息的格式非常简单，包含了一个唯一数据包ID和一个订阅话题列表。<br><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/subscribe_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。</p>\n<ul>\n<li>List of Subscriptions</li>\n</ul>\n<p>一条订阅消息可以包含多条订阅。每条订阅由Topic和Qos级别组成。订阅消息中的Topic可以包含通配符，这样可以匹配一类Topic而不是某个特定的Topic。如果某个客户端重复订阅了一个Topic，broker会按照其中Qos级别最高的一条来处理对应的消息。</p>\n<h3 id=\"Suback\"><a href=\"#Suback\" class=\"headerlink\" title=\"Suback\"></a>Suback</h3><p>为了确认每一条订阅消息，broker会回复一个SUBACK消息给客户端。这条消息包含着对应的订阅消息的数据包ID，和一系列的返回码。<br><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/suback_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。和订阅消息中的ID一致。</p>\n<ul>\n<li>Return Code</li>\n</ul>\n<p>broker为在订阅消息中收到的每一个 Topic/Qos 对返回一个结果码。 例如，如果订阅消息包含5个订阅，则SUBACK消息包含5个结果码。结果码确认每一个Topic并且返回被broker使用的Qos级别。如果broker拒绝了某个订阅，SUBACK消息会包含一个代表失败的结果码给对应的订阅。例如客户端没有足够的权限去订阅某个Topic。</p>\n<p><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/return_code.png\"></p>\n<p><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/subscribe_flow.png\"></p>\n<p>在客户端成功的发送一条SUBSCRIBE消息，并且收到SUBACK消息之后。客户端会收到被订阅的话题下的每一条消息。</p>\n<h3 id=\"取消订阅-Unsubscribe\"><a href=\"#取消订阅-Unsubscribe\" class=\"headerlink\" title=\"取消订阅(Unsubscribe)\"></a>取消订阅(Unsubscribe)</h3><p>和订阅(Subscribe)消息对应的是取消订阅(Unsubscribe)消息。这条消息为客户端删除一个订阅。取消订阅消息和订阅消息类似，包含一个数据包ID和一系列Topic。</p>\n<p><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/unsubscribe_packet.png\"></p>\n<ul>\n<li>Packet Identifier</li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。客户端程序库或者broker负责设置这个MQTT内部的识别ID。</p>\n<ul>\n<li>List of Topic</li>\n</ul>\n<p>话题列表可以包含多个客户端想要取消订阅的Topic。只需要发送Topic，不需要Qos。broker不管当前Topic属于什么Qos级别，都会为客户端取消对某个Topic的订阅。</p>\n<h3 id=\"Unsunack\"><a href=\"#Unsunack\" class=\"headerlink\" title=\"Unsunack\"></a>Unsunack</h3><p>为了确认取消订阅消息，broker会发送一个UNSUBACK的确认消息给客户端。这条消息只包含着取消订阅消息的数据包ID(为了明确当前消息对应的取消订阅消息)。</p>\n<p><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/unsuback_packet.png\"></p>\n<ul>\n<li>Packet Identifier </li>\n</ul>\n<p>数据包ID是客户端和broker之间消息的唯一识别码。之前提到过，这个ID和UNSUBSCRIBE消息中的ID相等。</p>\n<p><img src=\"/2022/02/17/MQTT%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E5%9B%9B-%E5%8F%91%E5%B8%83%E3%80%81%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/unsubscribe_flow.png\"></p>\n<p>当客户端从broker收到UNSUBACK消息后，客户端可以认为在UNSUBSCRIBE消息中包含的订阅已经被删除了。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>第四章的内容已经结束了，希望你有所收获。在下一章中我们将深入了解MQTT Topic的使用方法。 包括Topic的基础知识、如何使用通配符，并且会提供大量的例子。</p>"},{"title":"ProtoBuf为什么比Json快","date":"2021-12-01T14:52:45.000Z","_content":"> Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. \n<!--more-->\nProtocol buffers是Google为了序列结构化数据开发的语言无关、平台无关、可拓展的机制。类似XML，但是更小，更快，更简单。\n> JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write.\n\nJSON是一个易于读写的轻量数据交换格式。\n\n## 从一个简单的例子开始\n一份Json数据以及对应的二进制数据\n```\n{\n    \"name\":\"Mike\",\n    \"age\":29,\n    \"sex\":true,\n    \"phone\":\"A123456\"\n}\n\nbytes size: 60\n7b 22 6e 61 6d 65 22 3a\n20 22 4d 69 6b 65 22 2c\n20 22 61 67 65 22 3a 20\n32 39 2c 20 22 73 65 78\n22 3a 20 74 72 75 65 2c\n20 22 70 68 6f 6e 65 22\n3a 20 22 41 31 32 33 34\n35 36 22 7d\n```\n使用类似的.proto定义生成对应的二进制数据\n```\n//user.proto\nsyntax = \"proto3\";\nmessage UserInfo {\n  string name = 1;\n  int32 age = 2;\n  bool sex = 3;\n  string phone = 4;\n}\n\n//python code snippet\ndef print_protobuf():\n    user = user_pb2.UserInfo()\n    user.name = \"Mike\"\n    user.age = 29\n    user.sex = True\n    user.phone = \"A123456\"\n    print_hex(user.SerializeToString())\n\nbytes size: 19\n0a 04 4d 69 6b 65 10 1d\n18 01 22 07 41 31 32 33\n34 35 36\n```\n\n可以看到，在这个例子中，为了传输同样的数据，使用Protobuf生成的数据量是使用Json时的三分之一。Json对应的二进制数据非常简单，每个字符由ASCII码表示，总计60个字符，每个字符一个字节，二进制数据总计60字节。而由protobuf生成的二进制数据就比较难懂了，为什么只用19个字节便可以表示相同的数据了呢？\n\n## Protobuf 编码方式\n\n内容参考Google的[官方文档](https://developers.google.com/protocol-buffers/docs/encoding)\n\n### Varint\n一个unsigned int32类型的变量占用4个字节，可以表示的数字范围是 0 到 2^32 (4,294,967,295)。在实际的场景中，小数字的使用频率是远大于大数字的使用频率的。这样，在存储中就会浪费掉一部分空间。 例如数字255的二进制小端表示中，后三个字节被浪费。\n```\n01111111 00000000 00000000 00000000\n         --------------------------\n```\n针对这种情况，提出了一种优化的方案 即varints, varints 是一种用一个或多个字节序列化整型数的方法。可以根据存储数据的大小动态的决定一个整型数占用的空间。 <br/>\n在varint的每一个字节中的最高位被设置为msg(most significant bit)，当msb为1表示下一字节还是属于当前数据，为0则表示当前字节为此数据的最后一个字节。每个字节的低7位用7位一组存储数字的二进制补码， 最低有效组在前，即数据字节为小端序。一些例子\n```\n1 -> 0 0000001\n\n255 -> 0 1111111\n\n256 -> 1 0000000  0 0000001 -> 0000001 0000000 -> 256\n\n300 -> 1 0101100  0 0000010 -> 0000010 0101100 -> 256 + 32 + 8 + 4 = 300\n```\n这样，当使用一个varint来表示unsigned int32类型整形数时，所占字节数会根据数字大小动态的改变。\n```\n0 <= x < (2^8 - 1)       1 bit\n2^8 <= x < (2^15 - 1)    2 bit\n2^15 <= x < (2^22 - 1)   3 bit\n2^22 <= x < (2^29 - 1)   4 bit\n2^29 <= x <= (2^32)      5 bit\n```\n### 消息结构\n一条protocol buffer消息是一系列的键值对。与Json格式数据的区别是，二进制版protocol buffer数据中使用field's number来作为key值，而最初定义的key值如需要在解码完成后通过定义文件来确定。<br/>\n当一条消息被编码时，key值和value被整合进字节流中。在protobuf中，key值是一个varint数，其中包含了两部分内容，第一部分是.proto文件中定义的每个key值对应的field number，第二部分是类型信息，用来确定value值的长度。可用的类型有以下几种\n![](wire_types.png)\nkey值的组织方式为:\n```\n(field_number << 3) | wire_type\n\n//即最后3bit数代表类型 例如上述例子中protobuf二进制数据的第一个字节0a代表的含义:\n0   0001              010\n-   ----              ---\nmsb fieldnumber = 1   type = 2\n```\n### Strings\n当一个k-v对的类型字段为2，即(length-delimited)时，在key值之后会紧跟一个varint值，来表示value的长度。\n\n## 解析数据\n现在我们回头来看例子中产生的二进制数据\n```\n0a 04 4d 69 6b 65\n0a -> 0 0001 010 -> field = 1, type = 2\n04 -> value length = 4\n4d -> M\n69 -> i\n6b -> k\n65 -> e\n\n10 1d \n0 0010 000 -> field = 2, type = 0\n00011101  -> 29\n\n18 01\n0 0011 000 -> field = 3, type = 0\n01 -> true\n\n22 07 41 31 32 33 34 35 36\n0 0100 010 -> field = 4, type = 2\n07 -> value length = 7\n41 31 32 33 34 35 36 -> \"A123456\"\n```\n到此，便可以理解这个简单例子中protobuf的二进制数据是如何组织的了。对于题目提出的问题，也有了一个初步的回答。\n- 使用varint类型，在使用较小数字更频繁的场景中，更加节省空间。Json中数字按字符串存储，有多少位数就要占用多少bit空间，如例子中 29 被存储为 32 39。示例中节省1字节。\n- bool类型值占用1字节。示例中节省3字节。\n- 不需要存储类似 {、\"、 }、 space 等冗余的字符。例子中Json二进制数据总计有28个冗余字符。\n- key值为一个varint类型数，通常只占1个字节。例子中Protobuf二进制数据 key值总计6字节，json中15字节。\n- 60(json bytes size) - 19(protobuf bytes size) = 1 + 3 + 28 + (15 - 6)\n\n## 初探protobuf源码\n如果有用过protobuf的话，一定对protoc不陌生。他是protocol编译器，用来编译含有消息定义的.proto文件。这个编译器提供一个很有意思的功能\n```\n$ protoc | grep decode_raw -A4\n  --decode_raw                Read an arbitrary protocol message from\n                              standard input and write the raw tag/value\n                              pairs in text format to standard output.  No\n                              PROTO_FILES should be given when using this\n                              flag.\n```\n即在不需要.proto定义文件的情况下，从标准输入读取任意的protocol消息，然后把他们以 tag/value 的文字格式打印到标准输出。后续内容都围绕这个功能来展开。<br/>\n先拿个稍微复杂一点的例子尝试一下\n```\n// .proto定义文件\n$ cat user.proto                      \nsyntax = \"proto3\";                    \n                                      \nmessage UserInfo {                    \n  string name = 1;                    \n  int32 age = 2;                      \n  bool sex = 3;                       \n  string phone = 4;                   \n}                                     \n                                      \nmessage AddressBook {                 \n  string email = 1;                   \n  string phone = 2;                   \n  string twitter = 3;                 \n}                                     \nmessage Location {                    \n  string state = 1;                   \n  int32 longitude = 2;                \n  int32 latitude = 3;                 \n  AddressBook contact = 4;            \n}                                     \n                                      \nmessage Company {                     \n  string name = 1;                    \n  repeated UserInfo legal_person = 2; \n  fixed32 tel = 3;                    \n  fixed64 fund = 4;                   \n  Location location = 5;              \n  bytes checksum = 6;                 \n  repeated int32 int_array = 7;       \n}\n```\n```\n// python 生成数据的代码段\nuser = user_pb2.UserInfo()\nuser.name = \"Mike\"\nuser.age = 29\nuser.sex = True\nuser.phone = \"A123456\"\nuser1 = user_pb2.UserInfo()\nuser1.name = \"Amy\"\nuser1.age = 25\nuser1.sex = False\nuser1.phone = \"A654321\"\naddressbook = user_pb2.AddressBook()\naddressbook.email = \"haha@qq.com\"\naddressbook.phone = \"A123456\"\naddressbook.twitter = \"dalala\"\nlocation = user_pb2.Location()\nlocation.state = \"China\"\nlocation.longitude = 123\nlocation.latitude = 456\nlocation.contact.CopyFrom(addressbook)\ncompany = user_pb2.Company()\ncompany.name = \"Baidu\"\ncompany.tel = 123456789\ncompany.legal_person.extend([user, user1])\ncompany.fund = 100000000000000\ncompany.location.CopyFrom(location)\ncompany.checksum = bytes([0xff, 0xf2, 0x12, 0xf4, 0x34])\ncompany.int_array.extend([1, 2, 3, 4, 5, 6])\nprint(\"protobuf:\", company.SerializeToString())\nfile = open(\"protobuf.bin\", \"wb\")\nfile.write(bytearray(company.SerializeToString()))\nfile.close()\n```\n```\n// 试一下~\n$ protoc --decode_raw < protobuf.bin\n1: \"Baidu\"\n2 {\n  1: \"Mike\"\n  2: 29\n  3: 1\n  4: \"A123456\"\n}\n2 {\n  1: \"Amy\"\n  2: 25\n  4: \"A654321\"\n}\n3: 0x075bcd15\n4: 0x00005af3107a4000\n5 {\n  1: \"China\"\n  2: 123\n  3: 456\n  4 {\n    1: \"haha@qq.com\"\n    2: \"A123456\"\n    3: \"dalala\"\n  }\n}\n6: \"\\377\\362\\022\\3644\"\n7: \"\\001\\002\\003\\004\\005\\006\"\n```\n\n恰好，protoc这个程序的代码是开源的，所以为了弄懂这个功能是如何实现的，按照[构建文档](https://github.com/protocolbuffers/protobuf/tree/master/cmake)来,得到一个有源码,可调试的protoc程序。\n![](debug_protoc.png)\n然后修改程序的运行时参数，添加decode_raw参数、并将一个样例二进制文件作为标准输入。 这样，就可以愉快的单步调试，找到对应部分的代码了。 解析二进制数据核心代码的起始部分调用栈如下:\n\n                                                                                                                                          \n```                                                                                                                                       \n1   google::protobuf::internal::WireFormat::_InternalParse                                  wire_format.cc            792  0x7ff77988e084 \n2   google::protobuf::Message::_InternalParse                                               message.cc                167  0x7ff779841a8c \n3   google::protobuf::internal::MergeFromImpl<0>                                            message_lite.cc           159  0x7ff7796b9346 \n4   google::protobuf::MessageLite::ParseFrom<3,google::protobuf::io::ZeroCopyInputStream *> message_lite.h            552  0x7ff7796b99e7 \n5   google::protobuf::MessageLite::ParsePartialFromZeroCopyStream                           message_lite.cc           267  0x7ff7796b59d2 \n6   google::protobuf::compiler::CommandLineInterface::EncodeOrDecode                        command_line_interface.cc 2384 0x7ff7794a0ecd \n7   google::protobuf::compiler::CommandLineInterface::Run                                   command_line_interface.cc 1121 0x7ff77949b251 \n8   google::protobuf::compiler::ProtobufMain                                                main.cc                   104  0x7ff7794349b8 \n9   main                                                                                    main.cc                   113  0x7ff779434aaf \n10  invoke_main                                                                             exe_common.inl            79   0x7ff7799723e9 \n```\n\n### 一些代码片段\n```\n//获取包含field_number和 wire_type的key值\n\n// Same as ParseVarint but only accept 5 bytes at most.\ninline const char* ReadTag(const char* p, uint32_t* out,\n                           uint32_t /*max_tag*/ = 0) {\n  uint32_t res = static_cast<uint8_t>(p[0]);\n  if (res < 128) {\n    *out = res;\n    return p + 1;\n  }\n  uint32_t second = static_cast<uint8_t>(p[1]);\n  res += (second - 1) << 7;         \n  if (second < 128) {\n    *out = res;\n    return p + 2;\n  }\n  auto tmp = ReadTagFallback(p, res);\n  *out = tmp.second;\n  return tmp.first;\n}\n\nstd::pair<const char*, uint32_t> ReadTagFallback(const char* p, uint32_t res) {\n  for (std::uint32_t i = 2; i < 5; i++) {\n    uint32_t byte = static_cast<uint8_t>(p[i]);\n    res += (byte - 1) << (7 * i);\n    if (PROTOBUF_PREDICT_TRUE(byte < 128)) {\n      return {p + i + 1, res};\n    }\n  }\n  return {nullptr, 0};\n}\n```\n\n这里是protobuf源码中读取varint的方法，因为varint的字节序是小端序，按索引顺序读取字节，若当前字节小于128，即最高位为0，则完成读取，返回结果。否则最高位为1，表示下一字节仍然属于当前值，则读取下一字节。<br/>\n当第一个字节大于128时，读取第二个字节， 结果值的计算方式为: res += (second - 1) << 7;  这里减1减掉的其实是第一个字节中的msg(most significant bit)，等同于res = (res - 128) + (second << 7)。\n当varint长度大于2时，计算方法一般化为 res += (byte - 1) << (7 * i)。 \n\n\n``` \n// 获取field字段\n\nstatic constexpr int kTagTypeBits = 3;\n\ninline int WireFormatLite::GetTagFieldNumber(uint32_t tag) {\n  return static_cast<int>(tag >> kTagTypeBits);\n}\n```\n\n\n```\n//  读取Varint值\ntemplate <typename T>\nconst char* VarintParse(const char* p, T* out) {\n  auto ptr = reinterpret_cast<const uint8_t*>(p);\n  uint32_t res = ptr[0];\n  if (!(res & 0x80)) {\n    *out = res;\n    return p + 1;\n  }\n  uint32_t byte = ptr[1];\n  res += (byte - 1) << 7;\n  if (!(byte & 0x80)) {\n    *out = res;\n    return p + 2;\n  }\n  return VarintParseSlow(p, res, out);\n}\n\ninline const char* VarintParseSlow(const char* p, uint32_t res, uint64_t* out) {\n  auto tmp = VarintParseSlow64(p, res);\n  *out = tmp.second;\n  return tmp.first;\n}\n\nstd::pair<const char*, uint64_t> VarintParseSlow64(const char* p,\n                                                   uint32_t res32) {\n  uint64_t res = res32;\n  for (std::uint32_t i = 2; i < 10; i++) {\n    uint64_t byte = static_cast<uint8_t>(p[i]);\n    res += (byte - 1) << (7 * i);\n    if (PROTOBUF_PREDICT_TRUE(byte < 128)) {\n      return {p + i + 1, res};\n    }\n  }\n  return {nullptr, 0};\n}\n\n```\n\n### 小练习\n这个功能的实现中，大部分类型数据的解析只需要按照常规的方式顺序解释二进制数据就好了(例如 Varint、64-bit、32-bit)。 主要的问题在于对Length-delimited类型数据的解析，在没有.proto定义的情况下，是无法确定一段二进制数据究竟是 embedded messages类型 还是 string\\bytes类型的。 源码中大概的步骤是:\n- 第一步顺序读取字节流，按对应规则解释二进制数据，存入一个UnknownFieldSet的结构中。在第一步中对于Length-delimited数据具体是什么类型不做判断和区分。\n- 第二步打印UnknownFieldSet数据。打印的过程中，对于Length-delimited类型的数据会首先尝试以embedded messages的方式解析这段二进制数据，如果解析成功,则按照embedded messages来解析和打印，否则则按照utf-8编码的string类型来打印。\n\n为了验证一下对这部分代码的理解，顺带练习一下python, 用python重新实现了一遍这个小功能。基本实现了 protoc --decode_raw 这个命令的功能(可能会有bug)，另外对string/bytes类型数据做了区分、把普通的repeated elements放在了一个数组里。代码总共不到三百行，对于这个功能具体实现细节感兴趣的同学可以拿来玩一玩。代码放在github上: [protobuf_decoder](https://github.com/liujianfengv/protobuf_decoder)\n```\n// 拿同样的数据试下\n$ python protobuf_decoder.py example/protobuf.bin\n{\n    \"1\": \"Baidu\",\n    \"2\": [\n        {\n            \"1\": \"Mike\",\n            \"2\": 29,\n            \"3\": 1,\n            \"4\": \"A123456\"\n        },\n        {\n            \"1\": \"Amy\",\n            \"2\": 25,\n            \"4\": \"A654321\"\n        }\n    ],\n    \"3\": 123456789,\n    \"4\": 100000000000000,\n    \"5\": {\n        \"1\": \"China\",\n        \"2\": 123,\n        \"3\": 456,\n        \"4\": {\n            \"1\": \"haha@qq.com\",\n            \"2\": \"A123456\",\n            \"3\": \"dalala\"\n        }\n    },\n    \"6\": \"ff f2 12 f4 34\",\n    \"7\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\"\n}\n```\n\n## 相关源码\n- [protobuf_decoder](https://github.com/liujianfengv/protobuf_decoder)\n\n## 参考链接\n- [Encoding | Protocol Buffers | Google Developers](https://developers.google.com/protocol-buffers/docs/encoding)\n- [protocolbuffers / protobuf](https://github.com/protocolbuffers/protobuf)","source":"_posts/ProtoBuf为什么比Json快.md","raw":"---\ntitle: ProtoBuf为什么比Json快\ndate: 2021-12-01 22:52:45\ntags: Protobuf\n---\n> Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. \n<!--more-->\nProtocol buffers是Google为了序列结构化数据开发的语言无关、平台无关、可拓展的机制。类似XML，但是更小，更快，更简单。\n> JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write.\n\nJSON是一个易于读写的轻量数据交换格式。\n\n## 从一个简单的例子开始\n一份Json数据以及对应的二进制数据\n```\n{\n    \"name\":\"Mike\",\n    \"age\":29,\n    \"sex\":true,\n    \"phone\":\"A123456\"\n}\n\nbytes size: 60\n7b 22 6e 61 6d 65 22 3a\n20 22 4d 69 6b 65 22 2c\n20 22 61 67 65 22 3a 20\n32 39 2c 20 22 73 65 78\n22 3a 20 74 72 75 65 2c\n20 22 70 68 6f 6e 65 22\n3a 20 22 41 31 32 33 34\n35 36 22 7d\n```\n使用类似的.proto定义生成对应的二进制数据\n```\n//user.proto\nsyntax = \"proto3\";\nmessage UserInfo {\n  string name = 1;\n  int32 age = 2;\n  bool sex = 3;\n  string phone = 4;\n}\n\n//python code snippet\ndef print_protobuf():\n    user = user_pb2.UserInfo()\n    user.name = \"Mike\"\n    user.age = 29\n    user.sex = True\n    user.phone = \"A123456\"\n    print_hex(user.SerializeToString())\n\nbytes size: 19\n0a 04 4d 69 6b 65 10 1d\n18 01 22 07 41 31 32 33\n34 35 36\n```\n\n可以看到，在这个例子中，为了传输同样的数据，使用Protobuf生成的数据量是使用Json时的三分之一。Json对应的二进制数据非常简单，每个字符由ASCII码表示，总计60个字符，每个字符一个字节，二进制数据总计60字节。而由protobuf生成的二进制数据就比较难懂了，为什么只用19个字节便可以表示相同的数据了呢？\n\n## Protobuf 编码方式\n\n内容参考Google的[官方文档](https://developers.google.com/protocol-buffers/docs/encoding)\n\n### Varint\n一个unsigned int32类型的变量占用4个字节，可以表示的数字范围是 0 到 2^32 (4,294,967,295)。在实际的场景中，小数字的使用频率是远大于大数字的使用频率的。这样，在存储中就会浪费掉一部分空间。 例如数字255的二进制小端表示中，后三个字节被浪费。\n```\n01111111 00000000 00000000 00000000\n         --------------------------\n```\n针对这种情况，提出了一种优化的方案 即varints, varints 是一种用一个或多个字节序列化整型数的方法。可以根据存储数据的大小动态的决定一个整型数占用的空间。 <br/>\n在varint的每一个字节中的最高位被设置为msg(most significant bit)，当msb为1表示下一字节还是属于当前数据，为0则表示当前字节为此数据的最后一个字节。每个字节的低7位用7位一组存储数字的二进制补码， 最低有效组在前，即数据字节为小端序。一些例子\n```\n1 -> 0 0000001\n\n255 -> 0 1111111\n\n256 -> 1 0000000  0 0000001 -> 0000001 0000000 -> 256\n\n300 -> 1 0101100  0 0000010 -> 0000010 0101100 -> 256 + 32 + 8 + 4 = 300\n```\n这样，当使用一个varint来表示unsigned int32类型整形数时，所占字节数会根据数字大小动态的改变。\n```\n0 <= x < (2^8 - 1)       1 bit\n2^8 <= x < (2^15 - 1)    2 bit\n2^15 <= x < (2^22 - 1)   3 bit\n2^22 <= x < (2^29 - 1)   4 bit\n2^29 <= x <= (2^32)      5 bit\n```\n### 消息结构\n一条protocol buffer消息是一系列的键值对。与Json格式数据的区别是，二进制版protocol buffer数据中使用field's number来作为key值，而最初定义的key值如需要在解码完成后通过定义文件来确定。<br/>\n当一条消息被编码时，key值和value被整合进字节流中。在protobuf中，key值是一个varint数，其中包含了两部分内容，第一部分是.proto文件中定义的每个key值对应的field number，第二部分是类型信息，用来确定value值的长度。可用的类型有以下几种\n![](wire_types.png)\nkey值的组织方式为:\n```\n(field_number << 3) | wire_type\n\n//即最后3bit数代表类型 例如上述例子中protobuf二进制数据的第一个字节0a代表的含义:\n0   0001              010\n-   ----              ---\nmsb fieldnumber = 1   type = 2\n```\n### Strings\n当一个k-v对的类型字段为2，即(length-delimited)时，在key值之后会紧跟一个varint值，来表示value的长度。\n\n## 解析数据\n现在我们回头来看例子中产生的二进制数据\n```\n0a 04 4d 69 6b 65\n0a -> 0 0001 010 -> field = 1, type = 2\n04 -> value length = 4\n4d -> M\n69 -> i\n6b -> k\n65 -> e\n\n10 1d \n0 0010 000 -> field = 2, type = 0\n00011101  -> 29\n\n18 01\n0 0011 000 -> field = 3, type = 0\n01 -> true\n\n22 07 41 31 32 33 34 35 36\n0 0100 010 -> field = 4, type = 2\n07 -> value length = 7\n41 31 32 33 34 35 36 -> \"A123456\"\n```\n到此，便可以理解这个简单例子中protobuf的二进制数据是如何组织的了。对于题目提出的问题，也有了一个初步的回答。\n- 使用varint类型，在使用较小数字更频繁的场景中，更加节省空间。Json中数字按字符串存储，有多少位数就要占用多少bit空间，如例子中 29 被存储为 32 39。示例中节省1字节。\n- bool类型值占用1字节。示例中节省3字节。\n- 不需要存储类似 {、\"、 }、 space 等冗余的字符。例子中Json二进制数据总计有28个冗余字符。\n- key值为一个varint类型数，通常只占1个字节。例子中Protobuf二进制数据 key值总计6字节，json中15字节。\n- 60(json bytes size) - 19(protobuf bytes size) = 1 + 3 + 28 + (15 - 6)\n\n## 初探protobuf源码\n如果有用过protobuf的话，一定对protoc不陌生。他是protocol编译器，用来编译含有消息定义的.proto文件。这个编译器提供一个很有意思的功能\n```\n$ protoc | grep decode_raw -A4\n  --decode_raw                Read an arbitrary protocol message from\n                              standard input and write the raw tag/value\n                              pairs in text format to standard output.  No\n                              PROTO_FILES should be given when using this\n                              flag.\n```\n即在不需要.proto定义文件的情况下，从标准输入读取任意的protocol消息，然后把他们以 tag/value 的文字格式打印到标准输出。后续内容都围绕这个功能来展开。<br/>\n先拿个稍微复杂一点的例子尝试一下\n```\n// .proto定义文件\n$ cat user.proto                      \nsyntax = \"proto3\";                    \n                                      \nmessage UserInfo {                    \n  string name = 1;                    \n  int32 age = 2;                      \n  bool sex = 3;                       \n  string phone = 4;                   \n}                                     \n                                      \nmessage AddressBook {                 \n  string email = 1;                   \n  string phone = 2;                   \n  string twitter = 3;                 \n}                                     \nmessage Location {                    \n  string state = 1;                   \n  int32 longitude = 2;                \n  int32 latitude = 3;                 \n  AddressBook contact = 4;            \n}                                     \n                                      \nmessage Company {                     \n  string name = 1;                    \n  repeated UserInfo legal_person = 2; \n  fixed32 tel = 3;                    \n  fixed64 fund = 4;                   \n  Location location = 5;              \n  bytes checksum = 6;                 \n  repeated int32 int_array = 7;       \n}\n```\n```\n// python 生成数据的代码段\nuser = user_pb2.UserInfo()\nuser.name = \"Mike\"\nuser.age = 29\nuser.sex = True\nuser.phone = \"A123456\"\nuser1 = user_pb2.UserInfo()\nuser1.name = \"Amy\"\nuser1.age = 25\nuser1.sex = False\nuser1.phone = \"A654321\"\naddressbook = user_pb2.AddressBook()\naddressbook.email = \"haha@qq.com\"\naddressbook.phone = \"A123456\"\naddressbook.twitter = \"dalala\"\nlocation = user_pb2.Location()\nlocation.state = \"China\"\nlocation.longitude = 123\nlocation.latitude = 456\nlocation.contact.CopyFrom(addressbook)\ncompany = user_pb2.Company()\ncompany.name = \"Baidu\"\ncompany.tel = 123456789\ncompany.legal_person.extend([user, user1])\ncompany.fund = 100000000000000\ncompany.location.CopyFrom(location)\ncompany.checksum = bytes([0xff, 0xf2, 0x12, 0xf4, 0x34])\ncompany.int_array.extend([1, 2, 3, 4, 5, 6])\nprint(\"protobuf:\", company.SerializeToString())\nfile = open(\"protobuf.bin\", \"wb\")\nfile.write(bytearray(company.SerializeToString()))\nfile.close()\n```\n```\n// 试一下~\n$ protoc --decode_raw < protobuf.bin\n1: \"Baidu\"\n2 {\n  1: \"Mike\"\n  2: 29\n  3: 1\n  4: \"A123456\"\n}\n2 {\n  1: \"Amy\"\n  2: 25\n  4: \"A654321\"\n}\n3: 0x075bcd15\n4: 0x00005af3107a4000\n5 {\n  1: \"China\"\n  2: 123\n  3: 456\n  4 {\n    1: \"haha@qq.com\"\n    2: \"A123456\"\n    3: \"dalala\"\n  }\n}\n6: \"\\377\\362\\022\\3644\"\n7: \"\\001\\002\\003\\004\\005\\006\"\n```\n\n恰好，protoc这个程序的代码是开源的，所以为了弄懂这个功能是如何实现的，按照[构建文档](https://github.com/protocolbuffers/protobuf/tree/master/cmake)来,得到一个有源码,可调试的protoc程序。\n![](debug_protoc.png)\n然后修改程序的运行时参数，添加decode_raw参数、并将一个样例二进制文件作为标准输入。 这样，就可以愉快的单步调试，找到对应部分的代码了。 解析二进制数据核心代码的起始部分调用栈如下:\n\n                                                                                                                                          \n```                                                                                                                                       \n1   google::protobuf::internal::WireFormat::_InternalParse                                  wire_format.cc            792  0x7ff77988e084 \n2   google::protobuf::Message::_InternalParse                                               message.cc                167  0x7ff779841a8c \n3   google::protobuf::internal::MergeFromImpl<0>                                            message_lite.cc           159  0x7ff7796b9346 \n4   google::protobuf::MessageLite::ParseFrom<3,google::protobuf::io::ZeroCopyInputStream *> message_lite.h            552  0x7ff7796b99e7 \n5   google::protobuf::MessageLite::ParsePartialFromZeroCopyStream                           message_lite.cc           267  0x7ff7796b59d2 \n6   google::protobuf::compiler::CommandLineInterface::EncodeOrDecode                        command_line_interface.cc 2384 0x7ff7794a0ecd \n7   google::protobuf::compiler::CommandLineInterface::Run                                   command_line_interface.cc 1121 0x7ff77949b251 \n8   google::protobuf::compiler::ProtobufMain                                                main.cc                   104  0x7ff7794349b8 \n9   main                                                                                    main.cc                   113  0x7ff779434aaf \n10  invoke_main                                                                             exe_common.inl            79   0x7ff7799723e9 \n```\n\n### 一些代码片段\n```\n//获取包含field_number和 wire_type的key值\n\n// Same as ParseVarint but only accept 5 bytes at most.\ninline const char* ReadTag(const char* p, uint32_t* out,\n                           uint32_t /*max_tag*/ = 0) {\n  uint32_t res = static_cast<uint8_t>(p[0]);\n  if (res < 128) {\n    *out = res;\n    return p + 1;\n  }\n  uint32_t second = static_cast<uint8_t>(p[1]);\n  res += (second - 1) << 7;         \n  if (second < 128) {\n    *out = res;\n    return p + 2;\n  }\n  auto tmp = ReadTagFallback(p, res);\n  *out = tmp.second;\n  return tmp.first;\n}\n\nstd::pair<const char*, uint32_t> ReadTagFallback(const char* p, uint32_t res) {\n  for (std::uint32_t i = 2; i < 5; i++) {\n    uint32_t byte = static_cast<uint8_t>(p[i]);\n    res += (byte - 1) << (7 * i);\n    if (PROTOBUF_PREDICT_TRUE(byte < 128)) {\n      return {p + i + 1, res};\n    }\n  }\n  return {nullptr, 0};\n}\n```\n\n这里是protobuf源码中读取varint的方法，因为varint的字节序是小端序，按索引顺序读取字节，若当前字节小于128，即最高位为0，则完成读取，返回结果。否则最高位为1，表示下一字节仍然属于当前值，则读取下一字节。<br/>\n当第一个字节大于128时，读取第二个字节， 结果值的计算方式为: res += (second - 1) << 7;  这里减1减掉的其实是第一个字节中的msg(most significant bit)，等同于res = (res - 128) + (second << 7)。\n当varint长度大于2时，计算方法一般化为 res += (byte - 1) << (7 * i)。 \n\n\n``` \n// 获取field字段\n\nstatic constexpr int kTagTypeBits = 3;\n\ninline int WireFormatLite::GetTagFieldNumber(uint32_t tag) {\n  return static_cast<int>(tag >> kTagTypeBits);\n}\n```\n\n\n```\n//  读取Varint值\ntemplate <typename T>\nconst char* VarintParse(const char* p, T* out) {\n  auto ptr = reinterpret_cast<const uint8_t*>(p);\n  uint32_t res = ptr[0];\n  if (!(res & 0x80)) {\n    *out = res;\n    return p + 1;\n  }\n  uint32_t byte = ptr[1];\n  res += (byte - 1) << 7;\n  if (!(byte & 0x80)) {\n    *out = res;\n    return p + 2;\n  }\n  return VarintParseSlow(p, res, out);\n}\n\ninline const char* VarintParseSlow(const char* p, uint32_t res, uint64_t* out) {\n  auto tmp = VarintParseSlow64(p, res);\n  *out = tmp.second;\n  return tmp.first;\n}\n\nstd::pair<const char*, uint64_t> VarintParseSlow64(const char* p,\n                                                   uint32_t res32) {\n  uint64_t res = res32;\n  for (std::uint32_t i = 2; i < 10; i++) {\n    uint64_t byte = static_cast<uint8_t>(p[i]);\n    res += (byte - 1) << (7 * i);\n    if (PROTOBUF_PREDICT_TRUE(byte < 128)) {\n      return {p + i + 1, res};\n    }\n  }\n  return {nullptr, 0};\n}\n\n```\n\n### 小练习\n这个功能的实现中，大部分类型数据的解析只需要按照常规的方式顺序解释二进制数据就好了(例如 Varint、64-bit、32-bit)。 主要的问题在于对Length-delimited类型数据的解析，在没有.proto定义的情况下，是无法确定一段二进制数据究竟是 embedded messages类型 还是 string\\bytes类型的。 源码中大概的步骤是:\n- 第一步顺序读取字节流，按对应规则解释二进制数据，存入一个UnknownFieldSet的结构中。在第一步中对于Length-delimited数据具体是什么类型不做判断和区分。\n- 第二步打印UnknownFieldSet数据。打印的过程中，对于Length-delimited类型的数据会首先尝试以embedded messages的方式解析这段二进制数据，如果解析成功,则按照embedded messages来解析和打印，否则则按照utf-8编码的string类型来打印。\n\n为了验证一下对这部分代码的理解，顺带练习一下python, 用python重新实现了一遍这个小功能。基本实现了 protoc --decode_raw 这个命令的功能(可能会有bug)，另外对string/bytes类型数据做了区分、把普通的repeated elements放在了一个数组里。代码总共不到三百行，对于这个功能具体实现细节感兴趣的同学可以拿来玩一玩。代码放在github上: [protobuf_decoder](https://github.com/liujianfengv/protobuf_decoder)\n```\n// 拿同样的数据试下\n$ python protobuf_decoder.py example/protobuf.bin\n{\n    \"1\": \"Baidu\",\n    \"2\": [\n        {\n            \"1\": \"Mike\",\n            \"2\": 29,\n            \"3\": 1,\n            \"4\": \"A123456\"\n        },\n        {\n            \"1\": \"Amy\",\n            \"2\": 25,\n            \"4\": \"A654321\"\n        }\n    ],\n    \"3\": 123456789,\n    \"4\": 100000000000000,\n    \"5\": {\n        \"1\": \"China\",\n        \"2\": 123,\n        \"3\": 456,\n        \"4\": {\n            \"1\": \"haha@qq.com\",\n            \"2\": \"A123456\",\n            \"3\": \"dalala\"\n        }\n    },\n    \"6\": \"ff f2 12 f4 34\",\n    \"7\": \"\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\"\n}\n```\n\n## 相关源码\n- [protobuf_decoder](https://github.com/liujianfengv/protobuf_decoder)\n\n## 参考链接\n- [Encoding | Protocol Buffers | Google Developers](https://developers.google.com/protocol-buffers/docs/encoding)\n- [protocolbuffers / protobuf](https://github.com/protocolbuffers/protobuf)","slug":"ProtoBuf为什么比Json快","published":1,"updated":"2022-01-06T16:42:12.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0b4dtqb0009vsvi1dg84rek","content":"<blockquote>\n<p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. </p>\n</blockquote>\n<span id=\"more\"></span>\n<p>Protocol buffers是Google为了序列结构化数据开发的语言无关、平台无关、可拓展的机制。类似XML，但是更小，更快，更简单。</p>\n<blockquote>\n<p>JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write.</p>\n</blockquote>\n<p>JSON是一个易于读写的轻量数据交换格式。</p>\n<h2 id=\"从一个简单的例子开始\"><a href=\"#从一个简单的例子开始\" class=\"headerlink\" title=\"从一个简单的例子开始\"></a>从一个简单的例子开始</h2><p>一份Json数据以及对应的二进制数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;Mike&quot;,</span><br><span class=\"line\">    &quot;age&quot;:29,</span><br><span class=\"line\">    &quot;sex&quot;:true,</span><br><span class=\"line\">    &quot;phone&quot;:&quot;A123456&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bytes size: 60</span><br><span class=\"line\">7b 22 6e 61 6d 65 22 3a</span><br><span class=\"line\">20 22 4d 69 6b 65 22 2c</span><br><span class=\"line\">20 22 61 67 65 22 3a 20</span><br><span class=\"line\">32 39 2c 20 22 73 65 78</span><br><span class=\"line\">22 3a 20 74 72 75 65 2c</span><br><span class=\"line\">20 22 70 68 6f 6e 65 22</span><br><span class=\"line\">3a 20 22 41 31 32 33 34</span><br><span class=\"line\">35 36 22 7d</span><br></pre></td></tr></table></figure>\n<p>使用类似的.proto定义生成对应的二进制数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//user.proto</span><br><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\">message UserInfo &#123;</span><br><span class=\"line\">  string name = 1;</span><br><span class=\"line\">  int32 age = 2;</span><br><span class=\"line\">  bool sex = 3;</span><br><span class=\"line\">  string phone = 4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//python code snippet</span><br><span class=\"line\">def print_protobuf():</span><br><span class=\"line\">    user = user_pb2.UserInfo()</span><br><span class=\"line\">    user.name = &quot;Mike&quot;</span><br><span class=\"line\">    user.age = 29</span><br><span class=\"line\">    user.sex = True</span><br><span class=\"line\">    user.phone = &quot;A123456&quot;</span><br><span class=\"line\">    print_hex(user.SerializeToString())</span><br><span class=\"line\"></span><br><span class=\"line\">bytes size: 19</span><br><span class=\"line\">0a 04 4d 69 6b 65 10 1d</span><br><span class=\"line\">18 01 22 07 41 31 32 33</span><br><span class=\"line\">34 35 36</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个例子中，为了传输同样的数据，使用Protobuf生成的数据量是使用Json时的三分之一。Json对应的二进制数据非常简单，每个字符由ASCII码表示，总计60个字符，每个字符一个字节，二进制数据总计60字节。而由protobuf生成的二进制数据就比较难懂了，为什么只用19个字节便可以表示相同的数据了呢？</p>\n<h2 id=\"Protobuf-编码方式\"><a href=\"#Protobuf-编码方式\" class=\"headerlink\" title=\"Protobuf 编码方式\"></a>Protobuf 编码方式</h2><p>内容参考Google的<a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">官方文档</a></p>\n<h3 id=\"Varint\"><a href=\"#Varint\" class=\"headerlink\" title=\"Varint\"></a>Varint</h3><p>一个unsigned int32类型的变量占用4个字节，可以表示的数字范围是 0 到 2^32 (4,294,967,295)。在实际的场景中，小数字的使用频率是远大于大数字的使用频率的。这样，在存储中就会浪费掉一部分空间。 例如数字255的二进制小端表示中，后三个字节被浪费。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">01111111 00000000 00000000 00000000</span><br><span class=\"line\">         --------------------------</span><br></pre></td></tr></table></figure>\n<p>针对这种情况，提出了一种优化的方案 即varints, varints 是一种用一个或多个字节序列化整型数的方法。可以根据存储数据的大小动态的决定一个整型数占用的空间。 <br/><br>在varint的每一个字节中的最高位被设置为msg(most significant bit)，当msb为1表示下一字节还是属于当前数据，为0则表示当前字节为此数据的最后一个字节。每个字节的低7位用7位一组存储数字的二进制补码， 最低有效组在前，即数据字节为小端序。一些例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 -&gt; 0 0000001</span><br><span class=\"line\"></span><br><span class=\"line\">255 -&gt; 0 1111111</span><br><span class=\"line\"></span><br><span class=\"line\">256 -&gt; 1 0000000  0 0000001 -&gt; 0000001 0000000 -&gt; 256</span><br><span class=\"line\"></span><br><span class=\"line\">300 -&gt; 1 0101100  0 0000010 -&gt; 0000010 0101100 -&gt; 256 + 32 + 8 + 4 = 300</span><br></pre></td></tr></table></figure>\n<p>这样，当使用一个varint来表示unsigned int32类型整形数时，所占字节数会根据数字大小动态的改变。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 &lt;= x &lt; (2^8 - 1)       1 bit</span><br><span class=\"line\">2^8 &lt;= x &lt; (2^15 - 1)    2 bit</span><br><span class=\"line\">2^15 &lt;= x &lt; (2^22 - 1)   3 bit</span><br><span class=\"line\">2^22 &lt;= x &lt; (2^29 - 1)   4 bit</span><br><span class=\"line\">2^29 &lt;= x &lt;= (2^32)      5 bit</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息结构\"><a href=\"#消息结构\" class=\"headerlink\" title=\"消息结构\"></a>消息结构</h3><p>一条protocol buffer消息是一系列的键值对。与Json格式数据的区别是，二进制版protocol buffer数据中使用field’s number来作为key值，而最初定义的key值如需要在解码完成后通过定义文件来确定。<br/><br>当一条消息被编码时，key值和value被整合进字节流中。在protobuf中，key值是一个varint数，其中包含了两部分内容，第一部分是.proto文件中定义的每个key值对应的field number，第二部分是类型信息，用来确定value值的长度。可用的类型有以下几种<br><img src= \"/img/loading.gif\" data-src=\"/2021/12/01/ProtoBuf%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Json%E5%BF%AB/wire_types.png\"><br>key值的组织方式为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(field_number &lt;&lt; 3) | wire_type</span><br><span class=\"line\"></span><br><span class=\"line\">//即最后3bit数代表类型 例如上述例子中protobuf二进制数据的第一个字节0a代表的含义:</span><br><span class=\"line\">0   0001              010</span><br><span class=\"line\">-   ----              ---</span><br><span class=\"line\">msb fieldnumber = 1   type = 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h3><p>当一个k-v对的类型字段为2，即(length-delimited)时，在key值之后会紧跟一个varint值，来表示value的长度。</p>\n<h2 id=\"解析数据\"><a href=\"#解析数据\" class=\"headerlink\" title=\"解析数据\"></a>解析数据</h2><p>现在我们回头来看例子中产生的二进制数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0a 04 4d 69 6b 65</span><br><span class=\"line\">0a -&gt; 0 0001 010 -&gt; field = 1, type = 2</span><br><span class=\"line\">04 -&gt; value length = 4</span><br><span class=\"line\">4d -&gt; M</span><br><span class=\"line\">69 -&gt; i</span><br><span class=\"line\">6b -&gt; k</span><br><span class=\"line\">65 -&gt; e</span><br><span class=\"line\"></span><br><span class=\"line\">10 1d </span><br><span class=\"line\">0 0010 000 -&gt; field = 2, type = 0</span><br><span class=\"line\">00011101  -&gt; 29</span><br><span class=\"line\"></span><br><span class=\"line\">18 01</span><br><span class=\"line\">0 0011 000 -&gt; field = 3, type = 0</span><br><span class=\"line\">01 -&gt; true</span><br><span class=\"line\"></span><br><span class=\"line\">22 07 41 31 32 33 34 35 36</span><br><span class=\"line\">0 0100 010 -&gt; field = 4, type = 2</span><br><span class=\"line\">07 -&gt; value length = 7</span><br><span class=\"line\">41 31 32 33 34 35 36 -&gt; &quot;A123456&quot;</span><br></pre></td></tr></table></figure>\n<p>到此，便可以理解这个简单例子中protobuf的二进制数据是如何组织的了。对于题目提出的问题，也有了一个初步的回答。</p>\n<ul>\n<li>使用varint类型，在使用较小数字更频繁的场景中，更加节省空间。Json中数字按字符串存储，有多少位数就要占用多少bit空间，如例子中 29 被存储为 32 39。示例中节省1字节。</li>\n<li>bool类型值占用1字节。示例中节省3字节。</li>\n<li>不需要存储类似 {、”、 }、 space 等冗余的字符。例子中Json二进制数据总计有28个冗余字符。</li>\n<li>key值为一个varint类型数，通常只占1个字节。例子中Protobuf二进制数据 key值总计6字节，json中15字节。</li>\n<li>60(json bytes size) - 19(protobuf bytes size) = 1 + 3 + 28 + (15 - 6)</li>\n</ul>\n<h2 id=\"初探protobuf源码\"><a href=\"#初探protobuf源码\" class=\"headerlink\" title=\"初探protobuf源码\"></a>初探protobuf源码</h2><p>如果有用过protobuf的话，一定对protoc不陌生。他是protocol编译器，用来编译含有消息定义的.proto文件。这个编译器提供一个很有意思的功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ protoc | grep decode_raw -A4</span><br><span class=\"line\">  --decode_raw                Read an arbitrary protocol message from</span><br><span class=\"line\">                              standard input and write the raw tag/value</span><br><span class=\"line\">                              pairs in text format to standard output.  No</span><br><span class=\"line\">                              PROTO_FILES should be given when using this</span><br><span class=\"line\">                              flag.</span><br></pre></td></tr></table></figure>\n<p>即在不需要.proto定义文件的情况下，从标准输入读取任意的protocol消息，然后把他们以 tag/value 的文字格式打印到标准输出。后续内容都围绕这个功能来展开。<br/><br>先拿个稍微复杂一点的例子尝试一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// .proto定义文件</span><br><span class=\"line\">$ cat user.proto                      </span><br><span class=\"line\">syntax = &quot;proto3&quot;;                    </span><br><span class=\"line\">                                      </span><br><span class=\"line\">message UserInfo &#123;                    </span><br><span class=\"line\">  string name = 1;                    </span><br><span class=\"line\">  int32 age = 2;                      </span><br><span class=\"line\">  bool sex = 3;                       </span><br><span class=\"line\">  string phone = 4;                   </span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">                                      </span><br><span class=\"line\">message AddressBook &#123;                 </span><br><span class=\"line\">  string email = 1;                   </span><br><span class=\"line\">  string phone = 2;                   </span><br><span class=\"line\">  string twitter = 3;                 </span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">message Location &#123;                    </span><br><span class=\"line\">  string state = 1;                   </span><br><span class=\"line\">  int32 longitude = 2;                </span><br><span class=\"line\">  int32 latitude = 3;                 </span><br><span class=\"line\">  AddressBook contact = 4;            </span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">                                      </span><br><span class=\"line\">message Company &#123;                     </span><br><span class=\"line\">  string name = 1;                    </span><br><span class=\"line\">  repeated UserInfo legal_person = 2; </span><br><span class=\"line\">  fixed32 tel = 3;                    </span><br><span class=\"line\">  fixed64 fund = 4;                   </span><br><span class=\"line\">  Location location = 5;              </span><br><span class=\"line\">  bytes checksum = 6;                 </span><br><span class=\"line\">  repeated int32 int_array = 7;       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// python 生成数据的代码段</span><br><span class=\"line\">user = user_pb2.UserInfo()</span><br><span class=\"line\">user.name = &quot;Mike&quot;</span><br><span class=\"line\">user.age = 29</span><br><span class=\"line\">user.sex = True</span><br><span class=\"line\">user.phone = &quot;A123456&quot;</span><br><span class=\"line\">user1 = user_pb2.UserInfo()</span><br><span class=\"line\">user1.name = &quot;Amy&quot;</span><br><span class=\"line\">user1.age = 25</span><br><span class=\"line\">user1.sex = False</span><br><span class=\"line\">user1.phone = &quot;A654321&quot;</span><br><span class=\"line\">addressbook = user_pb2.AddressBook()</span><br><span class=\"line\">addressbook.email = &quot;haha@qq.com&quot;</span><br><span class=\"line\">addressbook.phone = &quot;A123456&quot;</span><br><span class=\"line\">addressbook.twitter = &quot;dalala&quot;</span><br><span class=\"line\">location = user_pb2.Location()</span><br><span class=\"line\">location.state = &quot;China&quot;</span><br><span class=\"line\">location.longitude = 123</span><br><span class=\"line\">location.latitude = 456</span><br><span class=\"line\">location.contact.CopyFrom(addressbook)</span><br><span class=\"line\">company = user_pb2.Company()</span><br><span class=\"line\">company.name = &quot;Baidu&quot;</span><br><span class=\"line\">company.tel = 123456789</span><br><span class=\"line\">company.legal_person.extend([user, user1])</span><br><span class=\"line\">company.fund = 100000000000000</span><br><span class=\"line\">company.location.CopyFrom(location)</span><br><span class=\"line\">company.checksum = bytes([0xff, 0xf2, 0x12, 0xf4, 0x34])</span><br><span class=\"line\">company.int_array.extend([1, 2, 3, 4, 5, 6])</span><br><span class=\"line\">print(&quot;protobuf:&quot;, company.SerializeToString())</span><br><span class=\"line\">file = open(&quot;protobuf.bin&quot;, &quot;wb&quot;)</span><br><span class=\"line\">file.write(bytearray(company.SerializeToString()))</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 试一下~</span><br><span class=\"line\">$ protoc --decode_raw &lt; protobuf.bin</span><br><span class=\"line\">1: &quot;Baidu&quot;</span><br><span class=\"line\">2 &#123;</span><br><span class=\"line\">  1: &quot;Mike&quot;</span><br><span class=\"line\">  2: 29</span><br><span class=\"line\">  3: 1</span><br><span class=\"line\">  4: &quot;A123456&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2 &#123;</span><br><span class=\"line\">  1: &quot;Amy&quot;</span><br><span class=\"line\">  2: 25</span><br><span class=\"line\">  4: &quot;A654321&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3: 0x075bcd15</span><br><span class=\"line\">4: 0x00005af3107a4000</span><br><span class=\"line\">5 &#123;</span><br><span class=\"line\">  1: &quot;China&quot;</span><br><span class=\"line\">  2: 123</span><br><span class=\"line\">  3: 456</span><br><span class=\"line\">  4 &#123;</span><br><span class=\"line\">    1: &quot;haha@qq.com&quot;</span><br><span class=\"line\">    2: &quot;A123456&quot;</span><br><span class=\"line\">    3: &quot;dalala&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">6: &quot;\\377\\362\\022\\3644&quot;</span><br><span class=\"line\">7: &quot;\\001\\002\\003\\004\\005\\006&quot;</span><br></pre></td></tr></table></figure>\n\n<p>恰好，protoc这个程序的代码是开源的，所以为了弄懂这个功能是如何实现的，按照<a href=\"https://github.com/protocolbuffers/protobuf/tree/master/cmake\">构建文档</a>来,得到一个有源码,可调试的protoc程序。<br><img src= \"/img/loading.gif\" data-src=\"/2021/12/01/ProtoBuf%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Json%E5%BF%AB/debug_protoc.png\"><br>然后修改程序的运行时参数，添加decode_raw参数、并将一个样例二进制文件作为标准输入。 这样，就可以愉快的单步调试，找到对应部分的代码了。 解析二进制数据核心代码的起始部分调用栈如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1   google::protobuf::internal::WireFormat::_InternalParse                                  wire_format.cc            792  0x7ff77988e084 </span><br><span class=\"line\">2   google::protobuf::Message::_InternalParse                                               message.cc                167  0x7ff779841a8c </span><br><span class=\"line\">3   google::protobuf::internal::MergeFromImpl&lt;0&gt;                                            message_lite.cc           159  0x7ff7796b9346 </span><br><span class=\"line\">4   google::protobuf::MessageLite::ParseFrom&lt;3,google::protobuf::io::ZeroCopyInputStream *&gt; message_lite.h            552  0x7ff7796b99e7 </span><br><span class=\"line\">5   google::protobuf::MessageLite::ParsePartialFromZeroCopyStream                           message_lite.cc           267  0x7ff7796b59d2 </span><br><span class=\"line\">6   google::protobuf::compiler::CommandLineInterface::EncodeOrDecode                        command_line_interface.cc 2384 0x7ff7794a0ecd </span><br><span class=\"line\">7   google::protobuf::compiler::CommandLineInterface::Run                                   command_line_interface.cc 1121 0x7ff77949b251 </span><br><span class=\"line\">8   google::protobuf::compiler::ProtobufMain                                                main.cc                   104  0x7ff7794349b8 </span><br><span class=\"line\">9   main                                                                                    main.cc                   113  0x7ff779434aaf </span><br><span class=\"line\">10  invoke_main                                                                             exe_common.inl            79   0x7ff7799723e9 </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一些代码片段\"><a href=\"#一些代码片段\" class=\"headerlink\" title=\"一些代码片段\"></a>一些代码片段</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//获取包含field_number和 wire_type的key值</span><br><span class=\"line\"></span><br><span class=\"line\">// Same as ParseVarint but only accept 5 bytes at most.</span><br><span class=\"line\">inline const char* ReadTag(const char* p, uint32_t* out,</span><br><span class=\"line\">                           uint32_t /*max_tag*/ = 0) &#123;</span><br><span class=\"line\">  uint32_t res = static_cast&lt;uint8_t&gt;(p[0]);</span><br><span class=\"line\">  if (res &lt; 128) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  uint32_t second = static_cast&lt;uint8_t&gt;(p[1]);</span><br><span class=\"line\">  res += (second - 1) &lt;&lt; 7;         </span><br><span class=\"line\">  if (second &lt; 128) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  auto tmp = ReadTagFallback(p, res);</span><br><span class=\"line\">  *out = tmp.second;</span><br><span class=\"line\">  return tmp.first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::pair&lt;const char*, uint32_t&gt; ReadTagFallback(const char* p, uint32_t res) &#123;</span><br><span class=\"line\">  for (std::uint32_t i = 2; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    uint32_t byte = static_cast&lt;uint8_t&gt;(p[i]);</span><br><span class=\"line\">    res += (byte - 1) &lt;&lt; (7 * i);</span><br><span class=\"line\">    if (PROTOBUF_PREDICT_TRUE(byte &lt; 128)) &#123;</span><br><span class=\"line\">      return &#123;p + i + 1, res&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;nullptr, 0&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是protobuf源码中读取varint的方法，因为varint的字节序是小端序，按索引顺序读取字节，若当前字节小于128，即最高位为0，则完成读取，返回结果。否则最高位为1，表示下一字节仍然属于当前值，则读取下一字节。<br/><br>当第一个字节大于128时，读取第二个字节， 结果值的计算方式为: res += (second - 1) &lt;&lt; 7;  这里减1减掉的其实是第一个字节中的msg(most significant bit)，等同于res = (res - 128) + (second &lt;&lt; 7)。<br>当varint长度大于2时，计算方法一般化为 res += (byte - 1) &lt;&lt; (7 * i)。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 获取field字段</span><br><span class=\"line\"></span><br><span class=\"line\">static constexpr int kTagTypeBits = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">inline int WireFormatLite::GetTagFieldNumber(uint32_t tag) &#123;</span><br><span class=\"line\">  return static_cast&lt;int&gt;(tag &gt;&gt; kTagTypeBits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//  读取Varint值</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">const char* VarintParse(const char* p, T* out) &#123;</span><br><span class=\"line\">  auto ptr = reinterpret_cast&lt;const uint8_t*&gt;(p);</span><br><span class=\"line\">  uint32_t res = ptr[0];</span><br><span class=\"line\">  if (!(res &amp; 0x80)) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  uint32_t byte = ptr[1];</span><br><span class=\"line\">  res += (byte - 1) &lt;&lt; 7;</span><br><span class=\"line\">  if (!(byte &amp; 0x80)) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return VarintParseSlow(p, res, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline const char* VarintParseSlow(const char* p, uint32_t res, uint64_t* out) &#123;</span><br><span class=\"line\">  auto tmp = VarintParseSlow64(p, res);</span><br><span class=\"line\">  *out = tmp.second;</span><br><span class=\"line\">  return tmp.first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::pair&lt;const char*, uint64_t&gt; VarintParseSlow64(const char* p,</span><br><span class=\"line\">                                                   uint32_t res32) &#123;</span><br><span class=\"line\">  uint64_t res = res32;</span><br><span class=\"line\">  for (std::uint32_t i = 2; i &lt; 10; i++) &#123;</span><br><span class=\"line\">    uint64_t byte = static_cast&lt;uint8_t&gt;(p[i]);</span><br><span class=\"line\">    res += (byte - 1) &lt;&lt; (7 * i);</span><br><span class=\"line\">    if (PROTOBUF_PREDICT_TRUE(byte &lt; 128)) &#123;</span><br><span class=\"line\">      return &#123;p + i + 1, res&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;nullptr, 0&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小练习\"><a href=\"#小练习\" class=\"headerlink\" title=\"小练习\"></a>小练习</h3><p>这个功能的实现中，大部分类型数据的解析只需要按照常规的方式顺序解释二进制数据就好了(例如 Varint、64-bit、32-bit)。 主要的问题在于对Length-delimited类型数据的解析，在没有.proto定义的情况下，是无法确定一段二进制数据究竟是 embedded messages类型 还是 string\\bytes类型的。 源码中大概的步骤是:</p>\n<ul>\n<li>第一步顺序读取字节流，按对应规则解释二进制数据，存入一个UnknownFieldSet的结构中。在第一步中对于Length-delimited数据具体是什么类型不做判断和区分。</li>\n<li>第二步打印UnknownFieldSet数据。打印的过程中，对于Length-delimited类型的数据会首先尝试以embedded messages的方式解析这段二进制数据，如果解析成功,则按照embedded messages来解析和打印，否则则按照utf-8编码的string类型来打印。</li>\n</ul>\n<p>为了验证一下对这部分代码的理解，顺带练习一下python, 用python重新实现了一遍这个小功能。基本实现了 protoc –decode_raw 这个命令的功能(可能会有bug)，另外对string/bytes类型数据做了区分、把普通的repeated elements放在了一个数组里。代码总共不到三百行，对于这个功能具体实现细节感兴趣的同学可以拿来玩一玩。代码放在github上: <a href=\"https://github.com/liujianfengv/protobuf_decoder\">protobuf_decoder</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 拿同样的数据试下</span><br><span class=\"line\">$ python protobuf_decoder.py example/protobuf.bin</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;1&quot;: &quot;Baidu&quot;,</span><br><span class=\"line\">    &quot;2&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;1&quot;: &quot;Mike&quot;,</span><br><span class=\"line\">            &quot;2&quot;: 29,</span><br><span class=\"line\">            &quot;3&quot;: 1,</span><br><span class=\"line\">            &quot;4&quot;: &quot;A123456&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;1&quot;: &quot;Amy&quot;,</span><br><span class=\"line\">            &quot;2&quot;: 25,</span><br><span class=\"line\">            &quot;4&quot;: &quot;A654321&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;3&quot;: 123456789,</span><br><span class=\"line\">    &quot;4&quot;: 100000000000000,</span><br><span class=\"line\">    &quot;5&quot;: &#123;</span><br><span class=\"line\">        &quot;1&quot;: &quot;China&quot;,</span><br><span class=\"line\">        &quot;2&quot;: 123,</span><br><span class=\"line\">        &quot;3&quot;: 456,</span><br><span class=\"line\">        &quot;4&quot;: &#123;</span><br><span class=\"line\">            &quot;1&quot;: &quot;haha@qq.com&quot;,</span><br><span class=\"line\">            &quot;2&quot;: &quot;A123456&quot;,</span><br><span class=\"line\">            &quot;3&quot;: &quot;dalala&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;6&quot;: &quot;ff f2 12 f4 34&quot;,</span><br><span class=\"line\">    &quot;7&quot;: &quot;\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关源码\"><a href=\"#相关源码\" class=\"headerlink\" title=\"相关源码\"></a>相关源码</h2><ul>\n<li><a href=\"https://github.com/liujianfengv/protobuf_decoder\">protobuf_decoder</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Encoding | Protocol Buffers | Google Developers</a></li>\n<li><a href=\"https://github.com/protocolbuffers/protobuf\">protocolbuffers / protobuf</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. </p>\n</blockquote>","more":"<p>Protocol buffers是Google为了序列结构化数据开发的语言无关、平台无关、可拓展的机制。类似XML，但是更小，更快，更简单。</p>\n<blockquote>\n<p>JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write.</p>\n</blockquote>\n<p>JSON是一个易于读写的轻量数据交换格式。</p>\n<h2 id=\"从一个简单的例子开始\"><a href=\"#从一个简单的例子开始\" class=\"headerlink\" title=\"从一个简单的例子开始\"></a>从一个简单的例子开始</h2><p>一份Json数据以及对应的二进制数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;:&quot;Mike&quot;,</span><br><span class=\"line\">    &quot;age&quot;:29,</span><br><span class=\"line\">    &quot;sex&quot;:true,</span><br><span class=\"line\">    &quot;phone&quot;:&quot;A123456&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bytes size: 60</span><br><span class=\"line\">7b 22 6e 61 6d 65 22 3a</span><br><span class=\"line\">20 22 4d 69 6b 65 22 2c</span><br><span class=\"line\">20 22 61 67 65 22 3a 20</span><br><span class=\"line\">32 39 2c 20 22 73 65 78</span><br><span class=\"line\">22 3a 20 74 72 75 65 2c</span><br><span class=\"line\">20 22 70 68 6f 6e 65 22</span><br><span class=\"line\">3a 20 22 41 31 32 33 34</span><br><span class=\"line\">35 36 22 7d</span><br></pre></td></tr></table></figure>\n<p>使用类似的.proto定义生成对应的二进制数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//user.proto</span><br><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\">message UserInfo &#123;</span><br><span class=\"line\">  string name = 1;</span><br><span class=\"line\">  int32 age = 2;</span><br><span class=\"line\">  bool sex = 3;</span><br><span class=\"line\">  string phone = 4;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//python code snippet</span><br><span class=\"line\">def print_protobuf():</span><br><span class=\"line\">    user = user_pb2.UserInfo()</span><br><span class=\"line\">    user.name = &quot;Mike&quot;</span><br><span class=\"line\">    user.age = 29</span><br><span class=\"line\">    user.sex = True</span><br><span class=\"line\">    user.phone = &quot;A123456&quot;</span><br><span class=\"line\">    print_hex(user.SerializeToString())</span><br><span class=\"line\"></span><br><span class=\"line\">bytes size: 19</span><br><span class=\"line\">0a 04 4d 69 6b 65 10 1d</span><br><span class=\"line\">18 01 22 07 41 31 32 33</span><br><span class=\"line\">34 35 36</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在这个例子中，为了传输同样的数据，使用Protobuf生成的数据量是使用Json时的三分之一。Json对应的二进制数据非常简单，每个字符由ASCII码表示，总计60个字符，每个字符一个字节，二进制数据总计60字节。而由protobuf生成的二进制数据就比较难懂了，为什么只用19个字节便可以表示相同的数据了呢？</p>\n<h2 id=\"Protobuf-编码方式\"><a href=\"#Protobuf-编码方式\" class=\"headerlink\" title=\"Protobuf 编码方式\"></a>Protobuf 编码方式</h2><p>内容参考Google的<a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">官方文档</a></p>\n<h3 id=\"Varint\"><a href=\"#Varint\" class=\"headerlink\" title=\"Varint\"></a>Varint</h3><p>一个unsigned int32类型的变量占用4个字节，可以表示的数字范围是 0 到 2^32 (4,294,967,295)。在实际的场景中，小数字的使用频率是远大于大数字的使用频率的。这样，在存储中就会浪费掉一部分空间。 例如数字255的二进制小端表示中，后三个字节被浪费。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">01111111 00000000 00000000 00000000</span><br><span class=\"line\">         --------------------------</span><br></pre></td></tr></table></figure>\n<p>针对这种情况，提出了一种优化的方案 即varints, varints 是一种用一个或多个字节序列化整型数的方法。可以根据存储数据的大小动态的决定一个整型数占用的空间。 <br/><br>在varint的每一个字节中的最高位被设置为msg(most significant bit)，当msb为1表示下一字节还是属于当前数据，为0则表示当前字节为此数据的最后一个字节。每个字节的低7位用7位一组存储数字的二进制补码， 最低有效组在前，即数据字节为小端序。一些例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 -&gt; 0 0000001</span><br><span class=\"line\"></span><br><span class=\"line\">255 -&gt; 0 1111111</span><br><span class=\"line\"></span><br><span class=\"line\">256 -&gt; 1 0000000  0 0000001 -&gt; 0000001 0000000 -&gt; 256</span><br><span class=\"line\"></span><br><span class=\"line\">300 -&gt; 1 0101100  0 0000010 -&gt; 0000010 0101100 -&gt; 256 + 32 + 8 + 4 = 300</span><br></pre></td></tr></table></figure>\n<p>这样，当使用一个varint来表示unsigned int32类型整形数时，所占字节数会根据数字大小动态的改变。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 &lt;= x &lt; (2^8 - 1)       1 bit</span><br><span class=\"line\">2^8 &lt;= x &lt; (2^15 - 1)    2 bit</span><br><span class=\"line\">2^15 &lt;= x &lt; (2^22 - 1)   3 bit</span><br><span class=\"line\">2^22 &lt;= x &lt; (2^29 - 1)   4 bit</span><br><span class=\"line\">2^29 &lt;= x &lt;= (2^32)      5 bit</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息结构\"><a href=\"#消息结构\" class=\"headerlink\" title=\"消息结构\"></a>消息结构</h3><p>一条protocol buffer消息是一系列的键值对。与Json格式数据的区别是，二进制版protocol buffer数据中使用field’s number来作为key值，而最初定义的key值如需要在解码完成后通过定义文件来确定。<br/><br>当一条消息被编码时，key值和value被整合进字节流中。在protobuf中，key值是一个varint数，其中包含了两部分内容，第一部分是.proto文件中定义的每个key值对应的field number，第二部分是类型信息，用来确定value值的长度。可用的类型有以下几种<br><img src=\"/2021/12/01/ProtoBuf%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Json%E5%BF%AB/wire_types.png\"><br>key值的组织方式为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(field_number &lt;&lt; 3) | wire_type</span><br><span class=\"line\"></span><br><span class=\"line\">//即最后3bit数代表类型 例如上述例子中protobuf二进制数据的第一个字节0a代表的含义:</span><br><span class=\"line\">0   0001              010</span><br><span class=\"line\">-   ----              ---</span><br><span class=\"line\">msb fieldnumber = 1   type = 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h3><p>当一个k-v对的类型字段为2，即(length-delimited)时，在key值之后会紧跟一个varint值，来表示value的长度。</p>\n<h2 id=\"解析数据\"><a href=\"#解析数据\" class=\"headerlink\" title=\"解析数据\"></a>解析数据</h2><p>现在我们回头来看例子中产生的二进制数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0a 04 4d 69 6b 65</span><br><span class=\"line\">0a -&gt; 0 0001 010 -&gt; field = 1, type = 2</span><br><span class=\"line\">04 -&gt; value length = 4</span><br><span class=\"line\">4d -&gt; M</span><br><span class=\"line\">69 -&gt; i</span><br><span class=\"line\">6b -&gt; k</span><br><span class=\"line\">65 -&gt; e</span><br><span class=\"line\"></span><br><span class=\"line\">10 1d </span><br><span class=\"line\">0 0010 000 -&gt; field = 2, type = 0</span><br><span class=\"line\">00011101  -&gt; 29</span><br><span class=\"line\"></span><br><span class=\"line\">18 01</span><br><span class=\"line\">0 0011 000 -&gt; field = 3, type = 0</span><br><span class=\"line\">01 -&gt; true</span><br><span class=\"line\"></span><br><span class=\"line\">22 07 41 31 32 33 34 35 36</span><br><span class=\"line\">0 0100 010 -&gt; field = 4, type = 2</span><br><span class=\"line\">07 -&gt; value length = 7</span><br><span class=\"line\">41 31 32 33 34 35 36 -&gt; &quot;A123456&quot;</span><br></pre></td></tr></table></figure>\n<p>到此，便可以理解这个简单例子中protobuf的二进制数据是如何组织的了。对于题目提出的问题，也有了一个初步的回答。</p>\n<ul>\n<li>使用varint类型，在使用较小数字更频繁的场景中，更加节省空间。Json中数字按字符串存储，有多少位数就要占用多少bit空间，如例子中 29 被存储为 32 39。示例中节省1字节。</li>\n<li>bool类型值占用1字节。示例中节省3字节。</li>\n<li>不需要存储类似 {、”、 }、 space 等冗余的字符。例子中Json二进制数据总计有28个冗余字符。</li>\n<li>key值为一个varint类型数，通常只占1个字节。例子中Protobuf二进制数据 key值总计6字节，json中15字节。</li>\n<li>60(json bytes size) - 19(protobuf bytes size) = 1 + 3 + 28 + (15 - 6)</li>\n</ul>\n<h2 id=\"初探protobuf源码\"><a href=\"#初探protobuf源码\" class=\"headerlink\" title=\"初探protobuf源码\"></a>初探protobuf源码</h2><p>如果有用过protobuf的话，一定对protoc不陌生。他是protocol编译器，用来编译含有消息定义的.proto文件。这个编译器提供一个很有意思的功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ protoc | grep decode_raw -A4</span><br><span class=\"line\">  --decode_raw                Read an arbitrary protocol message from</span><br><span class=\"line\">                              standard input and write the raw tag/value</span><br><span class=\"line\">                              pairs in text format to standard output.  No</span><br><span class=\"line\">                              PROTO_FILES should be given when using this</span><br><span class=\"line\">                              flag.</span><br></pre></td></tr></table></figure>\n<p>即在不需要.proto定义文件的情况下，从标准输入读取任意的protocol消息，然后把他们以 tag/value 的文字格式打印到标准输出。后续内容都围绕这个功能来展开。<br/><br>先拿个稍微复杂一点的例子尝试一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// .proto定义文件</span><br><span class=\"line\">$ cat user.proto                      </span><br><span class=\"line\">syntax = &quot;proto3&quot;;                    </span><br><span class=\"line\">                                      </span><br><span class=\"line\">message UserInfo &#123;                    </span><br><span class=\"line\">  string name = 1;                    </span><br><span class=\"line\">  int32 age = 2;                      </span><br><span class=\"line\">  bool sex = 3;                       </span><br><span class=\"line\">  string phone = 4;                   </span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">                                      </span><br><span class=\"line\">message AddressBook &#123;                 </span><br><span class=\"line\">  string email = 1;                   </span><br><span class=\"line\">  string phone = 2;                   </span><br><span class=\"line\">  string twitter = 3;                 </span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">message Location &#123;                    </span><br><span class=\"line\">  string state = 1;                   </span><br><span class=\"line\">  int32 longitude = 2;                </span><br><span class=\"line\">  int32 latitude = 3;                 </span><br><span class=\"line\">  AddressBook contact = 4;            </span><br><span class=\"line\">&#125;                                     </span><br><span class=\"line\">                                      </span><br><span class=\"line\">message Company &#123;                     </span><br><span class=\"line\">  string name = 1;                    </span><br><span class=\"line\">  repeated UserInfo legal_person = 2; </span><br><span class=\"line\">  fixed32 tel = 3;                    </span><br><span class=\"line\">  fixed64 fund = 4;                   </span><br><span class=\"line\">  Location location = 5;              </span><br><span class=\"line\">  bytes checksum = 6;                 </span><br><span class=\"line\">  repeated int32 int_array = 7;       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// python 生成数据的代码段</span><br><span class=\"line\">user = user_pb2.UserInfo()</span><br><span class=\"line\">user.name = &quot;Mike&quot;</span><br><span class=\"line\">user.age = 29</span><br><span class=\"line\">user.sex = True</span><br><span class=\"line\">user.phone = &quot;A123456&quot;</span><br><span class=\"line\">user1 = user_pb2.UserInfo()</span><br><span class=\"line\">user1.name = &quot;Amy&quot;</span><br><span class=\"line\">user1.age = 25</span><br><span class=\"line\">user1.sex = False</span><br><span class=\"line\">user1.phone = &quot;A654321&quot;</span><br><span class=\"line\">addressbook = user_pb2.AddressBook()</span><br><span class=\"line\">addressbook.email = &quot;haha@qq.com&quot;</span><br><span class=\"line\">addressbook.phone = &quot;A123456&quot;</span><br><span class=\"line\">addressbook.twitter = &quot;dalala&quot;</span><br><span class=\"line\">location = user_pb2.Location()</span><br><span class=\"line\">location.state = &quot;China&quot;</span><br><span class=\"line\">location.longitude = 123</span><br><span class=\"line\">location.latitude = 456</span><br><span class=\"line\">location.contact.CopyFrom(addressbook)</span><br><span class=\"line\">company = user_pb2.Company()</span><br><span class=\"line\">company.name = &quot;Baidu&quot;</span><br><span class=\"line\">company.tel = 123456789</span><br><span class=\"line\">company.legal_person.extend([user, user1])</span><br><span class=\"line\">company.fund = 100000000000000</span><br><span class=\"line\">company.location.CopyFrom(location)</span><br><span class=\"line\">company.checksum = bytes([0xff, 0xf2, 0x12, 0xf4, 0x34])</span><br><span class=\"line\">company.int_array.extend([1, 2, 3, 4, 5, 6])</span><br><span class=\"line\">print(&quot;protobuf:&quot;, company.SerializeToString())</span><br><span class=\"line\">file = open(&quot;protobuf.bin&quot;, &quot;wb&quot;)</span><br><span class=\"line\">file.write(bytearray(company.SerializeToString()))</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 试一下~</span><br><span class=\"line\">$ protoc --decode_raw &lt; protobuf.bin</span><br><span class=\"line\">1: &quot;Baidu&quot;</span><br><span class=\"line\">2 &#123;</span><br><span class=\"line\">  1: &quot;Mike&quot;</span><br><span class=\"line\">  2: 29</span><br><span class=\"line\">  3: 1</span><br><span class=\"line\">  4: &quot;A123456&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2 &#123;</span><br><span class=\"line\">  1: &quot;Amy&quot;</span><br><span class=\"line\">  2: 25</span><br><span class=\"line\">  4: &quot;A654321&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">3: 0x075bcd15</span><br><span class=\"line\">4: 0x00005af3107a4000</span><br><span class=\"line\">5 &#123;</span><br><span class=\"line\">  1: &quot;China&quot;</span><br><span class=\"line\">  2: 123</span><br><span class=\"line\">  3: 456</span><br><span class=\"line\">  4 &#123;</span><br><span class=\"line\">    1: &quot;haha@qq.com&quot;</span><br><span class=\"line\">    2: &quot;A123456&quot;</span><br><span class=\"line\">    3: &quot;dalala&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">6: &quot;\\377\\362\\022\\3644&quot;</span><br><span class=\"line\">7: &quot;\\001\\002\\003\\004\\005\\006&quot;</span><br></pre></td></tr></table></figure>\n\n<p>恰好，protoc这个程序的代码是开源的，所以为了弄懂这个功能是如何实现的，按照<a href=\"https://github.com/protocolbuffers/protobuf/tree/master/cmake\">构建文档</a>来,得到一个有源码,可调试的protoc程序。<br><img src=\"/2021/12/01/ProtoBuf%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94Json%E5%BF%AB/debug_protoc.png\"><br>然后修改程序的运行时参数，添加decode_raw参数、并将一个样例二进制文件作为标准输入。 这样，就可以愉快的单步调试，找到对应部分的代码了。 解析二进制数据核心代码的起始部分调用栈如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1   google::protobuf::internal::WireFormat::_InternalParse                                  wire_format.cc            792  0x7ff77988e084 </span><br><span class=\"line\">2   google::protobuf::Message::_InternalParse                                               message.cc                167  0x7ff779841a8c </span><br><span class=\"line\">3   google::protobuf::internal::MergeFromImpl&lt;0&gt;                                            message_lite.cc           159  0x7ff7796b9346 </span><br><span class=\"line\">4   google::protobuf::MessageLite::ParseFrom&lt;3,google::protobuf::io::ZeroCopyInputStream *&gt; message_lite.h            552  0x7ff7796b99e7 </span><br><span class=\"line\">5   google::protobuf::MessageLite::ParsePartialFromZeroCopyStream                           message_lite.cc           267  0x7ff7796b59d2 </span><br><span class=\"line\">6   google::protobuf::compiler::CommandLineInterface::EncodeOrDecode                        command_line_interface.cc 2384 0x7ff7794a0ecd </span><br><span class=\"line\">7   google::protobuf::compiler::CommandLineInterface::Run                                   command_line_interface.cc 1121 0x7ff77949b251 </span><br><span class=\"line\">8   google::protobuf::compiler::ProtobufMain                                                main.cc                   104  0x7ff7794349b8 </span><br><span class=\"line\">9   main                                                                                    main.cc                   113  0x7ff779434aaf </span><br><span class=\"line\">10  invoke_main                                                                             exe_common.inl            79   0x7ff7799723e9 </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一些代码片段\"><a href=\"#一些代码片段\" class=\"headerlink\" title=\"一些代码片段\"></a>一些代码片段</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//获取包含field_number和 wire_type的key值</span><br><span class=\"line\"></span><br><span class=\"line\">// Same as ParseVarint but only accept 5 bytes at most.</span><br><span class=\"line\">inline const char* ReadTag(const char* p, uint32_t* out,</span><br><span class=\"line\">                           uint32_t /*max_tag*/ = 0) &#123;</span><br><span class=\"line\">  uint32_t res = static_cast&lt;uint8_t&gt;(p[0]);</span><br><span class=\"line\">  if (res &lt; 128) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  uint32_t second = static_cast&lt;uint8_t&gt;(p[1]);</span><br><span class=\"line\">  res += (second - 1) &lt;&lt; 7;         </span><br><span class=\"line\">  if (second &lt; 128) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  auto tmp = ReadTagFallback(p, res);</span><br><span class=\"line\">  *out = tmp.second;</span><br><span class=\"line\">  return tmp.first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::pair&lt;const char*, uint32_t&gt; ReadTagFallback(const char* p, uint32_t res) &#123;</span><br><span class=\"line\">  for (std::uint32_t i = 2; i &lt; 5; i++) &#123;</span><br><span class=\"line\">    uint32_t byte = static_cast&lt;uint8_t&gt;(p[i]);</span><br><span class=\"line\">    res += (byte - 1) &lt;&lt; (7 * i);</span><br><span class=\"line\">    if (PROTOBUF_PREDICT_TRUE(byte &lt; 128)) &#123;</span><br><span class=\"line\">      return &#123;p + i + 1, res&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;nullptr, 0&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是protobuf源码中读取varint的方法，因为varint的字节序是小端序，按索引顺序读取字节，若当前字节小于128，即最高位为0，则完成读取，返回结果。否则最高位为1，表示下一字节仍然属于当前值，则读取下一字节。<br/><br>当第一个字节大于128时，读取第二个字节， 结果值的计算方式为: res += (second - 1) &lt;&lt; 7;  这里减1减掉的其实是第一个字节中的msg(most significant bit)，等同于res = (res - 128) + (second &lt;&lt; 7)。<br>当varint长度大于2时，计算方法一般化为 res += (byte - 1) &lt;&lt; (7 * i)。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 获取field字段</span><br><span class=\"line\"></span><br><span class=\"line\">static constexpr int kTagTypeBits = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">inline int WireFormatLite::GetTagFieldNumber(uint32_t tag) &#123;</span><br><span class=\"line\">  return static_cast&lt;int&gt;(tag &gt;&gt; kTagTypeBits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//  读取Varint值</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">const char* VarintParse(const char* p, T* out) &#123;</span><br><span class=\"line\">  auto ptr = reinterpret_cast&lt;const uint8_t*&gt;(p);</span><br><span class=\"line\">  uint32_t res = ptr[0];</span><br><span class=\"line\">  if (!(res &amp; 0x80)) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  uint32_t byte = ptr[1];</span><br><span class=\"line\">  res += (byte - 1) &lt;&lt; 7;</span><br><span class=\"line\">  if (!(byte &amp; 0x80)) &#123;</span><br><span class=\"line\">    *out = res;</span><br><span class=\"line\">    return p + 2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return VarintParseSlow(p, res, out);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline const char* VarintParseSlow(const char* p, uint32_t res, uint64_t* out) &#123;</span><br><span class=\"line\">  auto tmp = VarintParseSlow64(p, res);</span><br><span class=\"line\">  *out = tmp.second;</span><br><span class=\"line\">  return tmp.first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">std::pair&lt;const char*, uint64_t&gt; VarintParseSlow64(const char* p,</span><br><span class=\"line\">                                                   uint32_t res32) &#123;</span><br><span class=\"line\">  uint64_t res = res32;</span><br><span class=\"line\">  for (std::uint32_t i = 2; i &lt; 10; i++) &#123;</span><br><span class=\"line\">    uint64_t byte = static_cast&lt;uint8_t&gt;(p[i]);</span><br><span class=\"line\">    res += (byte - 1) &lt;&lt; (7 * i);</span><br><span class=\"line\">    if (PROTOBUF_PREDICT_TRUE(byte &lt; 128)) &#123;</span><br><span class=\"line\">      return &#123;p + i + 1, res&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;nullptr, 0&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小练习\"><a href=\"#小练习\" class=\"headerlink\" title=\"小练习\"></a>小练习</h3><p>这个功能的实现中，大部分类型数据的解析只需要按照常规的方式顺序解释二进制数据就好了(例如 Varint、64-bit、32-bit)。 主要的问题在于对Length-delimited类型数据的解析，在没有.proto定义的情况下，是无法确定一段二进制数据究竟是 embedded messages类型 还是 string\\bytes类型的。 源码中大概的步骤是:</p>\n<ul>\n<li>第一步顺序读取字节流，按对应规则解释二进制数据，存入一个UnknownFieldSet的结构中。在第一步中对于Length-delimited数据具体是什么类型不做判断和区分。</li>\n<li>第二步打印UnknownFieldSet数据。打印的过程中，对于Length-delimited类型的数据会首先尝试以embedded messages的方式解析这段二进制数据，如果解析成功,则按照embedded messages来解析和打印，否则则按照utf-8编码的string类型来打印。</li>\n</ul>\n<p>为了验证一下对这部分代码的理解，顺带练习一下python, 用python重新实现了一遍这个小功能。基本实现了 protoc –decode_raw 这个命令的功能(可能会有bug)，另外对string/bytes类型数据做了区分、把普通的repeated elements放在了一个数组里。代码总共不到三百行，对于这个功能具体实现细节感兴趣的同学可以拿来玩一玩。代码放在github上: <a href=\"https://github.com/liujianfengv/protobuf_decoder\">protobuf_decoder</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 拿同样的数据试下</span><br><span class=\"line\">$ python protobuf_decoder.py example/protobuf.bin</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;1&quot;: &quot;Baidu&quot;,</span><br><span class=\"line\">    &quot;2&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;1&quot;: &quot;Mike&quot;,</span><br><span class=\"line\">            &quot;2&quot;: 29,</span><br><span class=\"line\">            &quot;3&quot;: 1,</span><br><span class=\"line\">            &quot;4&quot;: &quot;A123456&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;1&quot;: &quot;Amy&quot;,</span><br><span class=\"line\">            &quot;2&quot;: 25,</span><br><span class=\"line\">            &quot;4&quot;: &quot;A654321&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;3&quot;: 123456789,</span><br><span class=\"line\">    &quot;4&quot;: 100000000000000,</span><br><span class=\"line\">    &quot;5&quot;: &#123;</span><br><span class=\"line\">        &quot;1&quot;: &quot;China&quot;,</span><br><span class=\"line\">        &quot;2&quot;: 123,</span><br><span class=\"line\">        &quot;3&quot;: 456,</span><br><span class=\"line\">        &quot;4&quot;: &#123;</span><br><span class=\"line\">            &quot;1&quot;: &quot;haha@qq.com&quot;,</span><br><span class=\"line\">            &quot;2&quot;: &quot;A123456&quot;,</span><br><span class=\"line\">            &quot;3&quot;: &quot;dalala&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;6&quot;: &quot;ff f2 12 f4 34&quot;,</span><br><span class=\"line\">    &quot;7&quot;: &quot;\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关源码\"><a href=\"#相关源码\" class=\"headerlink\" title=\"相关源码\"></a>相关源码</h2><ul>\n<li><a href=\"https://github.com/liujianfengv/protobuf_decoder\">protobuf_decoder</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">Encoding | Protocol Buffers | Google Developers</a></li>\n<li><a href=\"https://github.com/protocolbuffers/protobuf\">protocolbuffers / protobuf</a></li>\n</ul>"},{"title":"Qt信号槽机制浅析","date":"2021-11-02T14:39:24.000Z","_content":"\nQt是一个跨平台的C++软件开发框架，而Qt的核心机制是信号槽，关于信号槽，Qt官方的表述是:\n<!--more-->\n> Signals and slots are used for communication between objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. Signals and slots are made possible by Qt's meta-object system.\n\n信号和槽被用于对象间的沟通，信号槽机制是Qt的核心特点，也是Qt与其他应用框架的不同之处，信号槽的机制得益于Qt的元对象系统。\n下面分两步来对Qt的信号槽机制做一个简单分析。\n\n## 从Qt程序的编译过程讲起\n一个普通C++程序的编译需要经过以下几个步骤\n- 预处理(Prepressing): 主要处理源代码中以“#”开始的预编译命令，例如\"#include\"将被包含文件插入到该指令位置、 处理\"#if\"、\"ifdef\"等条件预编译指令、删除注释\n- 编译(Compilation): 将预处理完的文件进行词法分析、语法分析、语义分析生成相应的汇编代码文件\n- 汇编(Assembly): 将编译生成的汇编代码转化成机器可以执行的指令，生成目标文件\n- 链接(Linking): 组织汇编生成的目标文件和编译环境下相关的运行时库，将各个模块之间的相互引用部分处理好，使得各个模块间能够正确的衔接\nQt程序的编译与C++程序的编译主要区别在于moc系统\n\n> The Meta-Object Compiler, moc, is the program that handles Qt's C++ extensions. The moc tool reads a C++ header file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system\n\n元对象编译器是处理Qt的C++拓展程序， moc工具读取C++头文件，如果在文件中找到一个或多个Q_OBJECT宏，它将会生成一个包含对应类元对象代码的C++源文件，除此之外，元对象代码是信号槽机制、运行时类型信息、动态属性系统所必须的。\n一个最简单的不带界面和资源文件，只使用信号槽机制的Qt程序的编译过程就是，在普通C++程序编译的过程前对包含Q_OBJECT的类使用moc工具生成对应的元对象代码，即 元对象编译->预处理->编译->汇编->链接。\n下面用一个例子来验证。\n\n```\ntestSignalSlot\n├── main.cpp\n├── reciver.cpp\n├── reciver.h\n├── sender.cpp\n└── sender.h\n```\n\n```\n//reciver.h\n#ifndef RECIVER_H\n#define RECIVER_H\n\n#include <QObject>\n\nclass Reciver : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit Reciver(QObject *parent = nullptr);\npublic slots:\n    void recive();\n};\n\n#endif // RECIVER_H\n```\n```\n//reciver.cpp\n#include \"reciver.h\"\n\n#include <QDebug>\nReciver::Reciver(QObject *parent) : QObject(parent)\n{\n\n}\n\nvoid Reciver::recive()\n{\n    qDebug()<<\"Hello Qt!\";\n}\n\n```\n```\n//sender.h\n#ifndef SENDER_H\n#define SENDER_H\n\n#include <QObject>\n\nclass Sender : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit Sender(QObject *parent = nullptr);\n\nsignals:\n    void send();\n};\n\n#endif // SENDER_H\n```\n```\n//sender.cpp\n#include \"sender.h\"\n\nSender::Sender(QObject *parent) : QObject(parent)\n{\n}\n```\n```\nmain.cpp\n#include <QCoreApplication>\n\n#include \"sender.h\"\n#include \"reciver.h\"\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n    Sender sender;\n    Reciver reciver;\n    QObject::connect(&sender, &Sender::send,\n                     &reciver, &Reciver::recive);\n    emit sender.send();\n    return a.exec();\n}\n```\n\n首先使用moc工具为sender 和 reciver 生成moc代码 moc路径\n\n```\nC:\\Qt\\5.15.2\\mingw81_64\\bin\\moc.exe\n```\n\n执行moc\n\n```\n$ moc sender.h -o moc_sender.cpp\n$ moc reciver.h -o moc_reciver.cpp\n```\n\n完成后目录\n\n```\ntestSignalSlot\n├── main.cpp\n├── moc_reciver.cpp     (moc生成代码)\n├── moc_sender.cpp      (moc生成代码)\n├── reciver.cpp\n├── reciver.h\n├── sender.cpp\n└── sender.h\n```\n\n使用g++生成目标文件\n\n```\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o reciver.o reciver.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o sender.o sender.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_reciver.o moc_reciver.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_sender.o moc_sender.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o main.o main.cpp\n```\n\n生成可执行文件\n\n```\ng++ -o testSignalSlot.exe main.o reciver.o sender.o moc_reciver.o moc_sender.o  C:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\lib\\\\libQt5Core.a\n\n```\n到此编译完成，完成后目录:\n```\ntestSignalSlot\n├── testSignalSlot.exe\n├── main.cpp\n├── main.o\n├── moc_reciver.cpp\n├── moc_reciver.o\n├── moc_sender.cpp\n├── moc_sender.o\n├── reciver.cpp\n├── reciver.h\n├── reciver.o\n├── sender.cpp\n├── sender.h\n└── sender.o\n```\n\n运行验证一下:\n\n```\n$ ./testSignalSlot.exe\nHello Qt!\n```\n\n## 用标准C++完成一个简易的信号槽\n经过第一部分的了解后，我们知道元对象系统会使用moc工具对带有Q_OBJECT宏的头文件生成一份带有元对象信息的moc_xxx.cpp文件，那么我们应该可以手动编写moc_xxx.cpp代码,来完成moc所做的事情。\n接下来我们用标准C++来实现一个简易的信号槽机制，用以简单说明信号槽的实现原理。将手动编写以下几个文件，样例代码上传在github上。\n- [iso-cpp-reimp-signal-slot](https://github.com/liujianfengv/iso-cpp-reimp-signal-slot)\n\n```\n├── main.cpp\n├── moc_object.cpp\n├── object.cpp\n├── object.h\n```\n\n信号槽的实现大致需要以下几点\n\n- 类中应该保存有信号和槽的字符串信息\n- 字符串和信号槽函数要关联，有对应关系\n- 类实例中应该存有信号和监听该信号的reciver和槽函数的信息，通过connect借助字符串完成对象间信号和槽的关联\n- 信号触发时通过上述信息完成槽函数的调用\n\n所以，首先我们定义一个结构体，里面存放信号和槽的名称信息\n\n```\n//object.h\nstruct MetaObject\n{\n    const char * sig_names;     //存放信号函数字符串\n    const char * slts_names;    //存放槽函数字符串\n};\n...\n```\n\n并且将其作为一个静态成员变量放入Object类中,这样所有Object的实例就都拥有了信号和槽的字符串信息\n\n```\n//object.h\nclass Object\n{\n    static MetaObject meta;\n    ...\n```\n\n然后，在自己生成的moc_object.cpp文件中填充这个结构体信息， 当有多个信号或槽时，我们约定将所有信号的字符串连接起来并用'\\n'分割，这样每个信号或槽就有了一个对应的索引信息。 示例中使用信号 click 和 槽函数 onClick \n\n```\n//moc_object.cpp\nstatic const char sig_names[] = \"click\\n\";\nstatic const char slts_names[] = \"onClick\\n\";\nMetaObject Object::meta = {sig_names, slts_names};\n```\n\n接下来为每个对象保存连接信息，首先定义一个结构体。并定义一个mutimap作为Object的私有成员变量\n\n```\n//object.h\nstruct Connection\n{\n    Object *receiver;\n    int method;         //槽函数字符串索引\n};\ntypedef std::multimap<int, Connection> ConnectionMap;\n...\nclass Object{\n    ...\nprivate:\n    // key:信号函数索引 value:连接信息(接收者指针，接收者槽函数索引)\n     ConnectionMap connections;\n};\n```\n\n然后定义一个connect方法:\n\n```\nvoid Object::connect(Object* sender, const char* sig, Object* receiver, const char* slt)\n{\n    int sig_idx = find_substr_index(sender->meta.sig_names, sig);\n    int slt_idx = find_substr_index(receiver->meta.slts_names, slt);\n    if (sig_idx == -1 || slt_idx == -1) {\n        perror(\"signal or slot not found!\");\n    } else {\n        Connection c = {receiver, slt_idx};\n        sender->connections.insert(std::pair<int, Connection>(sig_idx, c));\n    }\n}\n```\n\n到此，类中的信号和槽相关信息都已经完成，接下来就是信号的触发了。\n\n```\n#define slots\n#define signals protected\n#define emit\n...\nsignals:\n    void click();\npublic slots:\n    void onClick();\n```\n\n信号和槽函数其实都是普通的函数，类似signals、slots关键字都只是一个标识，信号和槽的区别是，槽函数需要我们自己去实现，而信号函数会由moc替我们实现在moc_xxx.cpp文件中，而这里，我们需要自己去实现这个信号对应的函数。\n这里又用到之前的元对象,在其中添加active方法\n\n```\n//object.h\nstruct MetaObject\n{\n    const char * sig_names;     //存放信号函数字符串\n    const char * slts_names;    //存放槽函数字符串\n    static void active(Object * sender, int idx);\n};\n//object.cpp\nvoid MetaObject::active(Object* sender, int idx)\n{\n    auto ret = sender->connections.equal_range(idx);\n    for (auto it = ret.first; it != ret.second; ++it) {\n        Connection c = (*it).second;\n        //按索引调用receiver对应的槽函数\n        c.receiver->metacall(c.method);\n    }\n}\n//moc_object.cpp\nvoid Object::click()\n{\n    // 0 即为当前信号名字符串在meta.sig_names中的索引位置\n    MetaObject::active(this, 0);\n}\n\n//通过索引调用槽函数 \nvoid Object::metacall(int idx)\n{\n    switch (idx) {\n        case 0:\n        // 0 即为此槽函数名字符串在meta.slts_names中的索引位置\n            onClick();\n            break;\n        default:\n            break;\n    };\n}\n\n```\n\n至此，一个用C++实现的简单的信号槽就完成了，简单编译测试下\n\n```\ng++ main.cpp object.cpp moc_object.cpp -o test.exe\n$ ./test.exe\nHello Qt!\n```\n\n我现在使用的Qt版本是5.15.2，信号槽相关的源代码已经特别的多，充斥着各种宏和模板的奇计淫巧，还有多线程等其他特性相关的代码，看起来比较吃力，但也可以看到信号槽最基本的概念大体如此。这篇文章就先到这里，后续可能会写一篇对Qt5.15.2源代码中信号槽机制具体实现的分析。\n\n## 参考链接\n- [Using the Meta-Object Compiler (moc)](https://doc.qt.io/archives/qt-4.8/moc.html)\n- [用ISO C++实现自己的信号槽(Qt另类学习)](https://blog.csdn.net/dbzhang800/article/details/6376422)","source":"_posts/Qt信号槽机制浅析.md","raw":"---\ntitle: Qt信号槽机制浅析\ndate: 2021-11-02 22:39:24\ntags: Qt\n---\n\nQt是一个跨平台的C++软件开发框架，而Qt的核心机制是信号槽，关于信号槽，Qt官方的表述是:\n<!--more-->\n> Signals and slots are used for communication between objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. Signals and slots are made possible by Qt's meta-object system.\n\n信号和槽被用于对象间的沟通，信号槽机制是Qt的核心特点，也是Qt与其他应用框架的不同之处，信号槽的机制得益于Qt的元对象系统。\n下面分两步来对Qt的信号槽机制做一个简单分析。\n\n## 从Qt程序的编译过程讲起\n一个普通C++程序的编译需要经过以下几个步骤\n- 预处理(Prepressing): 主要处理源代码中以“#”开始的预编译命令，例如\"#include\"将被包含文件插入到该指令位置、 处理\"#if\"、\"ifdef\"等条件预编译指令、删除注释\n- 编译(Compilation): 将预处理完的文件进行词法分析、语法分析、语义分析生成相应的汇编代码文件\n- 汇编(Assembly): 将编译生成的汇编代码转化成机器可以执行的指令，生成目标文件\n- 链接(Linking): 组织汇编生成的目标文件和编译环境下相关的运行时库，将各个模块之间的相互引用部分处理好，使得各个模块间能够正确的衔接\nQt程序的编译与C++程序的编译主要区别在于moc系统\n\n> The Meta-Object Compiler, moc, is the program that handles Qt's C++ extensions. The moc tool reads a C++ header file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system\n\n元对象编译器是处理Qt的C++拓展程序， moc工具读取C++头文件，如果在文件中找到一个或多个Q_OBJECT宏，它将会生成一个包含对应类元对象代码的C++源文件，除此之外，元对象代码是信号槽机制、运行时类型信息、动态属性系统所必须的。\n一个最简单的不带界面和资源文件，只使用信号槽机制的Qt程序的编译过程就是，在普通C++程序编译的过程前对包含Q_OBJECT的类使用moc工具生成对应的元对象代码，即 元对象编译->预处理->编译->汇编->链接。\n下面用一个例子来验证。\n\n```\ntestSignalSlot\n├── main.cpp\n├── reciver.cpp\n├── reciver.h\n├── sender.cpp\n└── sender.h\n```\n\n```\n//reciver.h\n#ifndef RECIVER_H\n#define RECIVER_H\n\n#include <QObject>\n\nclass Reciver : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit Reciver(QObject *parent = nullptr);\npublic slots:\n    void recive();\n};\n\n#endif // RECIVER_H\n```\n```\n//reciver.cpp\n#include \"reciver.h\"\n\n#include <QDebug>\nReciver::Reciver(QObject *parent) : QObject(parent)\n{\n\n}\n\nvoid Reciver::recive()\n{\n    qDebug()<<\"Hello Qt!\";\n}\n\n```\n```\n//sender.h\n#ifndef SENDER_H\n#define SENDER_H\n\n#include <QObject>\n\nclass Sender : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit Sender(QObject *parent = nullptr);\n\nsignals:\n    void send();\n};\n\n#endif // SENDER_H\n```\n```\n//sender.cpp\n#include \"sender.h\"\n\nSender::Sender(QObject *parent) : QObject(parent)\n{\n}\n```\n```\nmain.cpp\n#include <QCoreApplication>\n\n#include \"sender.h\"\n#include \"reciver.h\"\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n    Sender sender;\n    Reciver reciver;\n    QObject::connect(&sender, &Sender::send,\n                     &reciver, &Reciver::recive);\n    emit sender.send();\n    return a.exec();\n}\n```\n\n首先使用moc工具为sender 和 reciver 生成moc代码 moc路径\n\n```\nC:\\Qt\\5.15.2\\mingw81_64\\bin\\moc.exe\n```\n\n执行moc\n\n```\n$ moc sender.h -o moc_sender.cpp\n$ moc reciver.h -o moc_reciver.cpp\n```\n\n完成后目录\n\n```\ntestSignalSlot\n├── main.cpp\n├── moc_reciver.cpp     (moc生成代码)\n├── moc_sender.cpp      (moc生成代码)\n├── reciver.cpp\n├── reciver.h\n├── sender.cpp\n└── sender.h\n```\n\n使用g++生成目标文件\n\n```\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o reciver.o reciver.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o sender.o sender.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_reciver.o moc_reciver.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_sender.o moc_sender.cpp\n$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o main.o main.cpp\n```\n\n生成可执行文件\n\n```\ng++ -o testSignalSlot.exe main.o reciver.o sender.o moc_reciver.o moc_sender.o  C:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\lib\\\\libQt5Core.a\n\n```\n到此编译完成，完成后目录:\n```\ntestSignalSlot\n├── testSignalSlot.exe\n├── main.cpp\n├── main.o\n├── moc_reciver.cpp\n├── moc_reciver.o\n├── moc_sender.cpp\n├── moc_sender.o\n├── reciver.cpp\n├── reciver.h\n├── reciver.o\n├── sender.cpp\n├── sender.h\n└── sender.o\n```\n\n运行验证一下:\n\n```\n$ ./testSignalSlot.exe\nHello Qt!\n```\n\n## 用标准C++完成一个简易的信号槽\n经过第一部分的了解后，我们知道元对象系统会使用moc工具对带有Q_OBJECT宏的头文件生成一份带有元对象信息的moc_xxx.cpp文件，那么我们应该可以手动编写moc_xxx.cpp代码,来完成moc所做的事情。\n接下来我们用标准C++来实现一个简易的信号槽机制，用以简单说明信号槽的实现原理。将手动编写以下几个文件，样例代码上传在github上。\n- [iso-cpp-reimp-signal-slot](https://github.com/liujianfengv/iso-cpp-reimp-signal-slot)\n\n```\n├── main.cpp\n├── moc_object.cpp\n├── object.cpp\n├── object.h\n```\n\n信号槽的实现大致需要以下几点\n\n- 类中应该保存有信号和槽的字符串信息\n- 字符串和信号槽函数要关联，有对应关系\n- 类实例中应该存有信号和监听该信号的reciver和槽函数的信息，通过connect借助字符串完成对象间信号和槽的关联\n- 信号触发时通过上述信息完成槽函数的调用\n\n所以，首先我们定义一个结构体，里面存放信号和槽的名称信息\n\n```\n//object.h\nstruct MetaObject\n{\n    const char * sig_names;     //存放信号函数字符串\n    const char * slts_names;    //存放槽函数字符串\n};\n...\n```\n\n并且将其作为一个静态成员变量放入Object类中,这样所有Object的实例就都拥有了信号和槽的字符串信息\n\n```\n//object.h\nclass Object\n{\n    static MetaObject meta;\n    ...\n```\n\n然后，在自己生成的moc_object.cpp文件中填充这个结构体信息， 当有多个信号或槽时，我们约定将所有信号的字符串连接起来并用'\\n'分割，这样每个信号或槽就有了一个对应的索引信息。 示例中使用信号 click 和 槽函数 onClick \n\n```\n//moc_object.cpp\nstatic const char sig_names[] = \"click\\n\";\nstatic const char slts_names[] = \"onClick\\n\";\nMetaObject Object::meta = {sig_names, slts_names};\n```\n\n接下来为每个对象保存连接信息，首先定义一个结构体。并定义一个mutimap作为Object的私有成员变量\n\n```\n//object.h\nstruct Connection\n{\n    Object *receiver;\n    int method;         //槽函数字符串索引\n};\ntypedef std::multimap<int, Connection> ConnectionMap;\n...\nclass Object{\n    ...\nprivate:\n    // key:信号函数索引 value:连接信息(接收者指针，接收者槽函数索引)\n     ConnectionMap connections;\n};\n```\n\n然后定义一个connect方法:\n\n```\nvoid Object::connect(Object* sender, const char* sig, Object* receiver, const char* slt)\n{\n    int sig_idx = find_substr_index(sender->meta.sig_names, sig);\n    int slt_idx = find_substr_index(receiver->meta.slts_names, slt);\n    if (sig_idx == -1 || slt_idx == -1) {\n        perror(\"signal or slot not found!\");\n    } else {\n        Connection c = {receiver, slt_idx};\n        sender->connections.insert(std::pair<int, Connection>(sig_idx, c));\n    }\n}\n```\n\n到此，类中的信号和槽相关信息都已经完成，接下来就是信号的触发了。\n\n```\n#define slots\n#define signals protected\n#define emit\n...\nsignals:\n    void click();\npublic slots:\n    void onClick();\n```\n\n信号和槽函数其实都是普通的函数，类似signals、slots关键字都只是一个标识，信号和槽的区别是，槽函数需要我们自己去实现，而信号函数会由moc替我们实现在moc_xxx.cpp文件中，而这里，我们需要自己去实现这个信号对应的函数。\n这里又用到之前的元对象,在其中添加active方法\n\n```\n//object.h\nstruct MetaObject\n{\n    const char * sig_names;     //存放信号函数字符串\n    const char * slts_names;    //存放槽函数字符串\n    static void active(Object * sender, int idx);\n};\n//object.cpp\nvoid MetaObject::active(Object* sender, int idx)\n{\n    auto ret = sender->connections.equal_range(idx);\n    for (auto it = ret.first; it != ret.second; ++it) {\n        Connection c = (*it).second;\n        //按索引调用receiver对应的槽函数\n        c.receiver->metacall(c.method);\n    }\n}\n//moc_object.cpp\nvoid Object::click()\n{\n    // 0 即为当前信号名字符串在meta.sig_names中的索引位置\n    MetaObject::active(this, 0);\n}\n\n//通过索引调用槽函数 \nvoid Object::metacall(int idx)\n{\n    switch (idx) {\n        case 0:\n        // 0 即为此槽函数名字符串在meta.slts_names中的索引位置\n            onClick();\n            break;\n        default:\n            break;\n    };\n}\n\n```\n\n至此，一个用C++实现的简单的信号槽就完成了，简单编译测试下\n\n```\ng++ main.cpp object.cpp moc_object.cpp -o test.exe\n$ ./test.exe\nHello Qt!\n```\n\n我现在使用的Qt版本是5.15.2，信号槽相关的源代码已经特别的多，充斥着各种宏和模板的奇计淫巧，还有多线程等其他特性相关的代码，看起来比较吃力，但也可以看到信号槽最基本的概念大体如此。这篇文章就先到这里，后续可能会写一篇对Qt5.15.2源代码中信号槽机制具体实现的分析。\n\n## 参考链接\n- [Using the Meta-Object Compiler (moc)](https://doc.qt.io/archives/qt-4.8/moc.html)\n- [用ISO C++实现自己的信号槽(Qt另类学习)](https://blog.csdn.net/dbzhang800/article/details/6376422)","slug":"Qt信号槽机制浅析","published":1,"updated":"2021-11-13T08:00:59.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0b4dtqd000cvsvieeawdfw7","content":"<p>Qt是一个跨平台的C++软件开发框架，而Qt的核心机制是信号槽，关于信号槽，Qt官方的表述是:</p>\n<span id=\"more\"></span>\n<blockquote>\n<p>Signals and slots are used for communication between objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. Signals and slots are made possible by Qt’s meta-object system.</p>\n</blockquote>\n<p>信号和槽被用于对象间的沟通，信号槽机制是Qt的核心特点，也是Qt与其他应用框架的不同之处，信号槽的机制得益于Qt的元对象系统。<br>下面分两步来对Qt的信号槽机制做一个简单分析。</p>\n<h2 id=\"从Qt程序的编译过程讲起\"><a href=\"#从Qt程序的编译过程讲起\" class=\"headerlink\" title=\"从Qt程序的编译过程讲起\"></a>从Qt程序的编译过程讲起</h2><p>一个普通C++程序的编译需要经过以下几个步骤</p>\n<ul>\n<li>预处理(Prepressing): 主要处理源代码中以“#”开始的预编译命令，例如”#include”将被包含文件插入到该指令位置、 处理”#if”、”ifdef”等条件预编译指令、删除注释</li>\n<li>编译(Compilation): 将预处理完的文件进行词法分析、语法分析、语义分析生成相应的汇编代码文件</li>\n<li>汇编(Assembly): 将编译生成的汇编代码转化成机器可以执行的指令，生成目标文件</li>\n<li>链接(Linking): 组织汇编生成的目标文件和编译环境下相关的运行时库，将各个模块之间的相互引用部分处理好，使得各个模块间能够正确的衔接<br>Qt程序的编译与C++程序的编译主要区别在于moc系统</li>\n</ul>\n<blockquote>\n<p>The Meta-Object Compiler, moc, is the program that handles Qt’s C++ extensions. The moc tool reads a C++ header file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system</p>\n</blockquote>\n<p>元对象编译器是处理Qt的C++拓展程序， moc工具读取C++头文件，如果在文件中找到一个或多个Q_OBJECT宏，它将会生成一个包含对应类元对象代码的C++源文件，除此之外，元对象代码是信号槽机制、运行时类型信息、动态属性系统所必须的。<br>一个最简单的不带界面和资源文件，只使用信号槽机制的Qt程序的编译过程就是，在普通C++程序编译的过程前对包含Q_OBJECT的类使用moc工具生成对应的元对象代码，即 元对象编译-&gt;预处理-&gt;编译-&gt;汇编-&gt;链接。<br>下面用一个例子来验证。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">testSignalSlot</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── reciver.cpp</span><br><span class=\"line\">├── reciver.h</span><br><span class=\"line\">├── sender.cpp</span><br><span class=\"line\">└── sender.h</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//reciver.h</span><br><span class=\"line\">#ifndef RECIVER_H</span><br><span class=\"line\">#define RECIVER_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Reciver : public QObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Reciver(QObject *parent = nullptr);</span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void recive();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // RECIVER_H</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//reciver.cpp</span><br><span class=\"line\">#include &quot;reciver.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\">Reciver::Reciver(QObject *parent) : QObject(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Reciver::recive()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    qDebug()&lt;&lt;&quot;Hello Qt!&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//sender.h</span><br><span class=\"line\">#ifndef SENDER_H</span><br><span class=\"line\">#define SENDER_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sender : public QObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Sender(QObject *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">signals:</span><br><span class=\"line\">    void send();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // SENDER_H</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//sender.cpp</span><br><span class=\"line\">#include &quot;sender.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Sender::Sender(QObject *parent) : QObject(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">main.cpp</span><br><span class=\"line\">#include &lt;QCoreApplication&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;sender.h&quot;</span><br><span class=\"line\">#include &quot;reciver.h&quot;</span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QCoreApplication a(argc, argv);</span><br><span class=\"line\">    Sender sender;</span><br><span class=\"line\">    Reciver reciver;</span><br><span class=\"line\">    QObject::connect(&amp;sender, &amp;Sender::send,</span><br><span class=\"line\">                     &amp;reciver, &amp;Reciver::recive);</span><br><span class=\"line\">    emit sender.send();</span><br><span class=\"line\">    return a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先使用moc工具为sender 和 reciver 生成moc代码 moc路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Qt\\5.15.2\\mingw81_64\\bin\\moc.exe</span><br></pre></td></tr></table></figure>\n\n<p>执行moc</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ moc sender.h -o moc_sender.cpp</span><br><span class=\"line\">$ moc reciver.h -o moc_reciver.cpp</span><br></pre></td></tr></table></figure>\n\n<p>完成后目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">testSignalSlot</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── moc_reciver.cpp     (moc生成代码)</span><br><span class=\"line\">├── moc_sender.cpp      (moc生成代码)</span><br><span class=\"line\">├── reciver.cpp</span><br><span class=\"line\">├── reciver.h</span><br><span class=\"line\">├── sender.cpp</span><br><span class=\"line\">└── sender.h</span><br></pre></td></tr></table></figure>\n\n<p>使用g++生成目标文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o reciver.o reciver.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o sender.o sender.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_reciver.o moc_reciver.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_sender.o moc_sender.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o main.o main.cpp</span><br></pre></td></tr></table></figure>\n\n<p>生成可执行文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -o testSignalSlot.exe main.o reciver.o sender.o moc_reciver.o moc_sender.o  C:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\lib\\\\libQt5Core.a</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>到此编译完成，完成后目录:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">testSignalSlot</span><br><span class=\"line\">├── testSignalSlot.exe</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── main.o</span><br><span class=\"line\">├── moc_reciver.cpp</span><br><span class=\"line\">├── moc_reciver.o</span><br><span class=\"line\">├── moc_sender.cpp</span><br><span class=\"line\">├── moc_sender.o</span><br><span class=\"line\">├── reciver.cpp</span><br><span class=\"line\">├── reciver.h</span><br><span class=\"line\">├── reciver.o</span><br><span class=\"line\">├── sender.cpp</span><br><span class=\"line\">├── sender.h</span><br><span class=\"line\">└── sender.o</span><br></pre></td></tr></table></figure>\n\n<p>运行验证一下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./testSignalSlot.exe</span><br><span class=\"line\">Hello Qt!</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用标准C-完成一个简易的信号槽\"><a href=\"#用标准C-完成一个简易的信号槽\" class=\"headerlink\" title=\"用标准C++完成一个简易的信号槽\"></a>用标准C++完成一个简易的信号槽</h2><p>经过第一部分的了解后，我们知道元对象系统会使用moc工具对带有Q_OBJECT宏的头文件生成一份带有元对象信息的moc_xxx.cpp文件，那么我们应该可以手动编写moc_xxx.cpp代码,来完成moc所做的事情。<br>接下来我们用标准C++来实现一个简易的信号槽机制，用以简单说明信号槽的实现原理。将手动编写以下几个文件，样例代码上传在github上。</p>\n<ul>\n<li><a href=\"https://github.com/liujianfengv/iso-cpp-reimp-signal-slot\">iso-cpp-reimp-signal-slot</a></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── moc_object.cpp</span><br><span class=\"line\">├── object.cpp</span><br><span class=\"line\">├── object.h</span><br></pre></td></tr></table></figure>\n\n<p>信号槽的实现大致需要以下几点</p>\n<ul>\n<li>类中应该保存有信号和槽的字符串信息</li>\n<li>字符串和信号槽函数要关联，有对应关系</li>\n<li>类实例中应该存有信号和监听该信号的reciver和槽函数的信息，通过connect借助字符串完成对象间信号和槽的关联</li>\n<li>信号触发时通过上述信息完成槽函数的调用</li>\n</ul>\n<p>所以，首先我们定义一个结构体，里面存放信号和槽的名称信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">struct MetaObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const char * sig_names;     //存放信号函数字符串</span><br><span class=\"line\">    const char * slts_names;    //存放槽函数字符串</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>并且将其作为一个静态成员变量放入Object类中,这样所有Object的实例就都拥有了信号和槽的字符串信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">class Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static MetaObject meta;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>然后，在自己生成的moc_object.cpp文件中填充这个结构体信息， 当有多个信号或槽时，我们约定将所有信号的字符串连接起来并用’\\n’分割，这样每个信号或槽就有了一个对应的索引信息。 示例中使用信号 click 和 槽函数 onClick </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//moc_object.cpp</span><br><span class=\"line\">static const char sig_names[] = &quot;click\\n&quot;;</span><br><span class=\"line\">static const char slts_names[] = &quot;onClick\\n&quot;;</span><br><span class=\"line\">MetaObject Object::meta = &#123;sig_names, slts_names&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接下来为每个对象保存连接信息，首先定义一个结构体。并定义一个mutimap作为Object的私有成员变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">struct Connection</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Object *receiver;</span><br><span class=\"line\">    int method;         //槽函数字符串索引</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">typedef std::multimap&lt;int, Connection&gt; ConnectionMap;</span><br><span class=\"line\">...</span><br><span class=\"line\">class Object&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // key:信号函数索引 value:连接信息(接收者指针，接收者槽函数索引)</span><br><span class=\"line\">     ConnectionMap connections;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后定义一个connect方法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">void Object::connect(Object* sender, const char* sig, Object* receiver, const char* slt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int sig_idx = find_substr_index(sender-&gt;meta.sig_names, sig);</span><br><span class=\"line\">    int slt_idx = find_substr_index(receiver-&gt;meta.slts_names, slt);</span><br><span class=\"line\">    if (sig_idx == -1 || slt_idx == -1) &#123;</span><br><span class=\"line\">        perror(&quot;signal or slot not found!&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        Connection c = &#123;receiver, slt_idx&#125;;</span><br><span class=\"line\">        sender-&gt;connections.insert(std::pair&lt;int, Connection&gt;(sig_idx, c));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到此，类中的信号和槽相关信息都已经完成，接下来就是信号的触发了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define slots</span><br><span class=\"line\">#define signals protected</span><br><span class=\"line\">#define emit</span><br><span class=\"line\">...</span><br><span class=\"line\">signals:</span><br><span class=\"line\">    void click();</span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void onClick();</span><br></pre></td></tr></table></figure>\n\n<p>信号和槽函数其实都是普通的函数，类似signals、slots关键字都只是一个标识，信号和槽的区别是，槽函数需要我们自己去实现，而信号函数会由moc替我们实现在moc_xxx.cpp文件中，而这里，我们需要自己去实现这个信号对应的函数。<br>这里又用到之前的元对象,在其中添加active方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">struct MetaObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const char * sig_names;     //存放信号函数字符串</span><br><span class=\"line\">    const char * slts_names;    //存放槽函数字符串</span><br><span class=\"line\">    static void active(Object * sender, int idx);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//object.cpp</span><br><span class=\"line\">void MetaObject::active(Object* sender, int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto ret = sender-&gt;connections.equal_range(idx);</span><br><span class=\"line\">    for (auto it = ret.first; it != ret.second; ++it) &#123;</span><br><span class=\"line\">        Connection c = (*it).second;</span><br><span class=\"line\">        //按索引调用receiver对应的槽函数</span><br><span class=\"line\">        c.receiver-&gt;metacall(c.method);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//moc_object.cpp</span><br><span class=\"line\">void Object::click()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 0 即为当前信号名字符串在meta.sig_names中的索引位置</span><br><span class=\"line\">    MetaObject::active(this, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//通过索引调用槽函数 </span><br><span class=\"line\">void Object::metacall(int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    switch (idx) &#123;</span><br><span class=\"line\">        case 0:</span><br><span class=\"line\">        // 0 即为此槽函数名字符串在meta.slts_names中的索引位置</span><br><span class=\"line\">            onClick();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>至此，一个用C++实现的简单的信号槽就完成了，简单编译测试下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ main.cpp object.cpp moc_object.cpp -o test.exe</span><br><span class=\"line\">$ ./test.exe</span><br><span class=\"line\">Hello Qt!</span><br></pre></td></tr></table></figure>\n\n<p>我现在使用的Qt版本是5.15.2，信号槽相关的源代码已经特别的多，充斥着各种宏和模板的奇计淫巧，还有多线程等其他特性相关的代码，看起来比较吃力，但也可以看到信号槽最基本的概念大体如此。这篇文章就先到这里，后续可能会写一篇对Qt5.15.2源代码中信号槽机制具体实现的分析。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://doc.qt.io/archives/qt-4.8/moc.html\">Using the Meta-Object Compiler (moc)</a></li>\n<li><a href=\"https://blog.csdn.net/dbzhang800/article/details/6376422\">用ISO C++实现自己的信号槽(Qt另类学习)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Qt是一个跨平台的C++软件开发框架，而Qt的核心机制是信号槽，关于信号槽，Qt官方的表述是:</p>","more":"<blockquote>\n<p>Signals and slots are used for communication between objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. Signals and slots are made possible by Qt’s meta-object system.</p>\n</blockquote>\n<p>信号和槽被用于对象间的沟通，信号槽机制是Qt的核心特点，也是Qt与其他应用框架的不同之处，信号槽的机制得益于Qt的元对象系统。<br>下面分两步来对Qt的信号槽机制做一个简单分析。</p>\n<h2 id=\"从Qt程序的编译过程讲起\"><a href=\"#从Qt程序的编译过程讲起\" class=\"headerlink\" title=\"从Qt程序的编译过程讲起\"></a>从Qt程序的编译过程讲起</h2><p>一个普通C++程序的编译需要经过以下几个步骤</p>\n<ul>\n<li>预处理(Prepressing): 主要处理源代码中以“#”开始的预编译命令，例如”#include”将被包含文件插入到该指令位置、 处理”#if”、”ifdef”等条件预编译指令、删除注释</li>\n<li>编译(Compilation): 将预处理完的文件进行词法分析、语法分析、语义分析生成相应的汇编代码文件</li>\n<li>汇编(Assembly): 将编译生成的汇编代码转化成机器可以执行的指令，生成目标文件</li>\n<li>链接(Linking): 组织汇编生成的目标文件和编译环境下相关的运行时库，将各个模块之间的相互引用部分处理好，使得各个模块间能够正确的衔接<br>Qt程序的编译与C++程序的编译主要区别在于moc系统</li>\n</ul>\n<blockquote>\n<p>The Meta-Object Compiler, moc, is the program that handles Qt’s C++ extensions. The moc tool reads a C++ header file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system</p>\n</blockquote>\n<p>元对象编译器是处理Qt的C++拓展程序， moc工具读取C++头文件，如果在文件中找到一个或多个Q_OBJECT宏，它将会生成一个包含对应类元对象代码的C++源文件，除此之外，元对象代码是信号槽机制、运行时类型信息、动态属性系统所必须的。<br>一个最简单的不带界面和资源文件，只使用信号槽机制的Qt程序的编译过程就是，在普通C++程序编译的过程前对包含Q_OBJECT的类使用moc工具生成对应的元对象代码，即 元对象编译-&gt;预处理-&gt;编译-&gt;汇编-&gt;链接。<br>下面用一个例子来验证。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">testSignalSlot</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── reciver.cpp</span><br><span class=\"line\">├── reciver.h</span><br><span class=\"line\">├── sender.cpp</span><br><span class=\"line\">└── sender.h</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//reciver.h</span><br><span class=\"line\">#ifndef RECIVER_H</span><br><span class=\"line\">#define RECIVER_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Reciver : public QObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Reciver(QObject *parent = nullptr);</span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void recive();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // RECIVER_H</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//reciver.cpp</span><br><span class=\"line\">#include &quot;reciver.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QDebug&gt;</span><br><span class=\"line\">Reciver::Reciver(QObject *parent) : QObject(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Reciver::recive()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    qDebug()&lt;&lt;&quot;Hello Qt!&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//sender.h</span><br><span class=\"line\">#ifndef SENDER_H</span><br><span class=\"line\">#define SENDER_H</span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;QObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sender : public QObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Q_OBJECT</span><br><span class=\"line\">public:</span><br><span class=\"line\">    explicit Sender(QObject *parent = nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">signals:</span><br><span class=\"line\">    void send();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#endif // SENDER_H</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//sender.cpp</span><br><span class=\"line\">#include &quot;sender.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Sender::Sender(QObject *parent) : QObject(parent)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">main.cpp</span><br><span class=\"line\">#include &lt;QCoreApplication&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;sender.h&quot;</span><br><span class=\"line\">#include &quot;reciver.h&quot;</span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QCoreApplication a(argc, argv);</span><br><span class=\"line\">    Sender sender;</span><br><span class=\"line\">    Reciver reciver;</span><br><span class=\"line\">    QObject::connect(&amp;sender, &amp;Sender::send,</span><br><span class=\"line\">                     &amp;reciver, &amp;Reciver::recive);</span><br><span class=\"line\">    emit sender.send();</span><br><span class=\"line\">    return a.exec();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先使用moc工具为sender 和 reciver 生成moc代码 moc路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Qt\\5.15.2\\mingw81_64\\bin\\moc.exe</span><br></pre></td></tr></table></figure>\n\n<p>执行moc</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ moc sender.h -o moc_sender.cpp</span><br><span class=\"line\">$ moc reciver.h -o moc_reciver.cpp</span><br></pre></td></tr></table></figure>\n\n<p>完成后目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">testSignalSlot</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── moc_reciver.cpp     (moc生成代码)</span><br><span class=\"line\">├── moc_sender.cpp      (moc生成代码)</span><br><span class=\"line\">├── reciver.cpp</span><br><span class=\"line\">├── reciver.h</span><br><span class=\"line\">├── sender.cpp</span><br><span class=\"line\">└── sender.h</span><br></pre></td></tr></table></figure>\n\n<p>使用g++生成目标文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o reciver.o reciver.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o sender.o sender.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_reciver.o moc_reciver.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o moc_sender.o moc_sender.cpp</span><br><span class=\"line\">$ g++ -c  -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include -IC:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\include\\\\QtCore  -o main.o main.cpp</span><br></pre></td></tr></table></figure>\n\n<p>生成可执行文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -o testSignalSlot.exe main.o reciver.o sender.o moc_reciver.o moc_sender.o  C:\\\\Qt\\\\5.15.2\\\\mingw81_64\\\\lib\\\\libQt5Core.a</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>到此编译完成，完成后目录:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">testSignalSlot</span><br><span class=\"line\">├── testSignalSlot.exe</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── main.o</span><br><span class=\"line\">├── moc_reciver.cpp</span><br><span class=\"line\">├── moc_reciver.o</span><br><span class=\"line\">├── moc_sender.cpp</span><br><span class=\"line\">├── moc_sender.o</span><br><span class=\"line\">├── reciver.cpp</span><br><span class=\"line\">├── reciver.h</span><br><span class=\"line\">├── reciver.o</span><br><span class=\"line\">├── sender.cpp</span><br><span class=\"line\">├── sender.h</span><br><span class=\"line\">└── sender.o</span><br></pre></td></tr></table></figure>\n\n<p>运行验证一下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./testSignalSlot.exe</span><br><span class=\"line\">Hello Qt!</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用标准C-完成一个简易的信号槽\"><a href=\"#用标准C-完成一个简易的信号槽\" class=\"headerlink\" title=\"用标准C++完成一个简易的信号槽\"></a>用标准C++完成一个简易的信号槽</h2><p>经过第一部分的了解后，我们知道元对象系统会使用moc工具对带有Q_OBJECT宏的头文件生成一份带有元对象信息的moc_xxx.cpp文件，那么我们应该可以手动编写moc_xxx.cpp代码,来完成moc所做的事情。<br>接下来我们用标准C++来实现一个简易的信号槽机制，用以简单说明信号槽的实现原理。将手动编写以下几个文件，样例代码上传在github上。</p>\n<ul>\n<li><a href=\"https://github.com/liujianfengv/iso-cpp-reimp-signal-slot\">iso-cpp-reimp-signal-slot</a></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── moc_object.cpp</span><br><span class=\"line\">├── object.cpp</span><br><span class=\"line\">├── object.h</span><br></pre></td></tr></table></figure>\n\n<p>信号槽的实现大致需要以下几点</p>\n<ul>\n<li>类中应该保存有信号和槽的字符串信息</li>\n<li>字符串和信号槽函数要关联，有对应关系</li>\n<li>类实例中应该存有信号和监听该信号的reciver和槽函数的信息，通过connect借助字符串完成对象间信号和槽的关联</li>\n<li>信号触发时通过上述信息完成槽函数的调用</li>\n</ul>\n<p>所以，首先我们定义一个结构体，里面存放信号和槽的名称信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">struct MetaObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const char * sig_names;     //存放信号函数字符串</span><br><span class=\"line\">    const char * slts_names;    //存放槽函数字符串</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>并且将其作为一个静态成员变量放入Object类中,这样所有Object的实例就都拥有了信号和槽的字符串信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">class Object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static MetaObject meta;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>然后，在自己生成的moc_object.cpp文件中填充这个结构体信息， 当有多个信号或槽时，我们约定将所有信号的字符串连接起来并用’\\n’分割，这样每个信号或槽就有了一个对应的索引信息。 示例中使用信号 click 和 槽函数 onClick </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//moc_object.cpp</span><br><span class=\"line\">static const char sig_names[] = &quot;click\\n&quot;;</span><br><span class=\"line\">static const char slts_names[] = &quot;onClick\\n&quot;;</span><br><span class=\"line\">MetaObject Object::meta = &#123;sig_names, slts_names&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接下来为每个对象保存连接信息，首先定义一个结构体。并定义一个mutimap作为Object的私有成员变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">struct Connection</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Object *receiver;</span><br><span class=\"line\">    int method;         //槽函数字符串索引</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">typedef std::multimap&lt;int, Connection&gt; ConnectionMap;</span><br><span class=\"line\">...</span><br><span class=\"line\">class Object&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">private:</span><br><span class=\"line\">    // key:信号函数索引 value:连接信息(接收者指针，接收者槽函数索引)</span><br><span class=\"line\">     ConnectionMap connections;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后定义一个connect方法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">void Object::connect(Object* sender, const char* sig, Object* receiver, const char* slt)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int sig_idx = find_substr_index(sender-&gt;meta.sig_names, sig);</span><br><span class=\"line\">    int slt_idx = find_substr_index(receiver-&gt;meta.slts_names, slt);</span><br><span class=\"line\">    if (sig_idx == -1 || slt_idx == -1) &#123;</span><br><span class=\"line\">        perror(&quot;signal or slot not found!&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        Connection c = &#123;receiver, slt_idx&#125;;</span><br><span class=\"line\">        sender-&gt;connections.insert(std::pair&lt;int, Connection&gt;(sig_idx, c));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到此，类中的信号和槽相关信息都已经完成，接下来就是信号的触发了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define slots</span><br><span class=\"line\">#define signals protected</span><br><span class=\"line\">#define emit</span><br><span class=\"line\">...</span><br><span class=\"line\">signals:</span><br><span class=\"line\">    void click();</span><br><span class=\"line\">public slots:</span><br><span class=\"line\">    void onClick();</span><br></pre></td></tr></table></figure>\n\n<p>信号和槽函数其实都是普通的函数，类似signals、slots关键字都只是一个标识，信号和槽的区别是，槽函数需要我们自己去实现，而信号函数会由moc替我们实现在moc_xxx.cpp文件中，而这里，我们需要自己去实现这个信号对应的函数。<br>这里又用到之前的元对象,在其中添加active方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//object.h</span><br><span class=\"line\">struct MetaObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const char * sig_names;     //存放信号函数字符串</span><br><span class=\"line\">    const char * slts_names;    //存放槽函数字符串</span><br><span class=\"line\">    static void active(Object * sender, int idx);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//object.cpp</span><br><span class=\"line\">void MetaObject::active(Object* sender, int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto ret = sender-&gt;connections.equal_range(idx);</span><br><span class=\"line\">    for (auto it = ret.first; it != ret.second; ++it) &#123;</span><br><span class=\"line\">        Connection c = (*it).second;</span><br><span class=\"line\">        //按索引调用receiver对应的槽函数</span><br><span class=\"line\">        c.receiver-&gt;metacall(c.method);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//moc_object.cpp</span><br><span class=\"line\">void Object::click()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 0 即为当前信号名字符串在meta.sig_names中的索引位置</span><br><span class=\"line\">    MetaObject::active(this, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//通过索引调用槽函数 </span><br><span class=\"line\">void Object::metacall(int idx)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    switch (idx) &#123;</span><br><span class=\"line\">        case 0:</span><br><span class=\"line\">        // 0 即为此槽函数名字符串在meta.slts_names中的索引位置</span><br><span class=\"line\">            onClick();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>至此，一个用C++实现的简单的信号槽就完成了，简单编译测试下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ main.cpp object.cpp moc_object.cpp -o test.exe</span><br><span class=\"line\">$ ./test.exe</span><br><span class=\"line\">Hello Qt!</span><br></pre></td></tr></table></figure>\n\n<p>我现在使用的Qt版本是5.15.2，信号槽相关的源代码已经特别的多，充斥着各种宏和模板的奇计淫巧，还有多线程等其他特性相关的代码，看起来比较吃力，但也可以看到信号槽最基本的概念大体如此。这篇文章就先到这里，后续可能会写一篇对Qt5.15.2源代码中信号槽机制具体实现的分析。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://doc.qt.io/archives/qt-4.8/moc.html\">Using the Meta-Object Compiler (moc)</a></li>\n<li><a href=\"https://blog.csdn.net/dbzhang800/article/details/6376422\">用ISO C++实现自己的信号槽(Qt另类学习)</a></li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/MQTT基础文档翻译-二-发布和订阅/mqtt-publish-subscribe.svg","slug":"mqtt-publish-subscribe.svg","post":"cl0b4dtq80003vsvi8eqdf8yy","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connack1.png","slug":"connack1.png","post":"cl0b4dtq90004vsvi89p18g8s","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connect-flow.gif","slug":"connect-flow.gif","post":"cl0b4dtq90004vsvi89p18g8s","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/connect.png","slug":"connect.png","post":"cl0b4dtq90004vsvi89p18g8s","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/mqtt-tcp-ip-stack.png","slug":"mqtt-tcp-ip-stack.png","post":"cl0b4dtq90004vsvi89p18g8s","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-三-MQTT客户端和Broker和MQTT服务器和连接建立的解释/retcode.png","slug":"retcode.png","post":"cl0b4dtq90004vsvi89p18g8s","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_basics.png","slug":"topic_basics.png","post":"cl0b4dtq90005vsvi36ozc3hl","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_hash.png","slug":"topic_wildcard_hash.png","post":"cl0b4dtq90005vsvi36ozc3hl","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_plus.png","slug":"topic_wildcard_plus.png","post":"cl0b4dtq90005vsvi36ozc3hl","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-五-话题和相关的实践/topic_wildcard_plus_example.png","slug":"topic_wildcard_plus_example.png","post":"cl0b4dtq90005vsvi36ozc3hl","modified":0,"renderable":0},{"_id":"source/_posts/ProtoBuf为什么比Json快/debug_protoc.png","slug":"debug_protoc.png","post":"cl0b4dtqb0009vsvi1dg84rek","modified":0,"renderable":0},{"_id":"source/_posts/ProtoBuf为什么比Json快/wire_types.png","slug":"wire_types.png","post":"cl0b4dtqb0009vsvi1dg84rek","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/publish_flow.png","slug":"publish_flow.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/publish_packet.png","slug":"publish_packet.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/return_code.png","slug":"return_code.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/suback_packet.png","slug":"suback_packet.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/subscribe_flow.png","slug":"subscribe_flow.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/subscribe_packet.png","slug":"subscribe_packet.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsuback_packet.png","slug":"unsuback_packet.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsubscribe_flow.png","slug":"unsubscribe_flow.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0},{"_id":"source/_posts/MQTT基础文档翻译-四-发布、订阅和取消订阅/unsubscribe_packet.png","slug":"unsubscribe_packet.png","post":"cl0b4dtqa0008vsvifnyj9w9i","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cl0b4dtq20000vsvi0e1fck8x","tag_id":"cl0b4dtq70002vsvibhd4hg75","_id":"cl0b4dtqa0007vsvi9dp6f5tz"},{"post_id":"cl0b4dtqa0008vsvifnyj9w9i","tag_id":"cl0b4dtqa0006vsvieaqie8tu","_id":"cl0b4dtqd000bvsvidcjnf76z"},{"post_id":"cl0b4dtq60001vsvi7rp6f8yw","tag_id":"cl0b4dtqa0006vsvieaqie8tu","_id":"cl0b4dtqd000dvsvi8rl6gdlu"},{"post_id":"cl0b4dtq80003vsvi8eqdf8yy","tag_id":"cl0b4dtqa0006vsvieaqie8tu","_id":"cl0b4dtqe000fvsviewcd4cyn"},{"post_id":"cl0b4dtq90004vsvi89p18g8s","tag_id":"cl0b4dtqa0006vsvieaqie8tu","_id":"cl0b4dtqe000hvsvi0inp8dbe"},{"post_id":"cl0b4dtq90005vsvi36ozc3hl","tag_id":"cl0b4dtqa0006vsvieaqie8tu","_id":"cl0b4dtqe000jvsvi5jybfjoz"},{"post_id":"cl0b4dtqb0009vsvi1dg84rek","tag_id":"cl0b4dtqe000ivsvi5jr357z8","_id":"cl0b4dtqf000lvsviclsl0g64"},{"post_id":"cl0b4dtqd000cvsvieeawdfw7","tag_id":"cl0b4dtqe000kvsvi5a7q1y77","_id":"cl0b4dtqf000mvsvi0zdgf6ts"}],"Tag":[{"name":"C++、shared_ptr","_id":"cl0b4dtq70002vsvibhd4hg75"},{"name":"MQTT","_id":"cl0b4dtqa0006vsvieaqie8tu"},{"name":"Protobuf","_id":"cl0b4dtqe000ivsvi5jr357z8"},{"name":"Qt","_id":"cl0b4dtqe000kvsvi5a7q1y77"}]}}